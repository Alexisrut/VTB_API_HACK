This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  capybara.webp
  kitty.webp
  vite.svg
src/
  assets/
    react.svg
  components/
    BankAccountList/
      index.module.scss
      index.tsx
    CashFlowChart/
      index.module.scss
      index.tsx
    Layout/
      index.module.scss
      index.tsx
    Loader/
      index.module.scss
      index.tsx
    ReceivablesTable/
      index.module.scss
      index.tsx
    StatCard/
      index.module.scss
      index.tsx
  hooks/
    context.tsx
    useAuth.ts
  pages/
    Auth/
      AuthForm.module.scss
      AuthForm.tsx
      index.module.scss
      index.tsx
      OAuthSuccess.module.scss
      OAuthSuccess.tsx
    CashFlow/
      index.module.scss
      index.tsx
    Health/
      index.module.scss
      index.tsx
    home/
      index.module.scss
      index.tsx
    Landing/
      index.module.scss
      index.tsx
    NotFound/
      index.module.scss
      index.tsx
    Payments/
      index.module.scss
      index.tsx
    Profile/
      index.module.scss
      index.tsx
    Receivables/
      index.module.scss
      index.tsx
    Settings/
      index.module.scss
      index.tsx
  styles/
    colors.ts
    globals.scss
    main.scss
    mixins.scss
    vars.scss
  ui/
    badge/
      index.module.scss
      index.tsx
    button/
      index.module.scss
      index.tsx
    card/
      index.module.scss
      index.tsx
    input/
      index.module.scss
      index.tsx
    label/
      index.module.scss
      index.tsx
    sonner/
      index.tsx
      sonner.module.scss
    table/
      index.module.scss
      index.tsx
    tooltip/
      index.module.scss
      index.tsx
  utils/
    api.ts
    cookies.ts
    zod.ts
  App.tsx
  main.tsx
.dockerignore
.gitignore
Dockerfile
Dockerfile.dev
eslint.config.js
index.html
nginx.conf
openapi.json
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/BankAccountList/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.bankCard {
  @include glass-card(false);
  border: 2px solid $glass-border;
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

}

.bankCardHeader {
  gap: 0.75rem;
}

.headerGroup {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.headerIconBg {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius;
  background-color: rgba($accent, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.headerIcon {
  height: 1.25rem;
  width: 1.25rem;
  color: $accent;
}

.bankCardTitle {
  font-weight: 700;
}

.bankCardSubtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.bankCardContent {
  padding-top: 0.5rem;
}

.accountList {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}


.accountItem {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1.25rem; 
  border-radius: $radius * 1.2;
  border: 1px solid rgba($border, 0.5);
  background-color: rgba($secondary, 0.3);
  transition: all 0.3s ease;

  &:hover {
    background-color: rgba($secondary, 0.5);
    border-color: rgba($accent, 0.3);
  }
}

.itemDetails {
  display: flex;
  align-items: center;
  gap: 1rem;
}


.itemIconBg {
  height: 3rem;
  width: 3rem;
  flex-shrink: 0;
  border-radius: $radius;
  background-color: rgba($accent, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;

  .accountItem:hover & {
    background-color: rgba($accent, 0.3);
  }
}

.itemIcon {
  height: 1.5rem;
  width: 1.5rem;
  color: $accent;
}

.itemBank {
  font-weight: 700;
  color: $foreground;
  font-size: 1.125rem;
}

.itemSync {
  font-size: 0.75rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.itemBalance {
  text-align: right;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
}

.balanceAmount {
  font-size: 1.25rem;
  font-weight: 700;
  color: $foreground;
}

.statusBadge {
  background-color: rgba($accent, 0.2);
  color: $accent;
  border-color: rgba($accent, 0.3);
  &:hover {
    background-color: rgba($accent, 0.3);
  }
}
</file>

<file path="src/components/BankAccountList/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Building2 } from "lucide-react";
import { useEffect, useState } from "react";
import { getAllBankAccounts, getAccountBalances, extractBalanceFromResponse, getAccountId, type BankAccount } from "../../utils/api";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";

interface AccountDisplay {
  bank: string;
  balance: number;
  currency: string;
  lastSync: string;
  status: string;
  accountId: string;
}

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return "только что";
  if (diffMins < 60) return `${diffMins} мин назад`;
  if (diffHours < 24) return `${diffHours} час${diffHours > 1 ? "а" : ""} назад`;
  return `${diffDays} дн${diffDays > 1 ? "ей" : "ь"} назад`;
}

function getAccountBalance(account: BankAccount): number {
  if (!account.balances || account.balances.length === 0) return 0;
  
  // Ищем баланс типа "InterimAvailable" или "InterimBooked"
  const balance = account.balances.find(
    (b) => b.balanceType === "InterimAvailable" || b.balanceType === "InterimBooked"
  ) || account.balances[0];
  
  return parseFloat(balance.balanceAmount.amount) || 0;
}

export default function BankAccountsList() {
  const { isAuthenticated } = useAuth();
  const [accounts, setAccounts] = useState<AccountDisplay[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastSyncTime, setLastSyncTime] = useState<Date>(new Date());

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockAccounts: AccountDisplay[] = [
      {
        bank: "Vbank",
        balance: 1250000,
        currency: "₽",
        lastSync: "только что",
        status: "active",
        accountId: "vtb-account-1",
      },
      {
        bank: "Abank",
        balance: 850000,
        currency: "₽",
        lastSync: "только что",
        status: "active",
        accountId: "sber-account-1",
      },
      {
        bank: "Sbank",
        balance: 350000,
        currency: "₽",
        lastSync: "только что",
        status: "active",
        accountId: "alpha-account-1",
      },
    ];

    setTimeout(() => {
      setAccounts(mockAccounts);
      setLastSyncTime(new Date());
      setIsLoading(false);
    }, 400);

    /* Закомментирован реальный API вызов
    const fetchAccounts = async () => {
      try {
        setIsLoading(true);
        setError(null);
        console.log("[BankAccountList] Fetching accounts...");
        const response = await getAllBankAccounts();
        const data = response.data;
        
        console.log("[BankAccountList] Accounts response:", data);

        if (!data.success) {
          throw new Error("Не удалось получить счета");
        }

        const accountsList: AccountDisplay[] = [];
        const balancePromises: Promise<void>[] = [];

        // Обрабатываем счета из всех банков
        Object.entries(data.banks || {}).forEach(([bankCode, bankData]) => {
          console.log(`[BankAccountList] Processing bank ${bankCode}:`, bankData);
          
          if (bankData.success && bankData.accounts) {
            console.log(`[BankAccountList] Bank ${bankCode} has ${bankData.accounts.length} accounts`);
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              if (!accountId) {
                console.warn(`[BankAccountList] Skipping account without account_id:`, account);
                return;
              }
              
              // Используем баланс из данных счета как начальное значение
              const initialBalance = getAccountBalance(account);
              const currency = account.currency || account.balances?.[0]?.balanceAmount?.currency || "RUB";
              
              const accountDisplay: AccountDisplay = {
                bank: bankNames[bankCode] || bankCode,
                balance: initialBalance,
                currency: currency === "RUB" ? "₽" : currency,
                lastSync: formatTimeAgo(lastSyncTime),
                status: "active",
                accountId: accountId,
              };
              
              accountsList.push(accountDisplay);
              
              // Запрашиваем актуальный баланс через API
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id
              )
                .then((response) => {
                  console.log(`[BankAccountList] Balance for account ${accountId}:`, response.data);
                  
                  // Извлекаем баланс из ответа
                  const newBalance = extractBalanceFromResponse(response);
                  console.log(`[BankAccountList] Extracted balance for ${accountId}:`, newBalance);
                  
                  // Обновляем баланс в списке (может быть отрицательным для овердрафта)
                  setAccounts((prev) =>
                    prev.map((acc) =>
                      acc.accountId === accountId
                        ? { ...acc, balance: newBalance }
                        : acc
                    )
                  );
                })
                .catch((err) => {
                  console.error(`[BankAccountList] Error fetching balance for account ${accountId}:`, err);
                  // Не показываем ошибку пользователю, просто используем начальный баланс
                });
              
              balancePromises.push(balancePromise);
            });
          } else {
            const errorMsg = bankData.error || "No accounts";
            console.warn(`[BankAccountList] Bank ${bankCode} failed or has no accounts:`, errorMsg);
            
            // Show helpful message if bank_user_id is missing
            if (errorMsg.includes("bank_user_id") || errorMsg.includes("Please set")) {
              setError(`Для банка ${bankNames[bankCode] || bankCode} необходимо установить ID пользователя в профиле. ${errorMsg}`);
            }
          }
        });

        console.log(`[BankAccountList] Total accounts found: ${accountsList.length}`);
        setAccounts(accountsList);
        setLastSyncTime(new Date());
        
        // Ждем завершения всех запросов балансов (в фоне, не блокируя UI)
        Promise.all(balancePromises).then(() => {
          console.log(`[BankAccountList] All balance requests completed`);
        });
      } catch (err: any) {
        console.error("[BankAccountList] Error fetching bank accounts:", err);
        console.error("[BankAccountList] Error details:", {
          message: err.message,
          response: err.response?.data,
          status: err.response?.status,
        });
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки счетов");
      } finally {
        setIsLoading(false);
      }
    };

    fetchAccounts();
    */
  }, [isAuthenticated]);

  if (!isAuthenticated) {
    return (
      <Card className={styles.bankCard}>
        <CardHeader className={styles.bankCardHeader}>
          <div className={styles.headerGroup}>
            <div className={styles.headerIconBg}>
              <Building2 className={styles.headerIcon} />
            </div>
            <div>
              <CardTitle className={styles.bankCardTitle}>Банковские счета</CardTitle>
              <p className={styles.bankCardSubtitle}>
                Войдите, чтобы увидеть свои счета
              </p>
            </div>
          </div>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card className={styles.bankCard}>
      <CardHeader className={styles.bankCardHeader}>
        <div className={styles.headerGroup}>
          <div className={styles.headerIconBg}>
            <Building2 className={styles.headerIcon} />
          </div>
          <div>
            <CardTitle className={styles.bankCardTitle}>Банковские счета</CardTitle>
            <p className={styles.bankCardSubtitle}>
              Все подключенные счета в одном месте
            </p>
          </div>
        </div>
      </CardHeader>
      <CardContent className={styles.bankCardContent}>
        {isLoading ? (
          <div className={styles.loadingState}>
            <p>Загрузка счетов...</p>
          </div>
        ) : error ? (
          <div className={styles.errorState}>
            <p>{error}</p>
          </div>
        ) : accounts.length === 0 ? (
          <div className={styles.emptyState}>
            <p>Нет подключенных счетов</p>
          </div>
        ) : (
          <div className={styles.accountList}>
            {accounts.map((account, index) => (
              <div
                key={`${account.accountId}-${index}`}
                className={styles.accountItem}
              >
                <div className={styles.itemDetails}>
                  <div className={styles.itemIconBg}>
                    <Building2 className={styles.itemIcon} />
                  </div>
                  <div>
                    <p className={styles.itemBank}>{account.bank}</p>
                    <p className={styles.itemSync}>
                      актуален: {account.lastSync}
                    </p>
                  </div>
                </div>
                <div className={styles.itemBalance}>
                  <p className={styles.balanceAmount}>
                    {account.currency}
                    {account.balance.toLocaleString("ru-RU", {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2,
                    })}
                  </p>
                  <Badge className={styles.statusBadge}>активен</Badge>
                </div>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/CashFlowChart/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.chartCard {
  @include glass-card(false);
  // border: 2px solid rgba($primary, 0.2);
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

//   &:hover {
//     border-color: rgba($primary, 0.4);
//     box-shadow: $shadow-medium, 0 0 40px rgba($primary, 0.2);
//     transform: translateY(-2px);
//   }
}

.chartCardHeader {
  gap: 0.75rem;
}

.headerGroup {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.headerIconBg {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius;
  background-color: rgba($primary, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.headerIcon {
  height: 1.25rem;
  width: 1.25rem;
  color: $primary;
}

.chartCardTitle {
  font-weight: 700;
}

.chartCardSubtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.chartCardContent {
  padding-top: 0.5rem;
}

.legend {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  margin-top: 1.5rem;
}

.legendItem {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.legendDot {
  width: 1rem;
  height: 1rem;
  border-radius: $radius-sm;
  
  box-shadow: 0 0 8px rgba($primary, 0.5);
}

.dotActual {
  background-color: $primary;
  box-shadow: 0 0 8px rgba($primary, 0.5);
}

.dotPredicted {
  background-color: $accent;
  box-shadow: 0 0 8px rgba($accent, 0.5);
}

.legendLabel {
  font-size: 0.875rem;
  font-weight: 600;
  color: $muted-foreground;
}
</file>

<file path="src/components/CashFlowChart/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { TrendingUp } from "lucide-react";
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
  ReferenceLine,
} from "recharts";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getCashFlowPredictions } from "../../utils/api";
import styles from "./index.module.scss";
import {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
  primaryHslParts,
  accentHslParts,
} from "../../styles/colors";

// Утилита для создания HSL-цвета для Recharts (требуется для градиентов)
const getHslColor = (h: string, s: string, l: string) => `hsl(${h}, ${s}, ${l})`;

export default function CashFlowChart() {
  const { isAuthenticated } = useAuth();
  const [data, setData] = useState<Array<{ date: string; actual: number | null; predicted: number | null }>>([]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!isAuthenticated) {
      setData([]);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const today = new Date();
    const mockChartData = [
      {
        date: new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000).toLocaleDateString("ru-RU", {
          day: "2-digit",
          month: "short",
        }),
        actual: null,
        predicted: 1250000,
      },
      {
        date: new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000).toLocaleDateString("ru-RU", {
          day: "2-digit",
          month: "short",
        }),
        actual: null,
        predicted: 980000,
      },
      {
        date: new Date(today.getTime() + 21 * 24 * 60 * 60 * 1000).toLocaleDateString("ru-RU", {
          day: "2-digit",
          month: "short",
        }),
        actual: null,
        predicted: -120000,
      },
      {
        date: new Date(today.getTime() + 28 * 24 * 60 * 60 * 1000).toLocaleDateString("ru-RU", {
          day: "2-digit",
          month: "short",
        }),
        actual: null,
        predicted: 340000,
      },
    ];

    setTimeout(() => {
      setData(mockChartData);
      setIsLoading(false);
    }, 300);

    /* Закомментирован реальный API вызов
    const fetchPredictions = async () => {
      try {
        setIsLoading(true);
        const response = await getCashFlowPredictions(4);
        if (response.data.success && response.data.predictions) {
          const chartData = response.data.predictions.map((p) => ({
            date: new Date(p.prediction_date).toLocaleDateString("ru-RU", {
              day: "2-digit",
              month: "short",
            }),
            actual: null,
            predicted: p.predicted_balance,
          }));
          setData(chartData);
        }
      } catch (err) {
        console.error("Error fetching cash flow predictions:", err);
        setData([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchPredictions();
    */
  }, [isAuthenticated]);

  const primaryHslString = getHslColor(primaryHslParts[0], primaryHslParts[1], primaryHslParts[2]);
  const accentHslString = getHslColor(accentHslParts[0], accentHslParts[1], accentHslParts[2]);
  const RefLine = ReferenceLine;
  
  const hasData = data.length > 0;
  
  return (
    <Card className={styles.chartCard}>
      <CardHeader className={styles.chartCardHeader}>
        <div className={styles.headerGroup}>
          <div className={styles.headerIconBg}>
            <TrendingUp className={styles.headerIcon} />
          </div>
          <div>
            <CardTitle className={styles.chartCardTitle}>Cash Flow прогноз</CardTitle>
            <p className={styles.chartCardSubtitle}>
              {hasData ? "Наши предсказания баланса на следующие 4 недели" : "Подключите счета для просмотра прогноза"}
            </p>
          </div>
        </div>
      </CardHeader>
      <CardContent className={styles.chartCardContent}>
        {isLoading ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка прогноза...</p>
          </div>
        ) : !hasData ? (
          <div style={{ padding: "2rem", textAlign: "center", color: muted_foreground }}>
            <p>Нет данных для отображения</p>
            <p style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
              Подключите банковские счета, чтобы увидеть прогноз денежного потока
            </p>
          </div>
        ) : (
        <ResponsiveContainer width="100%" height={320}>
          <AreaChart data={data} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
            <defs>
              {/* Используем SCSS-переменные в SVG-градиентах */}
              <linearGradient id="colorActual" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={primaryHslString} stopOpacity={0.4} />
                <stop offset="95%" stopColor={primaryHslString} stopOpacity={0.05} />
              </linearGradient>
              <linearGradient id="colorPredicted" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={accentHslString} stopOpacity={0.4} />
                <stop offset="95%" stopColor={accentHslString} stopOpacity={0.05} />
              </linearGradient>
            </defs>
            <CartesianGrid strokeDasharray="3 3" stroke={border} opacity={0.3} />
            <XAxis
              dataKey="date"
              stroke={muted_foreground}
              fontSize={12}
              tickLine={false}
              axisLine={{ stroke: border }}
            />
            <YAxis
              stroke={muted_foreground}
              fontSize={12}
              tickLine={false}
              axisLine={{ stroke: border }}
            />
            <Tooltip
              contentStyle={{
                backgroundColor: popover,
                border: `1px solid ${border}`,
                borderRadius: "12px",
                backdropFilter: "blur(12px)",
              }}
              formatter={(value: number) => [`₽${value.toLocaleString()}`, ""]}
            />
            <RefLine y={0} stroke={danger} strokeDasharray="5 5" strokeWidth={2} />
            <Area
              type="monotone"
              dataKey="actual"
              stroke={primary}
              strokeWidth={3}
              fillOpacity={1}
              fill="url(#colorActual)"
              name="Actual"
              dot={{ fill: primary, r: 4 }}
              />
            <Area
              type="monotone"
              dataKey="predicted"
              stroke={accent}
              strokeWidth={3}
              strokeDasharray="8 4"
              fillOpacity={1}
              fill="url(#colorPredicted)"
              name="Predicted"
              dot={{ fill: accent, r: 4 }}
            />
          </AreaChart>
        </ResponsiveContainer>
        )}
        {hasData && <div className={styles.legend}>
          <div className={styles.legendItem}>
            <div className={`${styles.legendDot} ${styles.dotActual}`} />
            <span className={styles.legendLabel}>Баланс</span>
          </div>
          <div className={styles.legendItem}>
            <div className={`${styles.legendDot} ${styles.dotPredicted}`} />
            <span className={styles.legendLabel}>Наш прогноз</span>
          </div>
        </div>}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/Layout/index.module.scss">
/* Файл: src/styles/sidebar.module.scss */
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.root {
  min-height: 100vh;
  background-color: $background;
  display: block;
}

/* Desktop floating sidebar */
.sidebar {
  display: none;
}

@media (min-width: 1024px) {
  .sidebar {
    display: block;
    position: fixed;
    left: 1.5rem; 
    top: 1.5rem; 
    bottom: 1.5rem; 
    width: 5rem; 
    z-index: 50;
    pointer-events: auto;
  }

  .sidebarInner {
    @include glass-card();
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    padding: 2rem 0;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    border-radius: $radius;
  }

  .brandLink {
    height: 3rem;
    width: 3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: $radius-md;
    background: $gradient-primary;
  }

  .nav {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1 1 auto;
    gap: 0.75rem;
    width: 100%;
  }

  .navItem {
    position: relative;
    height: 3rem;
    width: 3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: $radius-md;
    transition: $transition-smooth;
    color: $muted-foreground;
  }

  .navItemActive {
    background: $primary;
    color: $primary-foreground;
    box-shadow: $shadow-glow;
  }

  .tooltip {
    position: absolute;
    left: 100%;
    margin-left: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: $popover;
    color: $popover-foreground;
    font-size: 0.875rem;
    font-weight: 600;
    border-radius: $radius-md;
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
    white-space: nowrap;
    box-shadow: $shadow-medium;
  }

  .navItem:hover .tooltip {
    opacity: 1;
    pointer-events: auto;
  }
}

/* Mobile header */
.mobileHeader {
  display: block;
}

@media (min-width: 1024px) {
  .mobileHeader {
    display: none;
  }
}

.mobileBar {
  position: fixed;
  left: 0;
  right: 0;
  top: 1rem;
  z-index: 40;
  padding: 0 1rem;
  pointer-events: none; /* Позволяем кликам проходить через пустые области */
}

.mobileInner {
  @include glass-card();
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 4rem;
  padding: 0 1rem;
  border-radius: $radius;
  margin: 0 auto;
  max-width: calc(100% - 2rem); 
  pointer-events: auto;
}

.brandRow {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.brandSmall {
  height: 2rem;
  width: 2rem;
  border-radius: $radius-sm;
  display: flex;
  align-items: center;
  justify-content: center;
  background: $gradient-primary;
}

.mobilePanelOverlay {
  position: fixed;
  inset: 0;
  background: rgba($background, 0.6);
  backdrop-filter: blur(6px);
  z-index: 50;
  animation: fadeIn 0.2s ease-out;
}

.mobilePanel {
  @include glass-card();
  position: fixed;
  top: 1rem;
  bottom: 1rem;
  left: 1rem;
  right: 1rem;
  max-width: calc(100% - 2rem);
  max-height: calc(100% - 2rem);
  z-index: 60;
  border-radius: $radius;
  padding: 2rem;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  animation: slideUp 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0; 
    transform: translateY(20px);
  }
  to { 
    opacity: 1; 
    transform: translateY(0);
  }
}


.menuCloseRow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1.5rem;
}

.navList {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.navListItem a {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem 1rem;
  border-radius: $radius-md;
  font-weight: 700;
  text-decoration: none;
  color: $foreground;
}

.navListItem a:hover {
  background: rgba($foreground, 0.02);
}

.main {
  padding-left: 0;
}

@media (min-width: 1024px) {
  .main {
    padding-left: 8rem;
    padding-top: 0;
  }
}

.contentWrap {
  padding: 1.5rem 1.25rem;
  max-width: 1600px;
  margin: 0 auto;
}

.btn {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius-md;
  background: transparent;
  border: none;
  color: $foreground;
  transition: all 0.2s ease;
  cursor: pointer;
  
  &:hover {
    background: rgba($foreground, 0.1);
  }
}
</file>

<file path="src/components/Layout/index.tsx">
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import {
  LayoutDashboard,
  TrendingUp,
  Heart,
  Users,
  Calendar,
  Settings,
  Menu,
  X,
  Sparkles,
  CircleUser
} from "lucide-react";
import cn from "classnames"
import styles from "./index.module.scss";

const navigation = [
  { name: "Dashboard", href: "/", icon: LayoutDashboard },
  { name: "Cash Flow", href: "/cash-flow", icon: TrendingUp },
  { name: "Health", href: "/health", icon: Heart },
  { name: "Receivables", href: "/receivables", icon: Users },
  { name: "Payments", href: "/payments", icon: Calendar },
  { name: "Settings", href: "/settings", icon: Settings },
];

export default function Layout({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <div className={styles.root}>
      <aside className={styles.sidebar}>
        <div className={styles.sidebarInner}>
          <Link to="/" className={styles.brandLink} title="FinFlow">
            <Sparkles />
          </Link>
          {/* <Link to="/login" className={styles.brandLink} title="auth">
            <CircleUser />
          </Link> */}
          <nav className={styles.nav} aria-label="Primary">
            {navigation.map((item) => {
              const isActive = location.pathname === item.href;
              const Icon = item.icon;
              return (
                <Link
                  key={item.name}
                  to={item.href}
                  className={cn(styles.navItem, isActive && styles.navItemActive)}
                  title={item.name}
                >
                  <Icon />
                  <div className={styles.tooltip}>{item.name}</div>
                </Link>
              );
            })}
          </nav>
        </div>
      </aside>

      {/* Mobile menu */}
      <div className={styles.mobileHeader}>
        <div className={styles.mobileBar}>
          <div className={styles.mobileInner}>
            <button
              type="button"
              className={styles.btn}
              onClick={() => setMobileMenuOpen(true)}
              aria-label="Open menu"
            >
              <Menu />
            </button>

            <div className={styles.brandRow}>
              <div className={styles.brandSmall}>
                <Sparkles className="h-4 w-4 text-primary-foreground" />
              </div>
              <span className={styles.appName}>FinFlow</span>
            </div>

            <div style={{ width: 40 }} />
          </div>
        </div>

        {mobileMenuOpen && (
          <div>
            <div className={styles.mobilePanelOverlay} onClick={() => setMobileMenuOpen(false)} />
            <div className={styles.mobilePanel} role="dialog" aria-modal="true">
              <div className={styles.menuCloseRow}>
                <div className={styles.brandRow}>
                  <div className={styles.brandSmall}>
                    <Sparkles className="h-5 w-5 text-primary-foreground" />
                  </div>
                  <span className={styles.appName}>FinFlow</span>
                </div>
                <button
                  onClick={() => setMobileMenuOpen(false)}
                  aria-label="Close menu"
                  className={styles.btn}
                >
                  <X />
                </button>
              </div>

              <nav className={styles.mobileNav}>
                <ul className={styles.navList}>
                  {navigation.map((item) => {
                    const isActive = location.pathname === item.href;
                    const Icon = item.icon;
                    return (
                      <li className={styles.navListItem} key={item.name}>
                        <Link
                          to={item.href}
                          onClick={() => setMobileMenuOpen(false)}
                          className={cn(styles.navListItemLink, isActive && styles.navItemActive)}
                        >
                          <Icon />
                          <span className={styles.navItemText}>{item.name}</span>
                        </Link>
                      </li>
                    );
                  })}
                </ul>
              </nav>
            </div>
          </div>
        )}
      </div>

      {/* Main content */}
      <main className={styles.main}>
        <div className={styles.contentWrap}>{children}</div>
      </main>
    </div>
  );
}
</file>

<file path="src/components/Loader/index.module.scss">
/* From Uiverse.io by aryamitra06 */
.loader {
  display: flex;
  align-items: center;
}

.bar {
  display: inline-block;
  width: 3px;
  height: 20px;
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  animation: scale-up4 1s linear infinite;
}

.bar:nth-child(2) {
  height: 35px;
  margin: 0 5px;
  animation-delay: 0.25s;
}

.bar:nth-child(3) {
  animation-delay: 0.5s;
}

@keyframes scale-up4 {
  20% {
    background-color: #ffff;
    transform: scaleY(1.5);
  }

  40% {
    transform: scaleY(1);
  }
}
</file>

<file path="src/components/Loader/index.tsx">
import css from "./index.module.scss";

export const Loader = () => (
  <div className={css.loader}>
    <span className={css.bar}></span>
    <span className={css.bar}></span>
    <span className={css.bar}></span>
  </div>
);
</file>

<file path="src/components/ReceivablesTable/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.header {
  display: flex;
  gap: 1rem;
  align-items: center;

  .headerText {
    text-align: center
  }
}

.iconBox {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius-md;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba($success, 0.2);
}

.title {
  font-size: 1.25rem;
  font-weight: 700;
}

.subtitle {
  margin-top: 0.25rem;
  font-size: 0.875rem;
  color: $muted-foreground;
}

.content {
  padding-top: 0.5rem;
}

.tableWrap {
  @include glass-card();
  border-radius: $radius;
  border: 1px solid rgba($border, 0.5);
  overflow: hidden;
}

.tableRow {
  transition: background-color 160ms ease;
}

.tableRowHover:hover {
  background: rgba($foreground, 0.02);
}

.counterparty {
  font-weight: 600;
}

.amount {
  font-weight: 700;
  font-size: 1.125rem;
}

.dueDate {
  font-weight: 500;
}

.actions {
  display: flex;
  gap: 0.5rem;
}

.badgePending {
  background: rgba($warning, 0.2);
  color: $warning;
  border: 1px solid rgba($warning, 0.3);
  font-weight: 700;
}

.badgeOverdue {
  background: rgba($danger, 0.2);
  color: $danger;
  border: 1px solid rgba($danger, 0.3);
  font-weight: 700;
}

.btnOutlineHover {
  transition: all 160ms ease;
}

.btnOutlineHover:hover {
  background: $primary;
  color: $primary-foreground;
  border-color: $primary;
}
</file>

<file path="src/components/ReceivablesTable/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Button } from "../../ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "../../ui/table";
import { useEffect, useState } from "react";
import { getAllBankAccounts, getAccountTransactions, getAccountBalances, getAccountId, type BankAccount, type BankTransaction } from "../../utils/api";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";
import { Phone } from "lucide-react";

interface Receivable {
  id: string;
  counterparty: string;
  amount: number;
  dueDate: string;
  status: "pending" | "overdue" | "received";
  transactionId?: string;
}

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

function formatDate(dateString?: string): string {
  if (!dateString) return "—";
  try {
    const date = new Date(dateString);
    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    return `${day}.${month}`;
  } catch {
    return "—";
  }
}

function isOverdue(dateString?: string): boolean {
  if (!dateString) return false;
  try {
    const date = new Date(dateString);
    const now = new Date();
    return date < now;
  } catch {
    return false;
  }
}

export default function ReceivablesTable() {
  const { isAuthenticated } = useAuth();
  const [receivables, setReceivables] = useState<Receivable[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockReceivables: Receivable[] = [
      {
        id: "rec-1",
        counterparty: "Vbank",
        amount: 450000,
        dueDate: "15.11",
        status: "received",
      },
      {
        id: "rec-2",
        counterparty: "Sbank",
        amount: 320000,
        dueDate: "14.11",
        status: "received",
      },
      {
        id: "rec-3",
        counterparty: "Abank",
        amount: 180000,
        dueDate: "13.11",
        status: "pending",
      },
      {
        id: "rec-4",
        counterparty: "Vbank",
        amount: 275000,
        dueDate: "12.11",
        status: "received",
      },
      {
        id: "rec-5",
        counterparty: "Sbank",
        amount: 95000,
        dueDate: "11.11",
        status: "pending",
      },
      {
        id: "rec-6",
        counterparty: "Abank",
        amount: 520000,
        dueDate: "10.11",
        status: "received",
      },
      {
        id: "rec-7",
        counterparty: "Vbank",
        amount: 68000,
        dueDate: "09.11",
        status: "overdue",
      },
    ];

    setTimeout(() => {
      setReceivables(mockReceivables);
      setIsLoading(false);
    }, 500);

    /* Закомментирован реальный API вызов
    const fetchReceivables = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // Сначала получаем все счета
        console.log("[ReceivablesTable] Fetching accounts...");
        const accountsResponse = await getAllBankAccounts();
        const accountsData = accountsResponse.data;
        
        console.log("[ReceivablesTable] Accounts response:", accountsData);

        if (!accountsData.success) {
          throw new Error("Не удалось получить счета");
        }

        const receivablesList: Receivable[] = [];
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const fromDate = thirtyDaysAgo.toISOString().split("T")[0];
        const toDate = now.toISOString().split("T")[0];

        // Получаем транзакции и балансы из всех счетов
        const transactionPromises: Promise<void>[] = [];

        Object.entries(accountsData.banks || {}).forEach(([bankCode, bankData]) => {
          console.log(`[ReceivablesTable] Processing bank ${bankCode}:`, bankData);
          
          if (bankData.success && bankData.accounts && bankData.accounts.length > 0) {
            console.log(`[ReceivablesTable] Bank ${bankCode} has ${bankData.accounts.length} accounts`);
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              
              if (!accountId) {
                console.warn(`[ReceivablesTable] Skipping account without account_id:`, account);
                return;
              }
              
              console.log(`[ReceivablesTable] Fetching transactions for account ${accountId} from ${bankCode}`);
              
              // Получаем баланс счета (сервер автоматически использует сохраненный consent_id)
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id // опционально, сервер получит из БД если не указано
              )
                .then((response) => {
                  console.log(`[ReceivablesTable] Balance for account ${accountId}:`, response.data);
                  // Здесь можно обработать баланс, например, сохранить в состояние или отобразить
                })
                .catch((err) => {
                  console.error(`[ReceivablesTable] Error fetching balance for account ${accountId}:`, err);
                  console.error(`[ReceivablesTable] Error details:`, {
                    message: err.message,
                    response: err.response?.data,
                    status: err.response?.status,
                  });
                });
              
              transactionPromises.push(balancePromise);
              
              // Сервер автоматически использует сохраненный consent_id
              const promise = getAccountTransactions(
                accountId,
                bankCode,
                undefined, // consent_id не передаем - сервер использует сохраненный
                fromDate,
                toDate
              )
                .then((response) => {
                  const transactions = response.data.transactions || [];
                  console.log(`[ReceivablesTable] Received ${transactions.length} transactions for account ${accountId}`);
                  
                  // Фильтруем входящие транзакции (Credit)
                  // Берем только первые 5 с каждого банка
                  const creditTransactions = transactions
                    .filter((tx) => {
                      const indicator = tx.transaction_type || tx.creditDebitIndicator;
                      return indicator === "Credit";
                    })
                    .slice(0, 5); // Ограничиваем до 5 транзакций с каждого банка
                  
                  creditTransactions.forEach((tx) => {
                    // Извлекаем сумму из нового формата
                    const amount = tx.amount || 0;
                    
                    // Используем название банка вместо контрагента
                    const counterparty = bankNames[bankCode] || bankCode;
                    
                    // Извлекаем дату
                    const bookingDate = tx.booking_date || tx.bookingDateTime || tx.value_date || tx.valueDateTime;
                    const status = bookingDate && isOverdue(bookingDate) 
                      ? "overdue" 
                      : bookingDate 
                      ? "pending" 
                      : "received";

                    receivablesList.push({
                      id: tx.transaction_id || tx.transactionId || `${accountId}-${tx.transactionReference || Date.now()}`,
                      counterparty,
                      amount,
                      dueDate: formatDate(bookingDate),
                      status: status as "pending" | "overdue" | "received",
                      transactionId: tx.transaction_id || tx.transactionId,
                    });
                  });
                })
                .catch((err) => {
                  console.error(`[ReceivablesTable] Error fetching transactions for account ${accountId}:`, err);
                  console.error(`[ReceivablesTable] Error details:`, {
                    message: err.message,
                    response: err.response?.data,
                    status: err.response?.status,
                  });
                });
              
              transactionPromises.push(promise);
            });
          } else {
            console.warn(`[ReceivablesTable] Bank ${bankCode} has no accounts or failed:`, bankData.error || "No accounts");
          }
        });

        console.log(`[ReceivablesTable] Waiting for ${transactionPromises.length} transaction requests...`);
        await Promise.all(transactionPromises);
        console.log(`[ReceivablesTable] Found ${receivablesList.length} receivables`);

        // Сортируем по дате (новые сначала)
        receivablesList.sort((a, b) => {
          if (a.dueDate === "—" && b.dueDate === "—") return 0;
          if (a.dueDate === "—") return 1;
          if (b.dueDate === "—") return -1;
          return b.dueDate.localeCompare(a.dueDate);
        });

        setReceivables(receivablesList);
      } catch (err: any) {
        console.error("Error fetching receivables:", err);
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки данных");
      } finally {
        setIsLoading(false);
      }
    };

    fetchReceivables();
    */
  }, [isAuthenticated]);

  const getStatusBadge = (status: string) => {
    if (status === "overdue") {
      return (
        <Badge className={styles.badgeOverdue}>
          Overdue
        </Badge>
      );
    }
    if (status === "received") {
      return (
        <Badge className={styles.badgePending} style={{ backgroundColor: "#10b981" }}>
          Received
        </Badge>
      );
    }
    return (
      <Badge className={styles.badgePending}>
        Pending
      </Badge>
    );
  };

  if (!isAuthenticated) {
    return (
      <Card className={styles.cardRoot}>
        <CardHeader className={styles.header}>
          <div className={styles.iconBox} aria-hidden>
            <svg className="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div className={styles.headerText}>
            <CardTitle className={styles.title}>Выплаты</CardTitle>
            <p className={styles.subtitle}>Войдите, чтобы увидеть входящие платежи</p>
          </div>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card className={styles.cardRoot}>
      <CardHeader className={styles.header}>
        <div className={styles.iconBox} aria-hidden>
          <svg className="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
        <div className={styles.headerText}>
          <CardTitle className={styles.title}>Выплаты</CardTitle>
          <p className={styles.subtitle}>Отслеживайте входящие платежи и управляйте ими</p>
        </div>
      </CardHeader>
      <CardContent className={styles.content}>
        {isLoading ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка данных...</p>
          </div>
        ) : error ? (
          <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
            <p>{error}</p>
          </div>
        ) : receivables.length === 0 ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Нет входящих платежей за последние 30 дней</p>
          </div>
        ) : (
          <div className={styles.tableWrap}>
            <Table>
              <TableHeader>
                <TableRow className={styles.tableRow}>
                  <TableHead className={styles.counterparty}>Банк</TableHead>
                  <TableHead className={styles.amount}>Сумма</TableHead>
                  <TableHead className={styles.dueDate}>Дата</TableHead>
                  <TableHead>Статус</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {receivables.map((item) => (
                  <TableRow key={item.id} className={`${styles.tableRow} ${styles.tableRowHover}`}>
                    <TableCell className={styles.counterparty}>{item.counterparty}</TableCell>
                    <TableCell className={styles.amount}>
                      ₽{item.amount.toLocaleString("ru-RU", {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                      })}
                    </TableCell>
                    <TableCell className={styles.dueDate}>{item.dueDate}</TableCell>
                    <TableCell>{getStatusBadge(item.status)}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/StatCard/index.module.scss">
/* Файл: src/components/StatCard.module.scss */
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;
@use "sass:color";

@mixin variant-styles($color, $color-foreground) {
  border: 2px solid rgba($color, 0.2);
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

  &:hover {
    border-color: rgba($color, 0.4);
    box-shadow: $shadow-medium, 0 0 40px rgba($color, 0.2);
    transform: translateY(-2px);
  }

  .iconBg {
    background-color: $color;
    color: $color-foreground;
    box-shadow: 0 4px 12px rgba(color.adjust($color, $lightness: -20%), 0.4);
  }

  .trendPositive {
    background-color: rgba($success, 0.2);
    color: $success;
  }
  
  .trendNegative {
    background-color: rgba($danger, 0.2);
    color: $danger;
  }
}


.statCard {
  @include glass-card(false);
  
  &.default {
    @include variant-styles($primary, $primary-foreground);
  }
  &.success {
    @include variant-styles($success, $success-foreground);
  }
  &.warning {
    @include variant-styles($warning, $warning-foreground);
  }
  &.danger {
    @include variant-styles($danger, $danger-foreground);
  }
}


.cardContent {
  padding: 1.5rem;
}

.contentWrapper {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 1rem;
}

.textSection {
  flex: 1 1 0%;
  
  > *:not([hidden]) ~ *:not([hidden]) {
    margin-top: 0.75rem;
  }
}

.title {
  font-size: 0.875rem;
  font-weight: 600;
  color: $muted-foreground;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}


.value {
  font-size: 2.25rem;
  font-weight: 700;
  color: $foreground;
  text-shadow: 0 0 20px rgba($primary, 0.3);
}

.subtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
}


.trendContainer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding-top: 0.5rem;
}


.trendBadge {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.875rem;
  font-weight: 700;
  padding: 0.25rem 0.5rem;
  border-radius: $radius-md;
}


.iconBg {
  border-radius: $radius * 1.25;
  padding: 1rem;
  flex-shrink: 0;
}

.icon {
  height: 1.75rem;
  width: 1.75rem;
}
</file>

<file path="src/components/StatCard/index.tsx">
import type { LucideIcon } from "lucide-react";
import { Card, CardContent } from "../../ui/card";
import cn from "classnames"
import styles from "./index.module.scss";

type Variant = "default" | "success" | "warning" | "danger";

interface StatCardProps {
  title: string;
  value: string;
  subtitle?: string;
  icon: LucideIcon;
  variant?: Variant;
  trend?: {
    value: string;
    isPositive: boolean;
  };
}

export default function StatCard({
  title,
  value,
  subtitle,
  icon: Icon,
  variant = "default",
  trend,
}: StatCardProps) {


  const trendClass = trend?.isPositive
    ? styles.trendPositive
    : styles.trendNegative;

  return (
    <Card className={cn(styles.statCard, styles[variant])}>
      <CardContent className={styles.cardContent}>
        <div className={styles.contentWrapper}>

          <div className={styles.textSection}>
            <p className={styles.title}>{title}</p>
            <p className={styles.value}>{value}</p>

            {subtitle && (
              <p className={styles.subtitle}>{subtitle}</p>
            )}

            {trend && (
              <div className={styles.trendContainer}>
                <span className={cn(styles.trendBadge, trendClass)}>
                  {trend.isPositive ? "↗" : "↘"} {trend.value}
                </span>
              </div>
            )}
          </div>

          <div className={styles.iconBg}>
            <Icon className={styles.icon} strokeWidth={2.5} />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/hooks/context.tsx">
import { createContext, useContext, type ReactNode } from "react";
import { Loader } from "../components/Loader";
import type { UserResponse } from "../utils/api";
import { useAuth } from "./useAuth";

export type AppContext = {
    me: UserResponse | null;
}

const AppReactContext = createContext<AppContext>({
    me: null,
});


export const useAppContext = () => {
  return useContext(AppReactContext);
};

export const useMe = () => {
  const { me } = useAppContext();
  return me;
};

export const AppContextProvider = ({
    children,
}: {
    children: ReactNode;
}) => {
    const { user, isLoading, error} = useAuth();
    return (
    <AppReactContext.Provider
      value={{
        me: user || null,
      }}
    >
      {isLoading ? (
        <Loader/>
      ) : error ? (
        <p>Error: {error}</p>
      ) : (
        children
      )}
    </AppReactContext.Provider>
  );
};
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from "react";
import { getCookie, eraseCookie } from "../utils/cookies";
import { getMe, type UserResponse } from "../utils/api";
import type { AxiosError } from "axios";

export const useAuth = () => {
  const [user, setUser] = useState<UserResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const checkAuth = async () => {
      const token = getCookie("access_token");
      if (!token) {
        setIsAuthenticated(false);
        setIsLoading(false);
        return;
      }

      try {
        const { data } = await getMe();
        setUser(data);
        setIsAuthenticated(true);
        setError(null);
      } catch (err) {
        const axiosErr = err as AxiosError;

        // Сохраняем ошибку
        setError(axiosErr.response?.data as string ?? axiosErr.message);

        if (axiosErr.response?.status === 401 || axiosErr.response?.status === 403) {
          console.log("Token invalid or expired, clearing auth state");
          eraseCookie("access_token");
          eraseCookie("refresh_token");
        }

        setIsAuthenticated(false);
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  const refetch = async () => {
    const token = getCookie("access_token");
    if (!token) {
      setUser(null);
      setIsAuthenticated(false);
      setError("No token");
      return;
    }

    try {
      const { data } = await getMe();
      setUser(data);
      setIsAuthenticated(true);
      setError(null);
    } catch (err) {
      const axiosErr = err as AxiosError;
      setError(axiosErr.response?.data as string ?? axiosErr.message);
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  return { user, isLoading, isAuthenticated, error, refetch };
};
</file>

<file path="src/pages/Auth/AuthForm.module.scss">
@use "../../styles/vars" as *;

.authForm {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  width: 100%;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.25rem;

  h2 {
    font-size: 1.75rem;
    font-weight: 700;
    color: $foreground;
    text-align: center;
    margin-bottom: 0.5rem;
  }
}

.subtitle {
  color: $muted-foreground;
  text-align: center;
  font-size: 0.875rem;
  margin-top: -1rem;
  margin-bottom: 0.5rem;
}

.fieldGroup {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;

  label {
    font-weight: 600;
    font-size: 0.875rem;
    color: $muted-foreground;
  }

  input,
  select {
    width: 100%;
    background-color: $input;
    border: 1px solid $border;
    color: $foreground;
    border-radius: $radius-md;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    transition: all 0.2s ease;

    &:focus {
      outline: none;
      border-color: $primary;
      box-shadow: 0 0 0 2px rgba($primary, 0.3);
    }

    &.fieldError {
      border-color: #ef4444;
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
      
      &:focus {
        border-color: #ef4444;
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
      }
    }

    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-background-clip: text;
      -webkit-text-fill-color: $foreground;
      -webkit-box-shadow: 0 0 0px 1000px $input inset;
      box-shadow: 0 0 0px 1000px $input inset;
      transition: background-color 5000s ease-in-out 0s;
      border-color: $border;
    }
  }
}



.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  width: 100%;
  gap: 1rem;
}

.footer {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-top: 1rem;
}

.switchMode {
  color: $primary-light;
  text-decoration: none;

  &:hover {
    color: $foreground;
    text-decoration: none;
  }
}

.divider {
  display: flex;
  align-items: center;
  text-align: center;
  color: $muted-foreground;
  font-size: 0.75rem;
  font-weight: 600;

  &::before,
  &::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid $border;
  }

  span {
    padding: 0 1rem;
  }
}

.error {
  color: #ef4444;
  font-size: 0.8rem;
  margin-top: 4px;
  text-align: left;
  font-weight: 500;
  min-height: 1.2rem;
  display: block;
}

.loginButton {
  width: 100%;
  margin-top: 0.5rem;
}

.oauthSection {
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid $border;
}

.oauthTitle {
  text-align: center;
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-bottom: 1rem;
  font-weight: 600;
}

.oauthButtons {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.oauthButton {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}
</file>

<file path="src/pages/Auth/AuthForm.tsx">
/* eslint-disable @typescript-eslint/no-explicit-any */
import React, { useState } from "react";
import { Formik, Form, Field, ErrorMessage } from "formik";
import styles from "./AuthForm.module.scss";
import { Button } from "../../ui/button";
import { toast } from "sonner";
import * as api from "../../utils/api";
import { initiateBankOAuth } from "../../utils/api";
import { setCookie } from "../../utils/cookies";
import { zUserSignIn, zUserSignUp } from "../../utils/zod";
import { toFormikValidationSchema } from 'zod-formik-adapter';
import { Building2 } from "lucide-react";
import axios from "axios";

type View = "login" | "register" | "verify";

interface AuthFormProps {
  onClose: () => void;
}

export const AuthForm: React.FC<AuthFormProps> = ({ onClose }) => {
  const [view, setView] = useState<View>("login");
  
  const [phoneForVerify, setPhoneForVerify] = useState("");

  const handleLogin = async (values: any, { setSubmitting, setFieldError }: any) => {
    try {
      const { data } = await api.login(values.email, values.password);
      setCookie("access_token", data.access_token, 15 / (24 * 60));
      setCookie("refresh_token", data.refresh_token, 7);
      toast.success("Вход выполнен успешно!", {
        description: "Добро пожаловать!",
        duration: 1500,
      });
      onClose();
      // Обновляем страницу, чтобы хук useAuth сработал заново
      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (err: any) {
      console.error("❌ Ошибка входа:", err);
      
      let errorMessage = "Неверный email или пароль";
      let errorDescription = "Проверьте правильность введенных данных";
      
      if (axios.isAxiosError(err)) {
        if (err.response) {
          // Handle 401 Unauthorized specifically
          if (err.response.status === 401) {
            errorMessage = err.response.data?.detail || "Неверный email или пароль";
            errorDescription = "Проверьте правильность email и пароля";
            toast.error(errorMessage, {
              description: errorDescription,
              duration: 1500,
            });
          } else {
            const detail = err.response.data?.detail || err.response.data?.message;
            errorMessage = detail || errorMessage;
            toast.error(errorMessage, {
              description: "Попробуйте еще раз",
              duration: 5000,
            });
          }
          
          // Если есть ошибки валидации, показываем их в полях
          if (err.response.data?.errors && Array.isArray(err.response.data.errors)) {
            err.response.data.errors.forEach((error: any) => {
              const field = error.field || "";
              if (field.includes("email")) {
                setFieldError("email", error.message);
              }
              if (field.includes("password")) {
                setFieldError("password", error.message);
              }
            });
          }
        } else if (err.request) {
          errorMessage = "Ошибка сети";
          errorDescription = "Проверьте подключение к интернету или настройки сервера";
          toast.error(errorMessage, {
            description: errorDescription,
            duration: 1500,
          });
        } else {
          errorMessage = err.message || "Ошибка входа";
          toast.error(errorMessage, {
            description: "Попробуйте еще раз",
            duration: 5000,
          });
        }
      } else {
        toast.error(errorMessage, {
          description: errorDescription,
          duration: 5000,
        });
      }
    }
    setSubmitting(false);
  };

  const handleRegister = async (values: any, { setSubmitting, setFieldError }: any) => {
  try {
    await api.register({
      email: values.email,
      phone_number: values.phone,
      first_name: values.firstName,
      last_name: values.lastName,
      password: values.password,
    });
    
    // После успешной регистрации автоматически логиним пользователя
    toast.success("Регистрация успешна!", {
      description: "Выполняется автоматический вход...",
      duration: 1500,
    });
    
    try {
      const { data } = await api.login(values.email, values.password);
      setCookie("access_token", data.access_token, 15 / (24 * 60));
      setCookie("refresh_token", data.refresh_token, 7);
      toast.success("Добро пожаловать!", {
        description: "Ваш аккаунт успешно создан и активирован",
        duration: 1500,
      });
      onClose();
      // Обновляем страницу, чтобы хук useAuth сработал заново
      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (loginErr: any) {
      console.error("❌ Ошибка автоматического входа после регистрации:", loginErr);
      toast.error("Регистрация успешна, но не удалось войти", {
        description: "Пожалуйста, войдите вручную",
        duration: 1500,
      });
      setView("login");
    }
  } catch (err: any) {
    console.error("❌ Ошибка регистрации:", err);
    
    let errorMessage = "Ошибка регистрации";
    let errorDescription = "Попробуйте позже";
    let hasValidationErrors = false;
    
    if (axios.isAxiosError(err)) {
      if (err.response) {
        const responseData = err.response.data;
        
        // Handle specific error codes
        if (err.response.status === 409) {
          errorMessage = "Пользователь уже существует";
          errorDescription = responseData?.detail || "Email или номер телефона уже зарегистрирован";
        } else if (err.response.status === 422) {
          errorMessage = "Ошибка валидации данных";
          errorDescription = "Проверьте правильность заполнения полей";
        } else {
          errorMessage = responseData?.detail || responseData?.message || "Ошибка регистрации";
          errorDescription = "Попробуйте еще раз";
        }
        
        // Если есть ошибки валидации, показываем их в полях
        if (responseData?.errors && Array.isArray(responseData.errors)) {
          hasValidationErrors = true;
          responseData.errors.forEach((error: any) => {
            const field = error.field || "";
            if (field.includes("email")) {
              setFieldError("email", error.message);
            }
            if (field.includes("phone") || field.includes("phone_number")) {
              setFieldError("phone", error.message);
            }
            if (field.includes("first_name") || field.includes("firstName")) {
              setFieldError("firstName", error.message);
            }
            if (field.includes("last_name") || field.includes("lastName")) {
              setFieldError("lastName", error.message);
            }
            if (field.includes("password")) {
              setFieldError("password", error.message);
            }
          });
        }
        
        // Показываем общее сообщение об ошибке
        if (hasValidationErrors && responseData.errors.length > 0) {
          toast.error("Проверьте правильность заполнения полей", {
            description: "Исправьте ошибки в форме",
            duration: 1500,
          });
        } else {
          toast.error(errorMessage, {
            description: errorDescription,
            duration: 1500,
          });
        }
      } else if (err.request) {
        errorMessage = "Ошибка сети";
        errorDescription = "Проверьте подключение к интернету или настройки сервера";
        toast.error(errorMessage, {
          description: errorDescription,
          duration: 1500,
        });

        if (err.message.includes('Network Error')) {
          toast.error("Ошибка соединения с сервером", {
            description: "Проверьте, запущен ли бэкенд",
            duration: 1500,
          });
        }
      } else {
        errorMessage = err.message || "Неизвестная ошибка";
        toast.error(errorMessage, {
          description: "Попробуйте еще раз",
          duration: 1500,
        });
      }
    } else {
      toast.error(errorMessage, {
        description: errorDescription,
        duration: 1500,
      });
    }
  } finally {
    setSubmitting(false);
  }
};

  const handleVerify = async (values: any, { setSubmitting }: any) => {
    try {
      await api.verifySms(phoneForVerify, values.code);
      toast.success("Телефон успешно подтвержден!", {
        description: "Теперь вы можете войти",
        duration: 1500,
      });
      setView("login");
    } catch (err: any) {
      console.error("❌ Ошибка верификации:", err);
      const errorMessage = err.response?.data?.detail || "Неверный код верификации";
      toast.error("Ошибка верификации", {
        description: errorMessage,
        duration: 1500,
      });
    }
    setSubmitting(false);
  };


  const handleBankOAuth = (bankCode: string) => {
    toast.info("Перенаправление на банк для авторизации...", {
      description: "Вы будете перенаправлены на страницу банка",
      duration: 1500,
    });
    initiateBankOAuth(bankCode);
  };

  const renderLogin = () => (
    <Formik
      initialValues={{ email: "", password: "" }}
      validationSchema={toFormikValidationSchema(zUserSignIn)}
      onSubmit={handleLogin}
    >
      {({ isSubmitting, isValid, dirty, errors, touched }) => (
        <Form className={styles.form}>
          <h2>Вход в FinFlow</h2>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="email">Email</label>
            <Field 
              id="email" 
              name="email" 
              placeholder="user@example.com"
              className={errors.email && touched.email ? styles.fieldError : ""}
            />
            <ErrorMessage name="email" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="password">Пароль</label>
            <Field 
              id="password" 
              name="password" 
              type="password"
              className={errors.password && touched.password ? styles.fieldError : ""}
            />
            <ErrorMessage name="password" component="div" className={styles.error} />
          </div>
          
          <Button 
            type="submit" 
            disabled={isSubmitting || !isValid || !dirty}
            variant="default" 
            size="lg"
            className={styles.loginButton}
          >
            {isSubmitting ? "Вход..." : "Войти"}
          </Button>

          <div className={styles.divider}></div>

          <div className={styles.oauthSection}>
            <p className={styles.oauthTitle}>Войти через</p>
            <div className={styles.oauthButtons}>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("vbank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Virtual Bank
              </Button>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("abank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Awesome Bank
              </Button>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("sbank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Smart Bank
              </Button>
            </div>
          </div>
        </Form>
      )}
    </Formik>
  );

  const renderRegister = () => (
    <Formik
      initialValues={{ firstName: "", lastName: "", email: "", phone: "", password: "" }}
      validationSchema={toFormikValidationSchema(zUserSignUp)}
      onSubmit={handleRegister}
    >
      {({ isSubmitting, isValid, dirty, errors, touched }) => (
        <Form className={styles.form}>
          <h2>Регистрация</h2>
          
          <div className={styles.grid}>
            <div className={styles.fieldGroup}>
              <label htmlFor="firstName">Имя</label>
              <Field 
                id="firstName" 
                name="firstName"
                className={errors.firstName && touched.firstName ? styles.fieldError : ""}
              />
              <ErrorMessage name="firstName" component="div" className={styles.error} />
            </div>
            <div className={styles.fieldGroup}>
              <label htmlFor="lastName">Фамилия</label>
              <Field 
                id="lastName" 
                name="lastName"
                className={errors.lastName && touched.lastName ? styles.fieldError : ""}
              />
              <ErrorMessage name="lastName" component="div" className={styles.error} />
            </div>
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="email">Email</label>
            <Field 
              id="email" 
              name="email" 
              type="email"
              className={errors.email && touched.email ? styles.fieldError : ""}
            />
            <ErrorMessage name="email" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="phone">Телефон</label>
            <Field 
              id="phone" 
              name="phone" 
              placeholder="+79001234567"
              className={errors.phone && touched.phone ? styles.fieldError : ""}
            />
            <ErrorMessage name="phone" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="password">Пароль</label>
            <Field 
              id="password" 
              name="password" 
              type="password"
              className={errors.password && touched.password ? styles.fieldError : ""}
            />
            <ErrorMessage name="password" component="div" className={styles.error} />
          </div>
          
          <Button 
            type="submit" 
            disabled={isSubmitting || !isValid || !dirty}
            variant="default" 
            size="lg"
          >
            {isSubmitting ? "Регистрация..." : "Зарегистрироваться"}
          </Button>
        </Form>
      )}
    </Formik>
  );

const renderVerify = () => (
  <Formik 
    initialValues={{ code: "" }} 
    onSubmit={handleVerify}
    validate={(values) => {
      const errors: any = {};
      if (!values.code) {
        errors.code = "Обязательное поле";
      } else if (values.code.length < 6) {
        errors.code = "Код должен содержать 6 цифр";
      } else if (!/^\d+$/.test(values.code)) {
        errors.code = "Код должен содержать только цифры";
      }
      return errors;
    }}
  >
    {({ isSubmitting, values, errors, touched, setFieldValue }) => (
      <Form className={styles.form}>
        <h2>Код из SMS</h2>
        <p className={styles.subtitle}>
          Мы отправили код на номер <strong>{phoneForVerify || ""}</strong>
        </p>
        
        <div className={styles.fieldGroup}>
          <label htmlFor="code">Код</label>
          <Field 
            id="code" 
            name="code" 
            placeholder="123456" 
            maxLength={6}
            value={values.code}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
              // Используем setFieldValue вместо прямого изменения DOM
              const value = e.target.value.replace(/\D/g, '');
              setFieldValue('code', value);
            }}
          />
          <ErrorMessage name="code" component="div" className={styles.error} />
        </div>
        
        <Button 
          type="submit" 
          disabled={isSubmitting || values.code.length < 6 || !!errors.code}
          variant="default" 
          size="lg"
        >
          {isSubmitting ? "Проверка..." : "Подтвердить"}
        </Button>
      </Form>
    )}
  </Formik>
);

  return (
    <div className={styles.authForm}>
      {view === "login" && renderLogin()}
      {view === "register" && renderRegister()}
      {view === "verify" && renderVerify()}

      <div className={styles.footer}>
        {view !== "verify" && (
          <Button
            variant="link"
            className={styles.switchMode}
            onClick={() => setView(view === "login" ? "register" : "login")}
          >
            {view === "login" ? "Нет аккаунта? Регистрация" : "Уже есть аккаунт? Войти"}
          </Button>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/pages/Auth/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.authOverlay {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

.authBlur {
  position: absolute;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.4);
}

.authModal {
  position: relative;
  z-index: 101;
  width: 100%;
  max-width: 450px;
  margin: 1rem;
  
  @include glass-card(false);
  border: 1px solid $glass-border;
  padding: 2.5rem;
  border-radius: $radius;
  box-shadow: $shadow-strong;

  animation: slideUp 0.4s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0; 
    transform: translateY(20px);
  }
  to { 
    opacity: 1; 
    transform: translateY(0);
  }
}
</file>

<file path="src/pages/Auth/index.tsx">
import React from "react";
import styles from "./index.module.scss";
import { AuthForm } from "./AuthForm";
import cn from "classnames";

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const AuthModal: React.FC<AuthModalProps> = ({ isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className={cn(styles.authOverlay, "auth-modal-overlay")}>
      <div className={styles.authBlur} onClick={onClose}></div>

      <div className={styles.authModal}>
        <AuthForm onClose={onClose} />
      </div>
    </div>
  );
};
</file>

<file path="src/pages/Auth/OAuthSuccess.module.scss">
@use "../../styles/vars" as *;

.container {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
}

.content {
  text-align: center;
  
  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 1rem;
  }
  
  p {
    font-size: 1rem;
    color: $muted-foreground;
  }
}
</file>

<file path="src/pages/Auth/OAuthSuccess.tsx">
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { setCookie } from "../../utils/cookies";
import { toast } from "sonner";
import Layout from "../../components/Layout";
import styles from "./OAuthSuccess.module.scss";

export default function OAuthSuccess() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  useEffect(() => {
    const accessToken = searchParams.get("access_token");
    const refreshToken = searchParams.get("refresh_token");

    if (accessToken && refreshToken) {
      // Set tokens
      setCookie("access_token", accessToken, 15 / (24 * 60));
      setCookie("refresh_token", refreshToken, 7);

      toast.success("Успешный вход через банк!", {
        description: "Добро пожаловать!",
        duration: 1500,
      });

      // Redirect to home page
      setTimeout(() => {
        window.location.href = "/";
      }, 1000);
    } else {
      toast.error("Ошибка авторизации", {
        description: "Не удалось получить токены",
        duration: 1500,
      });

      setTimeout(() => {
        navigate("/");
      }, 2000);
    }
  }, [searchParams, navigate]);

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.content}>
          <h1>Завершение входа...</h1>
          <p>Пожалуйста, подождите</p>
        </div>
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/CashFlow/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.card {
  margin-bottom: 1.5rem;
}

.chartCard,
.gapsCard {
  margin-bottom: 1.5rem;
}

.icon {
  width: 1.5rem;
  height: 1.5rem;
  color: $primary;
}

.gapsList {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.gapItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background-color: $input;
  border: 1px solid $border;
  border-radius: $radius-md;

  .gapDate {
    font-weight: 600;
    color: $foreground;
    margin-bottom: 0.25rem;
  }

  .gapAmount {
    font-size: 1.25rem;
    font-weight: 700;
    color: $danger;
  }

  .gapMeta {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.5rem;
  }

  .gapProbability {
    font-size: 0.875rem;
    color: $muted-foreground;
  }

  .gapSeverity {
    padding: 0.25rem 0.75rem;
    border-radius: $radius-sm;
    font-size: 0.75rem;
    font-weight: 600;
    background-color: rgba($danger, 0.1);
    color: $danger;
  }
}
</file>

<file path="src/pages/CashFlow/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { TrendingUp, AlertTriangle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getCashFlowPredictions, getCashFlowGaps, type CashFlowPrediction, type CashFlowGap } from "../../utils/api";
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
  ReferenceLine,
} from "recharts";
import styles from "./index.module.scss";
import {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
  primaryHslParts,
  accentHslParts,
} from "../../styles/colors";
import { toast } from "sonner";

const getHslColor = (h: string, s: string, l: string) => `hsl(${h}, ${s}, ${l})`;

export default function CashFlow() {
  const { isAuthenticated } = useAuth();
  const [predictions, setPredictions] = useState<CashFlowPrediction["predictions"]>([]);
  const [gaps, setGaps] = useState<CashFlowGap["gaps"]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const today = new Date();
    const mockPredictions = [
      {
        prediction_date: new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString(),
        predicted_balance: 1250000,
        predicted_inflow: 850000,
        predicted_outflow: 620000,
        confidence: 0.85,
      },
      {
        prediction_date: new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000).toISOString(),
        predicted_balance: 980000,
        predicted_inflow: 720000,
        predicted_outflow: 990000,
        confidence: 0.78,
      },
      {
        prediction_date: new Date(today.getTime() + 21 * 24 * 60 * 60 * 1000).toISOString(),
        predicted_balance: -120000,
        predicted_inflow: 450000,
        predicted_outflow: 1550000,
        confidence: 0.72,
      },
      {
        prediction_date: new Date(today.getTime() + 28 * 24 * 60 * 60 * 1000).toISOString(),
        predicted_balance: 340000,
        predicted_inflow: 1200000,
        predicted_outflow: 740000,
        confidence: 0.68,
      },
    ];

    const mockGaps = [
      {
        date: new Date(today.getTime() + 21 * 24 * 60 * 60 * 1000).toISOString(),
        gap_amount: -120000,
        probability: 72.5,
        severity: "Средняя",
      },
      {
        date: new Date(today.getTime() + 19 * 24 * 60 * 60 * 1000).toISOString(),
        gap_amount: -45000,
        probability: 58.3,
        severity: "Низкая",
      },
    ];

    // Имитируем задержку загрузки
    setTimeout(() => {
      setPredictions(mockPredictions);
      setGaps(mockGaps);
      setIsLoading(false);
    }, 500);

    /* Закомментирован реальный API вызов
    const fetchData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const [predictionsRes, gapsRes] = await Promise.all([
          getCashFlowPredictions(4),
          getCashFlowGaps(4),
        ]);

        if (predictionsRes.data.success && predictionsRes.data.predictions) {
          setPredictions(predictionsRes.data.predictions);
        }

        if (gapsRes.data.success && gapsRes.data.gaps) {
          setGaps(gapsRes.data.gaps);
        }
      } catch (err: any) {
        console.error("Error fetching cash flow data:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить прогноз денежного потока");
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
    */
  }, [isAuthenticated]);

  const primaryHslString = getHslColor(primaryHslParts[0], primaryHslParts[1], primaryHslParts[2]);
  const accentHslString = getHslColor(accentHslParts[0], accentHslParts[1], accentHslParts[2]);

  const chartData = predictions?.map((p) => ({
    date: new Date(p.prediction_date).toLocaleDateString("ru-RU", { day: "2-digit", month: "short" }),
    predicted: p.predicted_balance,
    inflow: p.predicted_inflow,
    outflow: p.predicted_outflow,
  })) || [];

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card className={styles.card}>
          <CardHeader>
            <CardTitle>Cash Flow прогноз</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть прогноз денежного потока</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Cash Flow прогноз</h1>
          <p>Прогнозирование денежного потока на следующие 4 недели</p>
        </div>

        {isLoading ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Загрузка данных...</p>
            </CardContent>
          </Card>
        ) : error ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
              <p>{error}</p>
            </CardContent>
          </Card>
        ) : chartData.length === 0 ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Нет данных для отображения</p>
              <p style={{ fontSize: "0.875rem", marginTop: "0.5rem", color: muted_foreground }}>
                Подключите банковские счета для получения прогноза
              </p>
            </CardContent>
          </Card>
        ) : (
          <>
            <Card className={styles.chartCard}>
              <CardHeader>
                <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
                  <TrendingUp className={styles.icon} />
                  <div>
                    <CardTitle>Прогноз баланса</CardTitle>
                    <p style={{ fontSize: "0.875rem", color: muted_foreground, marginTop: "0.25rem" }}>
                      Прогнозируемый баланс на следующие 4 недели
                    </p>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={320}>
                  <AreaChart data={chartData} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
                    <defs>
                      <linearGradient id="colorPredicted" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="5%" stopColor={accentHslString} stopOpacity={0.4} />
                        <stop offset="95%" stopColor={accentHslString} stopOpacity={0.05} />
                      </linearGradient>
                    </defs>
                    <CartesianGrid strokeDasharray="3 3" stroke={border} opacity={0.3} />
                    <XAxis
                      dataKey="date"
                      stroke={muted_foreground}
                      fontSize={12}
                      tickLine={false}
                      axisLine={{ stroke: border }}
                    />
                    <YAxis
                      stroke={muted_foreground}
                      fontSize={12}
                      tickLine={false}
                      axisLine={{ stroke: border }}
                    />
                    <Tooltip
                      contentStyle={{
                        backgroundColor: popover,
                        border: `1px solid ${border}`,
                        borderRadius: "12px",
                      }}
                      formatter={(value: number) => [`₽${value.toLocaleString()}`, ""]}
                    />
                    <ReferenceLine y={0} stroke={danger} strokeDasharray="5 5" strokeWidth={2} />
                    <Area
                      type="monotone"
                      dataKey="predicted"
                      stroke={accent}
                      strokeWidth={3}
                      strokeDasharray="8 4"
                      fillOpacity={1}
                      fill="url(#colorPredicted)"
                      name="Прогноз"
                      dot={{ fill: accent, r: 4 }}
                    />
                  </AreaChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            {gaps && gaps.length > 0 && (
              <Card className={styles.gapsCard}>
                <CardHeader>
                  <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
                    <AlertTriangle className={styles.icon} style={{ color: danger }} />
                    <div>
                      <CardTitle>Потенциальные кассовые разрывы</CardTitle>
                      <p style={{ fontSize: "0.875rem", color: muted_foreground, marginTop: "0.25rem" }}>
                        Даты с высоким риском недостатка средств
                      </p>
                    </div>
                  </div>
                </CardHeader>
                <CardContent>
                  <div className={styles.gapsList}>
                    {gaps.map((gap, index) => (
                      <div key={index} className={styles.gapItem}>
                        <div>
                          <p className={styles.gapDate}>{new Date(gap.date).toLocaleDateString("ru-RU")}</p>
                          <p className={styles.gapAmount}>₽{gap.gap_amount.toLocaleString()}</p>
                        </div>
                        <div className={styles.gapMeta}>
                          <span className={styles.gapProbability}>
                            Вероятность: {gap.probability.toFixed(1)}%
                          </span>
                          <span className={styles.gapSeverity}>{gap.severity}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </>
        )}
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/Health/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.healthScore {
  margin-bottom: 2rem;
}

.scoreContent {
  display: flex;
  align-items: center;
  gap: 2rem;
  padding: 2rem !important;
}

.scoreCircle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 150px;
}

.scoreValue {
  font-size: 3rem;
  font-weight: 700;
  line-height: 1;
}

.scoreLabel {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.scoreStatus {
  flex: 1;
}

.statusBadge {
  display: inline-block;
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  color: white;
  font-weight: 600;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

.statusDescription {
  color: $muted-foreground;
  font-size: 0.875rem;
  line-height: 1.6;
}

.metricsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.detailsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

.metricRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 0;
  border-bottom: 1px solid $border;

  &:last-child {
    border-bottom: none;
  }

  span {
    color: $muted-foreground;
    font-size: 0.875rem;
  }

  strong {
    color: $foreground;
    font-weight: 600;
  }
}
</file>

<file path="src/pages/Health/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Heart, TrendingUp, TrendingDown, AlertCircle, DollarSign } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getHealthMetrics, type HealthMetrics } from "../../utils/api";
import StatCard from "../../components/StatCard";
import styles from "./index.module.scss";
import { toast } from "sonner";

export default function Health() {
  const { isAuthenticated } = useAuth();
  const [metrics, setMetrics] = useState<HealthMetrics["metrics"] | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockMetrics = {
      health_score: 78,
      health_status: "good",
      total_revenue: 5420000,
      total_expenses: 3890000,
      net_income: 1530000,
      total_ar: 2340000,
      overdue_ar: 340000,
      current_ratio: 2.45,
      quick_ratio: 1.87,
      operating_cash_flow: 1680000,
      cash_flow_trend: "Положительный",
      total_assets: 8750000,
      total_liabilities: 3200000,
      net_worth: 5550000,
    };

    // Имитируем задержку загрузки
    setTimeout(() => {
      setMetrics(mockMetrics);
      setIsLoading(false);
    }, 500);

    /* Закомментирован реальный API вызов
    const fetchMetrics = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await getHealthMetrics();
        if (response.data.success && response.data.metrics) {
          setMetrics(response.data.metrics);
        } else {
          setError(response.data.error || "Не удалось загрузить метрики");
        }
      } catch (err: any) {
        console.error("Error fetching health metrics:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить метрики финансового здоровья");
      } finally {
        setIsLoading(false);
      }
    };

    fetchMetrics();
    */
  }, [isAuthenticated]);

  const getHealthStatusColor = (status?: string) => {
    switch (status?.toLowerCase()) {
      case "excellent":
        return "#10b981";
      case "good":
        return "#3b82f6";
      case "fair":
        return "#f59e0b";
      case "poor":
        return "#ef4444";
      case "critical":
        return "#dc2626";
      default:
        return "#6b7280";
    }
  };

  const getHealthStatusText = (status?: string) => {
    switch (status?.toLowerCase()) {
      case "excellent":
        return "Отлично";
      case "good":
        return "Хорошо";
      case "fair":
        return "Удовлетворительно";
      case "poor":
        return "Плохо";
      case "critical":
        return "Критично";
      default:
        return "Не определено";
    }
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Финансовое здоровье</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть метрики финансового здоровья</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Финансовое здоровье</h1>
          <p>Анализ финансового состояния и ключевые метрики</p>
        </div>

        {isLoading ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Загрузка данных...</p>
            </CardContent>
          </Card>
        ) : error ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
              <p>{error}</p>
            </CardContent>
          </Card>
        ) : !metrics ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Нет данных для отображения</p>
              <p style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
                Подключите банковские счета для расчета метрик
              </p>
            </CardContent>
          </Card>
        ) : (
          <>
            <div className={styles.healthScore}>
              <Card>
                <CardContent className={styles.scoreContent}>
                  <div className={styles.scoreCircle}>
                    <div
                      className={styles.scoreValue}
                      style={{ color: getHealthStatusColor(metrics.health_status) }}
                    >
                      {metrics.health_score || 0}
                    </div>
                    <div className={styles.scoreLabel}>Health Score</div>
                  </div>
                  <div className={styles.scoreStatus}>
                    <div
                      className={styles.statusBadge}
                      style={{ backgroundColor: getHealthStatusColor(metrics.health_status) }}
                    >
                      {getHealthStatusText(metrics.health_status)}
                    </div>
                    <p className={styles.statusDescription}>
                      {metrics.health_status === "excellent" && "Ваше финансовое состояние отличное"}
                      {metrics.health_status === "good" && "Ваше финансовое состояние хорошее"}
                      {metrics.health_status === "fair" && "Есть области для улучшения"}
                      {metrics.health_status === "poor" && "Требуется внимание к финансам"}
                      {metrics.health_status === "critical" && "Критическая ситуация, требуется срочное действие"}
                    </p>
                  </div>
                </CardContent>
              </Card>
            </div>

            <div className={styles.metricsGrid}>
              <StatCard
                title="Доходы"
                value={`₽${(metrics.total_revenue || 0).toLocaleString()}`}
                subtitle="За период"
                icon={TrendingUp}
                variant="success"
              />
              <StatCard
                title="Расходы"
                value={`₽${(metrics.total_expenses || 0).toLocaleString()}`}
                subtitle="За период"
                icon={TrendingDown}
                variant="danger"
              />
              <StatCard
                title="Чистая прибыль"
                value={`₽${(metrics.net_income || 0).toLocaleString()}`}
                subtitle={metrics.net_income && metrics.net_income >= 0 ? "Положительный" : "Отрицательный"}
                icon={DollarSign}
                variant={metrics.net_income && metrics.net_income >= 0 ? "success" : "danger"}
              />
              <StatCard
                title="Дебиторская задолженность"
                value={`₽${(metrics.total_ar || 0).toLocaleString()}`}
                subtitle={`Просрочено: ₽${(metrics.overdue_ar || 0).toLocaleString()}`}
                icon={AlertCircle}
                variant="warning"
              />
            </div>

            <div className={styles.detailsGrid}>
              <Card>
                <CardHeader>
                  <CardTitle>Ликвидность</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Коэффициент текущей ликвидности</span>
                    <strong>{metrics.current_ratio?.toFixed(2) || "—"}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Коэффициент быстрой ликвидности</span>
                    <strong>{metrics.quick_ratio?.toFixed(2) || "—"}</strong>
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Денежный поток</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Операционный денежный поток</span>
                    <strong>₽{(metrics.operating_cash_flow || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Тренд</span>
                    <strong>{metrics.cash_flow_trend || "—"}</strong>
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Активы и обязательства</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Общие активы</span>
                    <strong>₽{(metrics.total_assets || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Обязательства</span>
                    <strong>₽{(metrics.total_liabilities || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Чистая стоимость</span>
                    <strong>₽{(metrics.net_worth || 0).toLocaleString()}</strong>
                  </div>
                </CardContent>
              </Card>
            </div>
          </>
        )}
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/home/index.module.scss">
@use "../../styles/vars.scss" as *;
@use "../../styles/mixins" as *;

$md: 768px;
$lg: 1024px;
$xl: 1280px;

.headerRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.userButton {
  width: 48px;
  height: 48px;
  border-radius: $radius-md;
  background: $gradient-primary;
  border: 1px solid $primary;
  color: $foreground;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: $transition-smooth;
  box-shadow: $shadow-soft;

  &:hover {
    box-shadow: $shadow-medium, $shadow-glow;
    transform: translateY(-2px);
    border-color: $primary-light;
  }

  &:active {
    transform: translateY(0);
  }
}

.dashboardContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
}


.headerSection {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}


.mainTitle {
  font-size: 3rem;
  font-weight: 700;
  color: $foreground;
  @include text-glow($primary);
}


.subtitle {
  font-size: 1.125rem;
  color: $muted-foreground;
}

.statsGrid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 1.5rem;

  @media (min-width: $md) {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  @media (min-width: $lg) {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }
}

.chartsGrid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 2rem;

  @media (min-width: $xl) {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}
</file>

<file path="src/pages/home/index.tsx">
import Layout from "../../components/Layout";
import StatCard from "../../components/StatCard";
import CashFlowChart from "../../components/CashFlowChart";
import BankAccountsList from "../../components/BankAccountList";
import ReceivablesTable from "../../components/ReceivablesTable";
import Landing from "../Landing";
import { Wallet, TrendingUp, TrendingDown, AlertCircle, CircleUser } from "lucide-react";
import styles from "./index.module.scss";
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { AuthModal } from "../Auth";
import { useAuth } from "../../hooks/useAuth";
import { getDashboardSummary, getAllBankAccounts, getAccountBalances, extractBalanceFromResponse, getAccountId, type DashboardSummary } from "../../utils/api";

export default function Index() {
  const [isAuthOpen, setIsAuthOpen] = useState(false);
  const navigate = useNavigate();
  const { isAuthenticated, isLoading } = useAuth();
  const [dashboardData, setDashboardData] = useState<DashboardSummary["summary"] | null>(null);
  const [isLoadingDashboard, setIsLoadingDashboard] = useState(false);
  const [totalBalance, setTotalBalance] = useState<number | null>(null);
  const [accountsCount, setAccountsCount] = useState<number>(0);

  useEffect(() => {
    if (!isAuthenticated) {
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockDashboardData = {
      total_balance: 2450000,
      accounts_count: 3,
      total_revenue: 5420000,
      total_ar: 2340000,
      overdue_ar: 340000,
      net_income: 1530000,
    };

    setTimeout(() => {
      setDashboardData(mockDashboardData);
      setIsLoadingDashboard(false);
    }, 300);

    /* Закомментирован реальный API вызов
    const fetchDashboardData = async () => {
      try {
        setIsLoadingDashboard(true);
        const response = await getDashboardSummary();
        if (response.data.success && response.data.summary) {
          setDashboardData(response.data.summary);
        }
      } catch (err: any) {
        console.error("Error fetching dashboard summary:", err);
        // Don't show error toast - dashboard can work without summary
      } finally {
        setIsLoadingDashboard(false);
      }
    };

    fetchDashboardData();
    */
  }, [isAuthenticated]);

  useEffect(() => {
    if (!isAuthenticated) {
      return;
    }

    // Используем захардкоженные данные для демонстрации
    setTimeout(() => {
      setAccountsCount(3);
      setTotalBalance(2450000);
    }, 400);

    /* Закомментирован реальный API вызов
    const fetchBalances = async () => {
      try {
        console.log("[Dashboard] Fetching accounts and balances...");
        const accountsResponse = await getAllBankAccounts();
        const accountsData = accountsResponse.data;
        
        if (!accountsData.success) {
          console.warn("[Dashboard] Failed to get accounts");
          return;
        }

        let count = 0;
        const balancePromises: Promise<number>[] = [];

        Object.entries(accountsData.banks || {}).forEach(([bankCode, bankData]) => {
          if (bankData.success && bankData.accounts && bankData.accounts.length > 0) {
            count += bankData.accounts.length;
            
            bankData.accounts.forEach((account) => {
              const accountId = getAccountId(account);
              if (!accountId) {
                console.warn(`[Dashboard] Skipping account without account_id:`, account);
                return;
              }
              
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id
              )
                .then((response) => {
                  console.log(`[Dashboard] Balance for account ${accountId}:`, response.data);
                  
                  // Извлекаем баланс из ответа
                  const balance = extractBalanceFromResponse(response);
                  console.log(`[Dashboard] Extracted balance for ${accountId}:`, balance);
                  return balance;
                })
                .catch((err) => {
                  console.error(`[Dashboard] Error fetching balance for account ${accountId}:`, err);
                  return 0;
                });
              
              balancePromises.push(balancePromise);
            });
          }
        });

        setAccountsCount(count);
        
        // Ждем все запросы и суммируем балансы
        const balances = await Promise.all(balancePromises);
        const total = balances.reduce((sum, balance) => sum + balance, 0);
        setTotalBalance(total);
        console.log(`[Dashboard] Total balance calculated: ${total}`);
      } catch (err: any) {
        console.error("[Dashboard] Error fetching balances:", err);
      }
    };

    fetchBalances();
    */
  }, [isAuthenticated]);

  const handleUserClick = () => {
    if (isAuthenticated) {
      navigate("/profile");
    } else {
      setIsAuthOpen(true);
    }
  };

  // Show landing page if not authenticated
  if (!isAuthenticated && !isLoading) {
    return <Landing />;
  }

  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <Layout>
        <div className={styles.dashboardContainer}>
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка...</p>
          </div>
        </div>
      </Layout>
    );
  }

  return (
    <Layout>
      <AuthModal 
        isOpen={isAuthOpen} 
        onClose={() => setIsAuthOpen(false)} 
      />

      <div className={styles.dashboardContainer}>
        
        <div className={styles.headerSection}>
          <div className={styles.headerRow}>
          <h1 className={styles.mainTitle}>Дашборд</h1>
          <button 
              className={styles.userButton}
              onClick={handleUserClick}
              aria-label="Профиль"
              title="Профиль"
            >
              <CircleUser size={24} />
          </button>
          </div>
          <p className={styles.subtitle}>
            Финансовый обзор и ключевые показатели
          </p>
        </div>

        <div className={styles.statsGrid}>
          <StatCard
            title="Общий баланс"
            value={totalBalance !== null ? `₽${totalBalance.toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : (dashboardData ? `₽${(dashboardData.total_balance || 0).toLocaleString()}` : "—")}
            subtitle={accountsCount > 0 ? `${accountsCount} счет${accountsCount === 1 ? "" : accountsCount < 5 ? "а" : "ов"}` : (dashboardData ? `${dashboardData.accounts_count || 0} счетов` : "Загрузка...")}
            icon={Wallet}
            variant="default"
          />
          <StatCard
            title="Доходы"
            value={dashboardData ? `₽${(dashboardData.total_revenue || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? "За последние 30 дней" : "Загрузка..."}
            icon={TrendingUp}
            variant="success"
          />
          <StatCard
            title="Дебиторская задолженность"
            value={dashboardData ? `₽${(dashboardData.total_ar || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? `Просрочено: ₽${(dashboardData.overdue_ar || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "Загрузка..."}
            icon={AlertCircle}
            variant="danger"
          />
          <StatCard
            title="Чистая прибыль"
            value={dashboardData ? `₽${(dashboardData.net_income || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? (dashboardData.net_income && dashboardData.net_income >= 0 ? "Положительная" : "Отрицательная") : "Загрузка..."}
            icon={TrendingDown}
            variant={dashboardData && dashboardData.net_income && dashboardData.net_income >= 0 ? "success" : "warning"}
          />
        </div>

        <div className={styles.chartsGrid}>
          <CashFlowChart />
          <BankAccountsList />
        </div>

        <ReceivablesTable />
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/Landing/index.module.scss">
@use "../../styles/vars" as *;

.landing {
  min-height: 100vh;
  background: linear-gradient(180deg, $background 0%, rgba($primary, 0.05) 100%);
}

.hero {
  padding: 4rem 2rem;
  text-align: center;
  max-width: 1200px;
  margin: 0 auto;
}

.heroContent {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
}

.brand {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.brandIcon {
  width: 2rem;
  height: 2rem;
  color: $primary;
}

.brandName {
  font-size: 1.5rem;
  font-weight: 700;
  color: $foreground;
}

.heroTitle {
  font-size: 3rem;
  font-weight: 800;
  color: $foreground;
  line-height: 1.2;
  max-width: 800px;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 2rem;
  }
}

.heroDescription {
  font-size: 1.25rem;
  color: $muted-foreground;
  max-width: 600px;
  line-height: 1.6;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 1rem;
  }
}

.heroActions {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  justify-content: center;
}

.ctaButton {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.ctaButtonLarge {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 1.125rem;
  padding: 1rem 2rem;
}

.features,
.benefits,
.cta {
  padding: 4rem 2rem;
}

.sectionContent {
  max-width: 1200px;
  margin: 0 auto;
}

.sectionTitle {
  font-size: 2.5rem;
  font-weight: 700;
  color: $foreground;
  text-align: center;
  margin-bottom: 3rem;

  @media (max-width: 768px) {
    font-size: 2rem;
  }
}

.featuresGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 2rem;
}

.featureCard {
  height: 100%;
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba($primary, 0.15);
  }
}

.featureIcon {
  width: 3rem;
  height: 3rem;
  border-radius: $radius-md;
  background: linear-gradient(135deg, rgba($primary, 0.1), rgba($primary, 0.2));
  display: flex;
  align-items: center;
  justify-content: center;
  color: $primary;
  margin-bottom: 1rem;
}

.benefitsGrid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4rem;
  align-items: center;

  @media (max-width: 968px) {
    grid-template-columns: 1fr;
    gap: 2rem;
  }
}

.benefitsText {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.benefitsDescription {
  font-size: 1.125rem;
  color: $muted-foreground;
  line-height: 1.6;
}

.benefitsList {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.benefitItem {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 1rem;
  color: $foreground;

  span {
    flex: 1;
  }
}

.checkIcon {
  width: 1.25rem;
  height: 1.25rem;
  color: #10b981;
  flex-shrink: 0;
}

.benefitsVisual {
  display: flex;
  justify-content: center;
}

.visualCard {
  width: 100%;
  max-width: 500px;
}

.visualContent {
  padding: 3rem !important;
}

.chartPlaceholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  padding: 2rem;
  color: $muted-foreground;
  text-align: center;

  svg {
    width: 4rem;
    height: 4rem;
    opacity: 0.5;
  }
}

.ctaCard {
  background: linear-gradient(135deg, rgba($primary, 0.1), rgba($primary, 0.05));
  border: 2px solid rgba($primary, 0.2);
}

.ctaContent {
  padding: 3rem !important;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
}

.ctaTitle {
  font-size: 2rem;
  font-weight: 700;
  color: $foreground;
  margin: 0;
}

.ctaDescription {
  font-size: 1.125rem;
  color: $muted-foreground;
  max-width: 600px;
  margin: 0;
}
</file>

<file path="src/pages/Landing/index.tsx">
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { AuthModal } from "../Auth";
import { Button } from "../../ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import {
  TrendingUp,
  Shield,
  Zap,
  BarChart3,
  ArrowRight,
  CheckCircle,
  Sparkles,
} from "lucide-react";
import styles from "./index.module.scss";

export default function Landing() {
  const [isAuthOpen, setIsAuthOpen] = useState(false);
  const navigate = useNavigate();

  const features = [
    {
      icon: BarChart3,
      title: "Финансовая аналитика",
      description: "Получайте детальную аналитику по всем вашим счетам в одном месте",
    },
    {
      icon: TrendingUp,
      title: "Прогноз денежных потоков",
      description: "ML-прогнозы помогают предсказать кассовые разрывы заранее",
    },
    {
      icon: Shield,
      title: "Безопасность",
      description: "Ваши данные защищены современными стандартами безопасности",
    },
    {
      icon: Zap,
      title: "Мультибанкинг",
      description: "Подключите счета из разных банков и управляйте ими централизованно",
    },
  ];

  const benefits = [
    "Автоматическая синхронизация с банками",
    "Управление дебиторской задолженностью",
    "Прогнозирование денежных потоков",
    "Детальная финансовая аналитика",
    "Отслеживание всех транзакций",
  ];

  return (
    <div className={styles.landing}>
      <AuthModal isOpen={isAuthOpen} onClose={() => setIsAuthOpen(false)} />
      {/* Hero Section */}
      <section className={styles.hero}>
        <div className={styles.heroContent}>
          <div className={styles.brand}>
            <Sparkles className={styles.brandIcon} />
            <span className={styles.brandName}>FinFlow</span>
          </div>
          <h1 className={styles.heroTitle}>
            Управление финансами для предпринимателей
          </h1>
          <p className={styles.heroDescription}>
            Объедините все ваши банковские счета, получите детальную аналитику и прогнозы денежных потоков в одном приложении
          </p>
          <div className={styles.heroActions}>
            <Button
              size="lg"
              onClick={() => setIsAuthOpen(true)}
              className={styles.ctaButton}
            >
              Начать бесплатно
              <ArrowRight size={20} />
            </Button>
            <Button
              size="lg"
              variant="outline"
              onClick={() => {
                setIsAuthOpen(true);
                setTimeout(() => {
                  const loginTab = document.querySelector('[data-view="login"]');
                  if (loginTab) (loginTab as HTMLElement).click();
                }, 100);
              }}
            >
              Войти
            </Button>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className={styles.features}>
        <div className={styles.sectionContent}>
          <h2 className={styles.sectionTitle}>Возможности</h2>
          <div className={styles.featuresGrid}>
            {features.map((feature, index) => {
              const Icon = feature.icon;
              return (
                <Card key={index} className={styles.featureCard}>
                  <CardHeader>
                    <div className={styles.featureIcon}>
                      <Icon />
                    </div>
                    <CardTitle>{feature.title}</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p>{feature.description}</p>
                  </CardContent>
                </Card>
              );
            })}
          </div>
        </div>
      </section>

      {/* Benefits Section */}
      <section className={styles.benefits}>
        <div className={styles.sectionContent}>
          <div className={styles.benefitsGrid}>
            <div className={styles.benefitsText}>
              <h2 className={styles.sectionTitle}>Почему FinFlow?</h2>
              <p className={styles.benefitsDescription}>
                Мы помогаем предпринимателям эффективно управлять финансами, предсказывать проблемы и принимать обоснованные решения
              </p>
              <ul className={styles.benefitsList}>
                {benefits.map((benefit, index) => (
                  <li key={index} className={styles.benefitItem}>
                    <CheckCircle className={styles.checkIcon} />
                    <span>{benefit}</span>
                  </li>
                ))}
              </ul>
              <Button
                size="lg"
                onClick={() => setIsAuthOpen(true)}
                className={styles.ctaButton}
              >
                Попробовать бесплатно
                <ArrowRight size={20} />
              </Button>
            </div>
            <div className={styles.benefitsVisual}>
              <Card className={styles.visualCard}>
                <CardContent className={styles.visualContent}>
                  <div className={styles.chartPlaceholder}>
                    <BarChart3 size={64} />
                    <p>Интерактивные графики и аналитика</p>
                  </div>
                </CardContent>
              </Card>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className={styles.cta}>
        <div className={styles.sectionContent}>
          <Card className={styles.ctaCard}>
            <CardContent className={styles.ctaContent}>
              <h2 className={styles.ctaTitle}>Готовы начать?</h2>
              <p className={styles.ctaDescription}>
                Присоединяйтесь к предпринимателям, которые уже используют FinFlow для управления финансами
              </p>
              <Button
                size="lg"
                onClick={() => setIsAuthOpen(true)}
                className={styles.ctaButtonLarge}
              >
                Создать аккаунт
                <ArrowRight size={20} />
              </Button>
            </CardContent>
          </Card>
        </div>
      </section>
    </div>
  );
}
</file>

<file path="src/pages/NotFound/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.pageContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  text-align: center;
  padding: 2rem;
  background: $gradient-card;
  position: relative;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: $gradient-glow;
    pointer-events: none;
  }

  p {
    font-size: 3rem;
    color: $foreground;
    margin-bottom: 2rem;
    position: relative;
    z-index: 1;
    
    @include gradient-text($gradient-primary);
    
    @include text-glow($primary);
  }

  img {
    max-width: 400px;
    width: 100%;
    height: auto;
    border-radius: $radius-lg;
    
    @include glass-card();
    
    box-shadow: $shadow-medium;
  }

  @media (max-width: 768px) {
    padding: 1rem;
    
    p {
      font-size: 2rem;
      margin-bottom: 1.5rem;
    }
    
    img {
      max-width: 250px;
    }
  }

  @media (max-width: 480px) {
    p {
      font-size: 1.4rem;
    }
    
    img {
      max-width: 200px;
    }
  }
}
</file>

<file path="src/pages/NotFound/index.tsx">
import css from "./index.module.scss"

export default function NotFound () {
    return (
        <div className={css.pageContainer}>
            <p>Такой страницы не существует</p>
            <img src="/kitty.webp"></img>
        </div>
    )
}
</file>

<file path="src/pages/Payments/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.tableWrap {
  overflow-x: auto;
}

.description {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.typeIncome,
.typeExpense {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
}

.typeIncome {
  color: #10b981;
}

.typeExpense {
  color: #ef4444;
}

.amountIncome {
  color: #10b981;
  font-weight: 600;
}

.amountExpense {
  color: #ef4444;
  font-weight: 600;
}

.status {
  padding: 0.25rem 0.75rem;
  border-radius: $radius-sm;
  font-size: 0.75rem;
  background-color: rgba(16, 185, 129, 0.1);
  color: #10b981;
}

.filters {
  display: flex;
  gap: 0.5rem;
}

.filterButton,
.filterActive {
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $input;
  color: $foreground;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background-color: $input;
    border-color: $primary;
  }
}

.filterActive {
  background-color: $primary;
  color: white;
  border-color: $primary;
}
</file>

<file path="src/pages/Payments/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../../ui/table";
import { Calendar, ArrowUpCircle, ArrowDownCircle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getAllBankAccounts, getAccountTransactions, getAccountId, type BankTransaction } from "../../utils/api";
import styles from "./index.module.scss";
import { toast } from "sonner";

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

export default function Payments() {
  const { isAuthenticated } = useAuth();
  const [transactions, setTransactions] = useState<BankTransaction[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filter, setFilter] = useState<"all" | "income" | "expense">("all");

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockTransactions: any[] = [
      {
        transaction_id: "tx-001",
        booking_date: "2024-11-15",
        transaction_type: "Credit",
        amount: 450000,
        transactionInformation: "Оплата по счету INV-2024-001 от ООО \"Альфа\"",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-002",
        booking_date: "2024-11-14",
        transaction_type: "Credit",
        amount: 320000,
        transactionInformation: "Оплата по счету INV-2024-002 от ООО \"Бета\"",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-003",
        booking_date: "2024-11-14",
        transaction_type: "Debit",
        amount: 125000,
        transactionInformation: "Оплата поставщику ООО \"Снабжение\"",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-004",
        booking_date: "2024-11-13",
        transaction_type: "Credit",
        amount: 180000,
        transactionInformation: "Оплата по счету INV-2024-003 от ООО \"Гамма\"",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-005",
        booking_date: "2024-11-12",
        transaction_type: "Credit",
        amount: 275000,
        transactionInformation: "Оплата по счету INV-2024-004 от ООО \"Дельта\"",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-006",
        booking_date: "2024-11-12",
        transaction_type: "Debit",
        amount: 85000,
        transactionInformation: "Аренда офиса за ноябрь",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-007",
        booking_date: "2024-11-11",
        transaction_type: "Credit",
        amount: 95000,
        transactionInformation: "Оплата по счету INV-2024-005 от ООО \"Эпсилон\"",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-008",
        booking_date: "2024-11-11",
        transaction_type: "Debit",
        amount: 45000,
        transactionInformation: "Коммунальные услуги",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-009",
        booking_date: "2024-11-10",
        transaction_type: "Credit",
        amount: 520000,
        transactionInformation: "Оплата по счету INV-2024-006 от ООО \"Зета\"",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-010",
        booking_date: "2024-11-10",
        transaction_type: "Debit",
        amount: 220000,
        transactionInformation: "Закупка материалов",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-011",
        booking_date: "2024-11-09",
        transaction_type: "Debit",
        amount: 68000,
        transactionInformation: "Зарплата сотрудникам",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-012",
        booking_date: "2024-11-08",
        transaction_type: "Debit",
        amount: 155000,
        transactionInformation: "Налоговые платежи",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-013",
        booking_date: "2024-11-07",
        transaction_type: "Debit",
        amount: 92000,
        transactionInformation: "Оплата услуг связи и интернета",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-014",
        booking_date: "2024-11-06",
        transaction_type: "Credit",
        amount: 410000,
        transactionInformation: "Оплата по счету INV-2024-013 от ООО \"Ню\"",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-015",
        booking_date: "2024-11-05",
        transaction_type: "Debit",
        amount: 175000,
        transactionInformation: "Страховые взносы",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-016",
        booking_date: "2024-11-04",
        transaction_type: "Debit",
        amount: 38000,
        transactionInformation: "Канцелярские товары",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-017",
        booking_date: "2024-11-03",
        transaction_type: "Debit",
        amount: 420000,
        transactionInformation: "Оплата подрядчикам",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
      {
        transaction_id: "tx-018",
        booking_date: "2024-11-02",
        transaction_type: "Debit",
        amount: 265000,
        transactionInformation: "Лизинговый платеж",
        bankName: "Sbank",
        bankCode: "sber",
        status: "Booked",
      },
      {
        transaction_id: "tx-019",
        booking_date: "2024-11-01",
        transaction_type: "Debit",
        amount: 115000,
        transactionInformation: "Реклама и маркетинг",
        bankName: "Abank",
        bankCode: "alpha",
        status: "Booked",
      },
      {
        transaction_id: "tx-020",
        booking_date: "2024-10-31",
        transaction_type: "Debit",
        amount: 340000,
        transactionInformation: "Закупка оборудования",
        bankName: "Vbank",
        bankCode: "vtb",
        status: "Booked",
      },
    ];

    setTimeout(() => {
      setTransactions(mockTransactions);
      setIsLoading(false);
    }, 450);

    /* Закомментирован реальный API вызов
    const fetchTransactions = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const accountsRes = await getAllBankAccounts();
        if (!accountsRes.data.success) {
          throw new Error("Не удалось получить счета");
        }

        const allTransactions: BankTransaction[] = [];
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const fromDate = thirtyDaysAgo.toISOString().split("T")[0];
        const toDate = now.toISOString().split("T")[0];

        const bankNames: { [key: string]: string } = {
          vbank: "Virtual Bank",
          abank: "Awesome Bank",
          sbank: "Smart Bank",
        };

        const transactionPromises: Promise<void>[] = [];

        Object.entries(accountsRes.data.banks || {}).forEach(([bankCode, bankData]) => {
          if (bankData.success && bankData.accounts) {
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              
              if (!accountId) {
                console.warn(`[Payments] Skipping account without account_id:`, account);
                return;
              }
              
              const promise = getAccountTransactions(
                accountId,
                bankCode,
                undefined,
                fromDate,
                toDate
              )
                .then((response) => {
                  const txs = response.data.transactions || [];
                  // Добавляем название банка к каждой транзакции
                  const txsWithBank = txs.map((tx: BankTransaction) => ({
                    ...tx,
                    bankName: bankNames[bankCode] || bankCode,
                    bankCode: bankCode,
                  }));
                  allTransactions.push(...txsWithBank);
                })
                .catch((err) => {
                  console.error(`Error fetching transactions for account ${accountId}:`, err);
                });

              transactionPromises.push(promise);
            });
          }
        });

        await Promise.all(transactionPromises);

        // Sort by date (newest first)
        allTransactions.sort((a, b) => {
          const dateA = new Date(a.booking_date || a.bookingDateTime || a.value_date || a.valueDateTime || 0).getTime();
          const dateB = new Date(b.booking_date || b.bookingDateTime || b.value_date || b.valueDateTime || 0).getTime();
          return dateB - dateA;
        });

        setTransactions(allTransactions);
      } catch (err: any) {
        console.error("Error fetching payments:", err);
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить транзакции");
      } finally {
        setIsLoading(false);
      }
    };

    fetchTransactions();
    */
  }, [isAuthenticated]);

  const filteredTransactions = transactions.filter((tx) => {
    if (filter === "all") return true;
    const indicator = tx.transaction_type || tx.creditDebitIndicator;
    if (filter === "income") return indicator === "Credit";
    if (filter === "expense") return indicator === "Debit";
    return true;
  });

  const formatDate = (dateString?: string) => {
    if (!dateString) return "—";
    return new Date(dateString).toLocaleDateString("ru-RU", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
  };

  const formatAmount = (amount: number | string | undefined) => {
    if (amount === undefined || amount === null) return "0.00";
    const numAmount = typeof amount === "string" ? parseFloat(amount) : amount;
    return numAmount.toLocaleString("ru-RU", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Платежи</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть транзакции</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Платежи</h1>
          <p>История транзакций за последние 30 дней</p>
        </div>

        <Card>
          <CardHeader>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <CardTitle>Транзакции</CardTitle>
              <div className={styles.filters}>
                <button
                  className={filter === "all" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("all")}
                >
                  Все
                </button>
                <button
                  className={filter === "income" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("income")}
                >
                  Доходы
                </button>
                <button
                  className={filter === "expense" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("expense")}
                >
                  Расходы
                </button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Загрузка данных...</p>
              </div>
            ) : error ? (
              <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
                <p>{error}</p>
              </div>
            ) : filteredTransactions.length === 0 ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Нет транзакций за выбранный период</p>
              </div>
            ) : (
              <div className={styles.tableWrap}>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Дата</TableHead>
                      <TableHead>Описание</TableHead>
                      <TableHead>Банк</TableHead>
                      <TableHead>Тип</TableHead>
                      <TableHead>Сумма</TableHead>
                      <TableHead>Статус</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredTransactions.map((tx: any) => {
                      const indicator = tx.transaction_type || tx.creditDebitIndicator;
                      const isCredit = indicator === "Credit";
                      const txAmount = tx.amount || 0;
                      const txDate = tx.booking_date || tx.bookingDateTime || tx.value_date || tx.valueDateTime;
                      const txDescription = 
                        tx.transactionInformation ||
                        (typeof tx.remittance_information === "string" ? tx.remittance_information :
                         (tx.remittanceInformation && typeof tx.remittanceInformation === "object" ? tx.remittanceInformation.unstructured :
                          typeof tx.remittanceInformation === "string" ? tx.remittanceInformation : null)) ||
                        "Без описания";
                      // Используем название банка вместо контрагента
                      const bankName = tx.bankName || (tx.bankCode ? (bankNames[tx.bankCode] || tx.bankCode) : "—");
                      const txId = tx.transaction_id || tx.transactionId || `${txDate}-${txAmount}`;
                      
                      return (
                        <TableRow key={txId}>
                          <TableCell>{formatDate(txDate)}</TableCell>
                          <TableCell className={styles.description}>
                            {txDescription}
                          </TableCell>
                          <TableCell>{bankName}</TableCell>
                          <TableCell>
                            {isCredit ? (
                              <div className={styles.typeIncome}>
                                <ArrowUpCircle size={16} />
                                <span>Доход</span>
                              </div>
                            ) : (
                              <div className={styles.typeExpense}>
                                <ArrowDownCircle size={16} />
                                <span>Расход</span>
                              </div>
                            )}
                          </TableCell>
                          <TableCell
                            className={isCredit ? styles.amountIncome : styles.amountExpense}
                          >
                            {isCredit ? "+" : "-"}₽{formatAmount(txAmount)}
                          </TableCell>
                          <TableCell>
                            <span className={styles.status}>{tx.status || "Booked"}</span>
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/Profile/index.module.scss">
@use "../../styles/vars.scss" as *;
@use "../../styles/mixins" as *;

.profileContainer {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100%;
  padding: 2rem 1rem;
}

.profileCard {
  width: 100%;
  max-width: 600px;
  @include glass-card(true);
  border-radius: $radius;
  padding: 2.5rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.profileHeader {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.avatar {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  box-shadow: $shadow-glow;
  border: 3px solid $primary;
}

.profileName {
  font-size: 2rem;
  font-weight: 700;
  color: $foreground;
  @include text-glow($primary);
  text-align: center;
}

.profileInfo {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.infoItem {
  display: flex;
  align-items: flex-start;
  gap: 1rem;
  padding: 1.25rem;
  background: $secondary;
  border-radius: $radius-md;
  border: 1px solid $border;
  transition: $transition-smooth;

  &:hover {
    border-color: $primary;
    box-shadow: $shadow-soft;
  }
}

.infoIcon {
  width: 40px;
  height: 40px;
  border-radius: $radius-sm;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  flex-shrink: 0;
}

.infoContent {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.infoLabel {
  font-size: 0.875rem;
  color: $muted-foreground;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.infoValue {
  font-size: 1.125rem;
  color: $foreground;
  font-weight: 500;
}

.profileActions {
  display: flex;
  justify-content: center;
  padding-top: 1rem;
}

.logoutButton {
  min-width: 200px;
}

.loading,
.error {
  text-align: center;
  color: $foreground;
  font-size: 1.25rem;
  padding: 2rem;
}

.error {
  color: $danger;
}

.consentsSection {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding-top: 1rem;
  border-top: 1px solid $border;
}

.sectionTitle {
  font-size: 1.5rem;
  font-weight: 700;
  color: $foreground;
  margin: 0;
}

.sectionDescription {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin: 0;
}

.consentsList {
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.consentItem {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 1.25rem;
  background: $secondary;
  border-radius: $radius-md;
  border: 1px solid $border;
  transition: $transition-smooth;

  &:hover {
    border-color: $primary;
    box-shadow: $shadow-soft;
  }
}

.consentHeader {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.consentIcon {
  width: 32px;
  height: 32px;
  border-radius: $radius-sm;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  flex-shrink: 0;
}

.consentLabel {
  font-size: 1rem;
  font-weight: 600;
  color: $foreground;
}

.consentInputGroup {
  display: flex;
  gap: 0.5rem;
  align-items: flex-start;
}

.consentInput {
  flex: 1;
}

.consentActions {
  display: flex;
  gap: 0.5rem;
}

.saveButton,
.deleteButton {
  white-space: nowrap;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.consentSaved {
  font-size: 0.875rem;
  color: $muted-foreground;
  padding-top: 0.5rem;
  border-top: 1px solid $border;
}
</file>

<file path="src/pages/Profile/index.tsx">
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../hooks/useAuth";
import { eraseCookie, setCookie, getCookie } from "../../utils/cookies";
import { logout, getUserBankUsers, saveBankUser, deleteBankUser, createAccountConsent, getUserConsents, type BankConsent } from "../../utils/api";
import Layout from "../../components/Layout";
import { Button } from "../../ui/button";
import { Input } from "../../ui/input";
import { Label } from "../../ui/label";
import { CircleUser, Mail, Phone, Building2, Save, Trash2, Shield, CheckCircle2 } from "lucide-react";
import { useState, useEffect, useCallback } from "react";
import { toast } from "sonner";
import styles from "./index.module.scss";

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

export default function Profile() {
  const { user, isLoading } = useAuth();
  const navigate = useNavigate();
  const [bankUsers, setBankUsers] = useState<Record<string, string>>({});
  const [bankUserInputs, setBankUserInputs] = useState<Record<string, string>>({});
  const [isLoadingBankUsers, setIsLoadingBankUsers] = useState(true);
  const [saving, setSaving] = useState<Record<string, boolean>>({});
  const [consents, setConsents] = useState<Record<string, BankConsent>>({});
  const [isLoadingConsents, setIsLoadingConsents] = useState(true);
  const [creatingConsent, setCreatingConsent] = useState<Record<string, boolean>>({});

  const loadBankUsers = useCallback(async () => {
    try {
      setIsLoadingBankUsers(true);
      const response = await getUserBankUsers();
      setBankUsers(response.data.bank_users || {});
      // Инициализируем поля ввода текущими значениями
      setBankUserInputs(response.data.bank_users || {});
    } catch (error) {
      console.error("Error loading bank users:", error);
    } finally {
      setIsLoadingBankUsers(false);
    }
  }, []);

  const loadConsents = useCallback(async () => {
    try {
      setIsLoadingConsents(true);
      const response = await getUserConsents();
      const consentsMap: Record<string, BankConsent> = {};
      (response.data.consents || []).forEach((consent: BankConsent) => {
        consentsMap[consent.bank_code] = consent;
        // Сохраняем согласие в куки для использования в других запросах
        setCookie(`consent_${consent.bank_code}`, consent.consent_id, 365);
      });
      setConsents(consentsMap);
    } catch (error) {
      console.error("Error loading consents:", error);
    } finally {
      setIsLoadingConsents(false);
    }
  }, []);

  useEffect(() => {
    if (user) {
      loadBankUsers();
      loadConsents();
    }
  }, [user, loadBankUsers, loadConsents]);

  const handleSaveBankUser = async (bankCode: string) => {
    const bankUserId = bankUserInputs[bankCode]?.trim();
    if (!bankUserId) {
      toast.error("Введите ID пользователя", {
        description: "Поле не может быть пустым",
        duration: 1500,
      });
      return;
    }

    try {
      setSaving((prev) => ({ ...prev, [bankCode]: true }));
      await saveBankUser({ bank_code: bankCode, bank_user_id: bankUserId });
      setBankUsers((prev) => ({ ...prev, [bankCode]: bankUserId }));
      toast.success(`ID пользователя для ${bankNames[bankCode]} сохранен`, {
        description: "Банковская интеграция настроена",
        duration: 1500,
      });
    } catch (error: any) {
      console.error("Error saving bank user:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при сохранении ID пользователя";
      toast.error("Не удалось сохранить ID пользователя", {
        description: errorMessage,
        duration: 1500,
      });
    } finally {
      setSaving((prev) => ({ ...prev, [bankCode]: false }));
    }
  };

  const handleDeleteBankUser = async (bankCode: string) => {
    // Use toast.promise for confirmation-like behavior
    const confirmed = window.confirm(`Удалить ID пользователя для ${bankNames[bankCode]}?`);
    if (!confirmed) {
      return;
    }

    try {
      await deleteBankUser(bankCode);
      setBankUsers((prev) => {
        const newBankUsers = { ...prev };
        delete newBankUsers[bankCode];
        return newBankUsers;
      });
      setBankUserInputs((prev) => {
        const newInputs = { ...prev };
        delete newInputs[bankCode];
        return newInputs;
      });
      toast.success(`ID пользователя для ${bankNames[bankCode]} удален`, {
        description: "Банковская интеграция отключена",
        duration: 1500,
      });
    } catch (error: any) {
      console.error("Error deleting bank user:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при удалении ID пользователя";
      toast.error("Не удалось удалить ID пользователя", {
        description: errorMessage,
        duration: 1500,
      });
    }
  };

  const handleCreateConsent = async (bankCode: string) => {
    if (!bankUsers[bankCode]) {
      toast.error("Сначала укажите ID пользователя в банке", {
        description: `Для ${bankNames[bankCode]} необходимо указать ID пользователя`,
        duration: 2000,
      });
      return;
    }

    try {
      setCreatingConsent((prev) => ({ ...prev, [bankCode]: true }));
      const response = await createAccountConsent(bankCode);
      
      // Сохраняем согласие в куки
      setCookie(`consent_${bankCode}`, response.data.consent_id, 365);
      
      // Обновляем список согласий
      const newConsent: BankConsent = {
        consent_id: response.data.consent_id,
        bank_code: bankCode,
        status: response.data.status,
        auto_approved: response.data.auto_approved,
        expires_at: response.data.expires_at,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
      
      setConsents((prev) => ({
        ...prev,
        [bankCode]: newConsent,
      }));
      
      toast.success(`Согласие для ${bankNames[bankCode]} создано`, {
        description: `ID: ${response.data.consent_id}`,
        duration: 2000,
      });
    } catch (error: any) {
      console.error("Error creating consent:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при создании согласия";
      toast.error("Не удалось создать согласие", {
        description: errorMessage,
        duration: 2000,
      });
    } finally {
      setCreatingConsent((prev) => ({ ...prev, [bankCode]: false }));
    }
  };

  const handleLogout = () => {
    logout();
    eraseCookie("access_token");
    eraseCookie("refresh_token");
    toast.success("Вы успешно вышли из аккаунта", {
      description: "До свидания!",
      duration: 1500,
    });
    navigate("/");
    setTimeout(() => {
      window.location.reload();
    }, 500);
  };

  if (isLoading) {
    return (
      <Layout>
        <div className={styles.profileContainer}>
          <div className={styles.loading}>Загрузка...</div>
        </div>
      </Layout>
    );
  }

  if (!user) {
    return (
      <Layout>
        <div className={styles.profileContainer}>
          <div className={styles.error}>Пользователь не найден</div>
        </div>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.profileContainer}>
        <div className={styles.profileCard}>
          <div className={styles.profileHeader}>
            <div className={styles.avatar}>
              <CircleUser size={64} />
            </div>
            <h1 className={styles.profileName}>
              {user.first_name} {user.last_name}
            </h1>
          </div>

          <div className={styles.profileInfo}>
            <div className={styles.infoItem}>
              <div className={styles.infoIcon}>
                <Mail size={20} />
              </div>
              <div className={styles.infoContent}>
                <div className={styles.infoLabel}>Email</div>
                <div className={styles.infoValue}>{user.email}</div>
              </div>
            </div>

            <div className={styles.infoItem}>
              <div className={styles.infoIcon}>
                <Phone size={20} />
              </div>
              <div className={styles.infoContent}>
                <div className={styles.infoLabel}>Телефон</div>
                <div className={styles.infoValue}>{user.phone_number}</div>
              </div>
            </div>
          </div>

          {/* Bank Users Section */}
          <div className={styles.consentsSection}>
            <h2 className={styles.sectionTitle}>ID пользователей в банках</h2>
            <p className={styles.sectionDescription}>
              Введите ваш ID пользователя для каждого банка. После этого вы сможете получать данные о счетах и транзакциях.
            </p>
            
            {isLoadingBankUsers ? (
              <div className={styles.loading}>Загрузка...</div>
            ) : (
              <div className={styles.consentsList}>
                {(["vbank", "abank", "sbank"] as const).map((bankCode) => (
                  <div key={bankCode} className={styles.consentItem}>
                    <div className={styles.consentHeader}>
                      <div className={styles.consentIcon}>
                        <Building2 size={20} />
                      </div>
                      <Label htmlFor={`bank-user-${bankCode}`} className={styles.consentLabel}>
                        {bankNames[bankCode]}
                      </Label>
                    </div>
                    <div className={styles.consentInputGroup}>
                      <Input
                        id={`bank-user-${bankCode}`}
                        type="text"
                        placeholder="Введите ваш ID в банке"
                        value={bankUserInputs[bankCode] || ""}
                        onChange={(e) =>
                          setBankUserInputs((prev) => ({
                            ...prev,
                            [bankCode]: e.target.value,
                          }))
                        }
                        className={styles.consentInput}
                      />
                      <div className={styles.consentActions}>
                        <Button
                          size="sm"
                          onClick={() => handleSaveBankUser(bankCode)}
                          disabled={saving[bankCode]}
                          className={styles.saveButton}
                        >
                          <Save size={16} />
                          {saving[bankCode] ? "Сохранение..." : "Сохранить"}
                        </Button>
                        {bankUsers[bankCode] && (
                          <Button
                            size="sm"
                            variant="destructive"
                            onClick={() => handleDeleteBankUser(bankCode)}
                            className={styles.deleteButton}
                          >
                            <Trash2 size={16} />
                          </Button>
                        )}
                      </div>
                    </div>
                    {bankUsers[bankCode] && (
                      <div className={styles.consentSaved}>
                        Сохранен: {bankUsers[bankCode]}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Consents Section */}
          <div className={styles.consentsSection}>
            <h2 className={styles.sectionTitle}>Согласия на доступ к данным</h2>
            <p className={styles.sectionDescription}>
              Создайте согласие для каждого банка, чтобы получать данные о счетах, балансах и транзакциях.
            </p>
            
            {isLoadingConsents ? (
              <div className={styles.loading}>Загрузка...</div>
            ) : (
              <div className={styles.consentsList}>
                {(["vbank", "abank", "sbank"] as const).map((bankCode) => {
                  const consent = consents[bankCode];
                  const hasBankUser = !!bankUsers[bankCode];
                  
                  return (
                    <div key={bankCode} className={styles.consentItem}>
                      <div className={styles.consentHeader}>
                        <div className={styles.consentIcon}>
                          <Shield size={20} />
                        </div>
                        <Label className={styles.consentLabel}>
                          {bankNames[bankCode]}
                        </Label>
                        {consent && consent.status === "approved" && (
                          <div className={styles.consentStatus}>
                            <CheckCircle2 size={16} className={styles.consentStatusIcon} />
                            <span>Активно</span>
                          </div>
                        )}
                      </div>
                      
                      {consent ? (
                        <div className={styles.consentInfo}>
                          <div className={styles.consentDetails}>
                            <div className={styles.consentDetail}>
                              <span className={styles.consentDetailLabel}>ID согласия:</span>
                              <span className={styles.consentDetailValue}>{consent.consent_id}</span>
                            </div>
                            {consent.expires_at && (
                              <div className={styles.consentDetail}>
                                <span className={styles.consentDetailLabel}>Истекает:</span>
                                <span className={styles.consentDetailValue}>
                                  {new Date(consent.expires_at).toLocaleDateString("ru-RU")}
                                </span>
                              </div>
                            )}
                            <div className={styles.consentDetail}>
                              <span className={styles.consentDetailLabel}>Статус:</span>
                              <span className={styles.consentDetailValue}>{consent.status}</span>
                            </div>
                          </div>
                          <Button
                            size="sm"
                            onClick={() => handleCreateConsent(bankCode)}
                            disabled={creatingConsent[bankCode] || !hasBankUser}
                            className={styles.createConsentButton}
                          >
                            <Shield size={16} />
                            {creatingConsent[bankCode] ? "Создание..." : "Обновить согласие"}
                          </Button>
                        </div>
                      ) : (
                        <div className={styles.consentInfo}>
                          <div className={styles.consentEmpty}>
                            {hasBankUser ? (
                              <p>Согласие не создано. Нажмите кнопку ниже для создания.</p>
                            ) : (
                              <p>Сначала укажите ID пользователя в банке выше.</p>
                            )}
                          </div>
                          <Button
                            size="sm"
                            onClick={() => handleCreateConsent(bankCode)}
                            disabled={creatingConsent[bankCode] || !hasBankUser}
                            className={styles.createConsentButton}
                          >
                            <Shield size={16} />
                            {creatingConsent[bankCode] ? "Создание..." : "Создать согласие"}
                          </Button>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          <div className={styles.profileActions}>
            <Button
              variant="destructive"
              size="lg"
              onClick={handleLogout}
              className={styles.logoutButton}
            >
              Выйти
            </Button>
          </div>
        </div>
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/Receivables/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.summaryGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.tableWrap {
  overflow-x: auto;
}

.invoiceNumber {
  font-weight: 600;
  font-family: monospace;
}

.amount,
.paidAmount {
  font-weight: 600;
}

.overdueDays {
  color: $danger;
  font-size: 0.875rem;
  margin-left: 0.5rem;
}

.filters {
  display: flex;
  gap: 0.5rem;
}

.filterButton,
.filterActive {
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $input;
  color: $foreground;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background-color: $input;
    border-color: $primary;
  }
}

.filterActive {
  background-color: $primary;
  color: white;
  border-color: $primary;
}

.badgeWarning {
  background-color: rgba(251, 191, 36, 0.1);
  color: #f59e0b;
}

.badgeSuccess {
  background-color: rgba(16, 185, 129, 0.1);
  color: #10b981;
}

.badgeDanger {
  background-color: rgba(239, 68, 68, 0.1);
  color: #ef4444;
}

.badgeInfo {
  background-color: rgba(59, 130, 246, 0.1);
  color: #3b82f6;
}

.badgeDefault {
  background-color: rgba(107, 114, 128, 0.1);
  color: #6b7280;
}
</file>

<file path="src/pages/Receivables/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../../ui/table";
import { Users, AlertCircle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getInvoices, getARSummary, type Invoice, type ARSummary } from "../../utils/api";
import StatCard from "../../components/StatCard";
import styles from "./index.module.scss";
import { toast } from "sonner";

export default function Receivables() {
  const { isAuthenticated } = useAuth();
  const [invoices, setInvoices] = useState<Invoice[]>([]);
  const [summary, setSummary] = useState<ARSummary["summary"] | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<string | undefined>(undefined);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    // Используем захардкоженные данные для демонстрации
    const mockSummary = {
      total_ar: 2340000,
      overdue_ar: 340000,
      overdue_count: 3,
      pending_count: 8,
      paid_count: 12,
    };

    const allMockInvoices: Invoice[] = [
      {
        id: "inv-001",
        invoice_number: "INV-2024-001",
        counterparty_name: "ООО \"Альфа\"",
        invoice_date: "2024-11-01",
        due_date: "2024-11-15",
        amount: 450000,
        paid_amount: 450000,
        status: "paid",
        days_overdue: 0,
      },
      {
        id: "inv-002",
        invoice_number: "INV-2024-002",
        counterparty_name: "ООО \"Бета\"",
        invoice_date: "2024-11-03",
        due_date: "2024-11-17",
        amount: 320000,
        paid_amount: 320000,
        status: "paid",
        days_overdue: 0,
      },
      {
        id: "inv-003",
        invoice_number: "INV-2024-003",
        counterparty_name: "ООО \"Гамма\"",
        invoice_date: "2024-11-05",
        due_date: "2024-11-19",
        amount: 180000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-004",
        invoice_number: "INV-2024-004",
        counterparty_name: "ООО \"Дельта\"",
        invoice_date: "2024-11-06",
        due_date: "2024-11-20",
        amount: 275000,
        paid_amount: 275000,
        status: "paid",
        days_overdue: 0,
      },
      {
        id: "inv-005",
        invoice_number: "INV-2024-005",
        counterparty_name: "ООО \"Эпсилон\"",
        invoice_date: "2024-11-07",
        due_date: "2024-11-21",
        amount: 95000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-006",
        invoice_number: "INV-2024-006",
        counterparty_name: "ООО \"Зета\"",
        invoice_date: "2024-11-08",
        due_date: "2024-11-22",
        amount: 520000,
        paid_amount: 520000,
        status: "paid",
        days_overdue: 0,
      },
      {
        id: "inv-007",
        invoice_number: "INV-2024-007",
        counterparty_name: "ООО \"Эта\"",
        invoice_date: "2024-10-25",
        due_date: "2024-11-08",
        amount: 68000,
        paid_amount: 0,
        status: "overdue",
        days_overdue: 8,
      },
      {
        id: "inv-008",
        invoice_number: "INV-2024-008",
        counterparty_name: "ООО \"Тета\"",
        invoice_date: "2024-10-28",
        due_date: "2024-11-11",
        amount: 142000,
        paid_amount: 0,
        status: "overdue",
        days_overdue: 5,
      },
      {
        id: "inv-009",
        invoice_number: "INV-2024-009",
        counterparty_name: "ООО \"Йота\"",
        invoice_date: "2024-10-30",
        due_date: "2024-11-13",
        amount: 130000,
        paid_amount: 0,
        status: "overdue",
        days_overdue: 3,
      },
      {
        id: "inv-010",
        invoice_number: "INV-2024-010",
        counterparty_name: "ООО \"Каппа\"",
        invoice_date: "2024-11-10",
        due_date: "2024-11-24",
        amount: 385000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-011",
        invoice_number: "INV-2024-011",
        counterparty_name: "ООО \"Лямбда\"",
        invoice_date: "2024-11-11",
        due_date: "2024-11-25",
        amount: 225000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-012",
        invoice_number: "INV-2024-012",
        counterparty_name: "ООО \"Мю\"",
        invoice_date: "2024-11-12",
        due_date: "2024-11-26",
        amount: 198000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-013",
        invoice_number: "INV-2024-013",
        counterparty_name: "ООО \"Ню\"",
        invoice_date: "2024-10-20",
        due_date: "2024-11-03",
        amount: 410000,
        paid_amount: 410000,
        status: "paid",
        days_overdue: 0,
      },
      {
        id: "inv-014",
        invoice_number: "INV-2024-014",
        counterparty_name: "ООО \"Кси\"",
        invoice_date: "2024-11-13",
        due_date: "2024-11-27",
        amount: 165000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
      {
        id: "inv-015",
        invoice_number: "INV-2024-015",
        counterparty_name: "ООО \"Омикрон\"",
        invoice_date: "2024-11-14",
        due_date: "2024-11-28",
        amount: 290000,
        paid_amount: 0,
        status: "pending",
        days_overdue: 0,
      },
    ];

    setTimeout(() => {
      setSummary(mockSummary);
      
      // Фильтруем счета по статусу
      let filteredInvoices = allMockInvoices;
      if (statusFilter) {
        filteredInvoices = allMockInvoices.filter(inv => inv.status === statusFilter);
      }
      
      setInvoices(filteredInvoices);
      setIsLoading(false);
    }, 400);

    /* Закомментирован реальный API вызов
    const fetchData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const [invoicesRes, summaryRes] = await Promise.all([
          getInvoices(statusFilter),
          getARSummary(),
        ]);

        if (invoicesRes.data.success && invoicesRes.data.invoices) {
          setInvoices(invoicesRes.data.invoices);
        }

        if (summaryRes.data.success && summaryRes.data.summary) {
          setSummary(summaryRes.data.summary);
        }
      } catch (err: any) {
        console.error("Error fetching receivables:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить данные о дебиторской задолженности");
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
    */
  }, [isAuthenticated, statusFilter]);

  const getStatusBadge = (status: string) => {
    const statusMap: Record<string, { label: string; variant: string }> = {
      pending: { label: "Ожидает оплаты", variant: "warning" },
      partial: { label: "Частично оплачено", variant: "info" },
      paid: { label: "Оплачено", variant: "success" },
      overdue: { label: "Просрочено", variant: "danger" },
      cancelled: { label: "Отменено", variant: "default" },
    };

    const statusInfo = statusMap[status.toLowerCase()] || { label: status, variant: "default" };

    return (
      <Badge className={styles[`badge${statusInfo.variant.charAt(0).toUpperCase() + statusInfo.variant.slice(1)}`]}>
        {statusInfo.label}
      </Badge>
    );
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("ru-RU", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Дебиторская задолженность</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть счета к получению</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Дебиторская задолженность</h1>
          <p>Управление счетами к получению</p>
        </div>

        {summary && (
          <div className={styles.summaryGrid}>
            <StatCard
              title="Общая ДЗ"
              value={`₽${(summary.total_ar || 0).toLocaleString()}`}
              subtitle="Всего к получению"
              icon={Users}
              variant="default"
            />
            <StatCard
              title="Просрочено"
              value={`₽${(summary.overdue_ar || 0).toLocaleString()}`}
              subtitle={`${summary.overdue_count || 0} счетов`}
              icon={AlertCircle}
              variant="danger"
            />
            <StatCard
              title="Ожидает оплаты"
              value={`${summary.pending_count || 0}`}
              subtitle="Счетов"
              icon={Users}
              variant="warning"
            />
            <StatCard
              title="Оплачено"
              value={`${summary.paid_count || 0}`}
              subtitle="Счетов"
              icon={Users}
              variant="success"
            />
          </div>
        )}

        <Card>
          <CardHeader>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <CardTitle>Счета к получению</CardTitle>
              <div className={styles.filters}>
                <button
                  className={statusFilter === undefined ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter(undefined)}
                >
                  Все
                </button>
                <button
                  className={statusFilter === "pending" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("pending")}
                >
                  Ожидают
                </button>
                <button
                  className={statusFilter === "overdue" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("overdue")}
                >
                  Просрочено
                </button>
                <button
                  className={statusFilter === "paid" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("paid")}
                >
                  Оплачено
                </button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Загрузка данных...</p>
              </div>
            ) : error ? (
              <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
                <p>{error}</p>
              </div>
            ) : invoices.length === 0 ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Нет счетов к получению</p>
              </div>
            ) : (
              <div className={styles.tableWrap}>
                <Table>
                  <TableHeader>
                    <TableRow>
                      {/* <TableHead>Номер счета</TableHead> */}
                      <TableHead>Дата</TableHead>
                      <TableHead>Срок оплаты</TableHead>
                      <TableHead>Сумма</TableHead>
                      <TableHead>Оплачено</TableHead>
                      <TableHead>Статус</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {invoices.map((invoice) => (
                      <TableRow key={invoice.id}>
                        {/* <TableCell className={styles.invoiceNumber}>{invoice.invoice_number}</TableCell> */}
                        <TableCell>{formatDate(invoice.invoice_date)}</TableCell>
                        <TableCell>
                          {formatDate(invoice.due_date)}
                          {invoice.days_overdue && invoice.days_overdue > 0 && (
                            <span className={styles.overdueDays}> ({invoice.days_overdue} дн.)</span>
                          )}
                        </TableCell>
                        <TableCell className={styles.amount}>
                          ₽{invoice.amount.toLocaleString("ru-RU", {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          })}
                        </TableCell>
                        <TableCell className={styles.paidAmount}>
                          ₽{invoice.paid_amount.toLocaleString("ru-RU", {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          })}
                        </TableCell>
                        <TableCell>{getStatusBadge(invoice.status)}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="src/pages/Settings/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.icon {
  width: 1.5rem;
  height: 1.5rem;
  color: $primary;
}
</file>

<file path="src/pages/Settings/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Settings as SettingsIcon } from "lucide-react";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";

export default function Settings() {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Настройки</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы изменить настройки</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Настройки</h1>
          <p>Управление настройками приложения</p>
        </div>

        <Card>
          <CardHeader>
            <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
              <SettingsIcon className={styles.icon} />
              <CardTitle>Настройки профиля</CardTitle>
            </div>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>
              Настройки профиля доступны на странице{" "}
              <a href="/profile" style={{ color: "var(--primary)", textDecoration: "underline" }}>
                Профиль
              </a>
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Уведомления</CardTitle>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>Настройки уведомлений будут доступны в будущих версиях</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Интеграции</CardTitle>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>
              Управление банковскими интеграциями доступно на странице{" "}
              <a href="/profile" style={{ color: "var(--primary)", textDecoration: "underline" }}>
                Профиль
              </a>
            </p>
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="src/styles/colors.ts">
// This file colors for recharts

export const primary_hsl = "270 80% 65%";
export const accent_hsl = "180 95% 55%";

export const primary = `hsl(${primary_hsl})`;
export const accent = `hsl(${accent_hsl})`;

export const danger = `hsl(0 72% 58%)`;
export const border = `hsl(240 8% 18%)`;
export const muted_foreground = `hsl(210 20% 65%)`;
export const popover = `hsl(240 8% 12%)`;

export const primaryHslParts = primary_hsl.split(" ");
export const accentHslParts = accent_hsl.split(" ");

export default {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
};
</file>

<file path="src/styles/globals.scss">
/* Файл: src/styles/globals.scss */
@use "vars" as *;
@use "mixins" as *;

/* Базовые стили */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border-color: $border;
}

body {
  background-color: $background;
  color: $foreground;
  overflow-x: hidden;
  background-image: $gradient-glow;
  background-attachment: fixed;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Глобальные утилитарные классы */
.glass-card {
  @include glass-card(false);
}

.glass-card-hover {
  @include glass-card(true);
}

.gradient-primary {
  background: $gradient-primary;
}

.gradient-accent {
  background: $gradient-accent;
}

.text-glow {
  @include text-glow($primary);
}

/* Стили для скроллбара (по желанию) */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: 	#8c8c8c transparent;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #8c8c8c;
    border-radius: 20px;
  }
}
</file>

<file path="src/styles/main.scss">
@use "vars";
@use "mixins";
@use "globals";
</file>

<file path="src/styles/mixins.scss">
/* Файл: src/styles/mixins.scss */
@use "vars" as *;
@use "sass:color";

/* Миксин для "стеклянной" карточки 
  @include glass-card(true) для эффекта при наведении
*/
@mixin glass-card($hover-effect: false) {
  backdrop-filter: $blur-xl ;
  border: 1px solid $glass-border;
  background: $glass-bg;
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

  @if $hover-effect {
    &:hover {
      border-color: $popover;
      box-shadow: $shadow-medium, $shadow-glow;
      transform: translateY(-2px);
    }
  }
}

/* Миксин для свечения текста */
@mixin text-glow($color: $primary) {
  $as-hsl: color.to-space($color, hsl);
  text-shadow: 0 0 20px hsla(color.channel($as-hsl, "hue"),
      color.channel($as-hsl, "saturation"),
      color.channel($as-hsl, "lightness"),
      0.3);
}

/* Миксин для градиентного текста */
@mixin gradient-text($gradient) {
  background: $gradient;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-fill-color: transparent;
}
</file>

<file path="src/styles/vars.scss">
// Основные цвета
$background: #0f101a;
$foreground: #edf2f9;
$card: #12131a;
$popover: #171820;
$primary: #c67dff;
$primary-light: #d4a1ff;
$primary-glow: #e9d2ff;
$secondary: #1a1b22;
$accent: #00f5cc;
$accent-light: #33ffd5;
$accent-glow: #a8fff8;
$success: #00d6a3;
$success-light: #33e8b8;
$success-glow: #a3ffe9;
$warning: #ff9933;
$warning-light: #ffaf66;
$danger: #ff505f;
$danger-light: #ff7f8c;
$muted: #1a1b22;
$border: #282a33;
$input: #282a33;
$ring: #c67dff;

// Специальные цвета
$chart-1: $primary;
$chart-2: $accent;
$chart-3: $success;
$chart-4: #cf77ff;
$chart-5: $warning;

// Цвета для текста
$primary-foreground: $foreground;
$secondary-foreground: $foreground;
$accent-foreground: $background;
$success-foreground: $background;
$warning-foreground: $background;
$danger-foreground: $foreground;
$muted-foreground: #a0a7b6;
$destructive: $danger;
$destructive-foreground: $foreground;
$card-foreground: $foreground;
$popover-foreground: $foreground;

// Градиенты
$gradient-primary: linear-gradient(135deg, $primary 0%, #cf77ff 100%);
$gradient-accent: linear-gradient(135deg, $accent 0%, $success 100%);
$gradient-card: linear-gradient(135deg, $card 0%, #1d1e26 100%);
$gradient-glow: radial-gradient(circle at 50% 0%, rgba($primary, 0.15) 0%, transparent 60%);

// Тени
$shadow-soft: 0 2px 16px -4px rgba($primary, 0.15);
$shadow-medium: 0 8px 32px -8px rgba($primary, 0.25);
$shadow-strong: 0 16px 48px -12px rgba($primary, 0.35);
$shadow-glow: 0 0 40px rgba($primary, 0.2);

// Прочие переменные
$radius: 1.25rem;
$radius-md: calc($radius - 2px);
$radius-sm: calc($radius - 4px);
$radius-lg: 10px;
$transition-smooth: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
$transition-bounce: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
$glass-bg: rgba(#1c1d26, 0.4);
$glass-border: rgba($foreground, 0.1);
$blur-xl: blur(20px)
</file>

<file path="src/ui/badge/index.module.scss">
@use "../../styles/vars" as *;


.badge {
  display: inline-flex;
  align-items: center;
  border-radius: 9999px;
  border: 1px solid;
  padding: 0.125rem 0.625rem;
  font-size: 0.75rem; 
  font-weight: 600; 
  transition: background-color 0.2s, color 0.2s, border-color 0.2s;

  &:focus {
    outline: none;
    box-shadow: 0 0 0 2px $background, 0 0 0 4px $ring;
  }
}


.default {
  border-color: transparent;
  background-color: $primary;
  color: $primary-foreground;
  &:hover {
    background-color: rgba($primary, 0.8);
  }
}

.secondary {
  border-color: transparent;
  background-color: $secondary;
  color: $secondary-foreground;
  &:hover {
    background-color: rgba($secondary, 0.8);
  }
}

.destructive {
  border-color: transparent;
  background-color: $danger;
  color: $destructive-foreground;
  &:hover {
    background-color: rgba($danger, 0.8);
  }
}


.outline {
  color: $foreground;
  border-color: $border; 
}
</file>

<file path="src/ui/badge/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

type BadgeVariant = "default" | "secondary" | "destructive" | "outline";

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: BadgeVariant;
}

function Badge({ className, variant = "default", ...props }: BadgeProps) {
  return <div className={cn(styles.badge, styles[variant], className)} {...props} />;
}

export { Badge };
</file>

<file path="src/ui/button/index.module.scss">
@use "../../styles/vars" as *;

.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  white-space: nowrap;
  border-radius: $radius-md;
  font-size: 0.875rem;
  font-weight: 500;
  transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s;
  cursor: pointer;

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px $background, 0 0 0 4px $ring;
  }

  &:disabled {
    pointer-events: none;
    opacity: 0.5;
  }


  > svg {
    pointer-events: none;
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
  }


  height: 2.5rem;
  padding: 0.5rem 1rem;
}


.sm {
  height: 2.25rem;
  padding: 0 0.75rem;
}


.lg {
  height: 2.75rem;
  padding: 0 2rem;
}


.icon {
  height: 2.5rem;
  width: 2.5rem;
  padding: 0;
}



.default {
  background-color: $primary;
  color: $primary-foreground;
  border: 1px solid $primary;
  &:hover {
    background-color: rgba($primary, 0.9);
    border-color: rgba($primary, 0.9);
  }
}


.destructive {
  background-color: $danger;
  color: $destructive-foreground;
  border: 1px solid $danger;
  &:hover {
    background-color: rgba($danger, 0.9);
    border-color: rgba($danger, 0.9);
  }
}

.outline {
  border: 1px solid $input;
  background-color: $background;
  color: $foreground;
  &:hover {
    background-color: $accent;
    color: $accent-foreground;
    border-color: $accent;
  }
}

.secondary {
  background-color: $secondary;
  color: $secondary-foreground;
  border: 1px solid $secondary;
  &:hover {
    background-color: rgba($secondary, 0.8);
    border-color: rgba($secondary, 0.8);
  }
}


.ghost {
  background-color: transparent;
  border: 1px solid transparent;
  color: $foreground;
  &:hover {
    background-color: $accent;
    color: $accent-foreground;
  }
}


.link {
  background-color: transparent;
  border: 1px solid transparent;
  color: $primary;
  text-underline-offset: 4px;
  &:hover {
    text-decoration: underline;
  }
}
</file>

<file path="src/ui/button/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";


type ButtonVariant = "default" | "destructive" | "outline" | "secondary" | "ghost" | "link";
type ButtonSize = "default" | "sm" | "lg" | "icon";

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = "default", size = "default", ...props }, ref) => {
    return (
      <button
        className={cn(
          styles.button,
          styles[variant],
          size !== "default" && styles[size],
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button };
</file>

<file path="src/ui/card/index.module.scss">
@use "../../styles/vars" as *;

.card {
  border-radius: $radius-lg;
  border: 1px solid $border;
  background-color: $card;
  color: $card-foreground;
  box-shadow: $shadow-soft;
}


.cardHeader {
  display: flex;
  flex-direction: column;
  padding: 1.5rem;
  
  > *:not([hidden]) ~ *:not([hidden]) {
    margin-top: 0.375rem;
  }
}


.cardTitle {
  font-size: 1.5rem; 
  font-weight: 600;
  line-height: 1;
  letter-spacing: -0.025em;
}

.cardDescription {
  font-size: 0.875rem;
  color: $muted-foreground;
}

.cardContent {
  padding: 1.5rem;
  padding-top: 0;
}

.cardFooter {
  display: flex;
  align-items: center;
  padding: 1.5rem;
  padding-top: 0;
}
</file>

<file path="src/ui/card/index.tsx">
import {forwardRef, type HTMLAttributes} from "react";
import cn from "classnames";
import styles from "./index.module.scss";


const Card = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
    <div ref={ref} className={cn(styles.card, className)} {...props} />
));
Card.displayName = "Card";

const CardHeader = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => (
        <div ref={ref} className={cn(styles.cardHeader, className)} {...props} />
    ),
);
CardHeader.displayName = "CardHeader";

const CardTitle = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLHeadingElement>>(
    ({ className, ...props }, ref) => (
        <h3 ref={ref} className={cn(styles.cardTitle, className)} {...props} />
    ),
);
CardTitle.displayName = "CardTitle";

const CardDescription = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
    ({ className, ...props }, ref) => (
        <p ref={ref} className={cn(styles.cardDescription, className)} {...props} />
    ),
);
CardDescription.displayName = "CardDescription";

const CardContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => <div ref={ref} className={cn(styles.cardContent, className)} {...props} />,
);
CardContent.displayName = "CardContent";

const CardFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => (
        <div ref={ref} className={cn(styles.cardFooter, className)} {...props} />
    ),
);
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="src/ui/input/index.module.scss">
@use "../../styles/vars.scss" as *;

.input {
  width: 100%;
  background-color: $input;
  border: 1px solid $border;
  color: $foreground;
  border-radius: $radius-md;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  transition: all 0.2s ease;
  font-family: inherit;

  &:focus {
    outline: none;
    border-color: $primary;
    box-shadow: 0 0 0 2px rgba($primary, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  &::placeholder {
    color: $muted-foreground;
  }

  &:-webkit-autofill,
  &:-webkit-autofill:hover,
  &:-webkit-autofill:focus,
  &:-webkit-autofill:active {
    -webkit-background-clip: text;
    -webkit-text-fill-color: $foreground;
    -webkit-box-shadow: 0 0 0px 1000px $input inset;
    box-shadow: 0 0 0px 1000px $input inset;
    transition: background-color 5000s ease-in-out 0s;
    border-color: $border;
  }
}
</file>

<file path="src/ui/input/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, ...props }, ref) => {
    return (
      <input
        className={cn(styles.input, className)}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/ui/label/index.module.scss">
@use "../../styles/vars.scss" as *;

.label {
  font-weight: 600;
  font-size: 0.875rem;
  color: $foreground;
  display: block;
  margin-bottom: 0.5rem;
  cursor: pointer;

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
}
</file>

<file path="src/ui/label/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

export interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {}

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => {
    return (
      <label
        className={cn(styles.label, className)}
        ref={ref}
        {...props}
      />
    );
  },
);
Label.displayName = "Label";

export { Label };
</file>

<file path="src/ui/sonner/index.tsx">
import { Toaster as Sonner, toast } from "sonner";
import "./sonner.module.scss";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      theme="light"
      className="toaster group"
      {...props}
    />
  );
};

export { Toaster, toast };
</file>

<file path="src/ui/sonner/sonner.module.scss">
// Custom styles for Sonner toasts - using :global to apply globally
:global {
  [data-sonner-toaster] {
    position: fixed !important;
    top: 20px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    right: auto !important;
    width: auto !important;
    margin: 0 !important;
    padding: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: flex-start !important;
  }
  
  [data-sonner-toaster][data-x-position="center"] {
    left: 50% !important;
    transform: translateX(-50%) !important;
    right: auto !important;
  }

  [data-sonner-toast] {
    min-width: 450px !important;
    max-width: 650px !important;
    font-size: 16px !important;
    padding: 18px 24px !important;
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15) !important;
    margin: 0 auto !important;
    position: relative !important;
    left: auto !important;
    right: auto !important;
    transform: none !important;
    opacity: 1 !important;
    transition: opacity 0.3s ease-out !important;
  }

  [data-sonner-toast][data-styled="true"] {
    min-width: 450px !important;
    max-width: 650px !important;
  }

  // Fade out animation when toast is dismissing
  [data-sonner-toast][data-removed="true"] {
    opacity: 0 !important;
    transition: opacity 0.3s ease-out !important;
  }

  [data-sonner-toast] [data-title] {
    font-size: 18px !important;
    font-weight: 600 !important;
    line-height: 1.4 !important;
    padding-right: 0 !important;
  }

  [data-sonner-toast] [data-description] {
    font-size: 15px !important;
    line-height: 1.5 !important;
    margin-top: 8px !important;
    opacity: 0.9 !important;
    padding-right: 0 !important;
  }

  [data-sonner-toast] [data-button] {
    font-size: 14px !important;
    padding: 8px 16px !important;
  }

  // Hide close button
  [data-sonner-toast] [data-close-button] {
    display: none !important;
  }
}
</file>

<file path="src/ui/table/index.module.scss">
@use "../../styles/vars" as *;

.tableWrapper {
  position: relative;
  width: 100%;
  overflow-x: auto;
}

.table {
  width: 100%;
  caption-side: bottom;
  font-size: 0.875rem;
}

.tableHeader {

  tr {
    border-bottom: 1px solid $border;
  }
}

.tableBody {
  tr:last-child {
    border-bottom: 0;
  }
}

.tableFooter {
  border-top: 1px solid $border;
  background-color: rgba($muted, 0.5);
  font-weight: 500;
  tr:last-child {
    border-bottom: 0;
  }
}

.tableRow {
  border-bottom: 1px solid $border;
  transition: background-color 0.2s;

  &[data-state="selected"] {
    background-color: $muted;
  }

  &:hover {
    background-color: rgba($muted, 0.5);
  }
}

.tableHead {
  height: 3rem; 
  padding: 0 1rem; 
  text-align: left;
  vertical-align: middle;
  font-weight: 500; 
  color: $muted-foreground;

  &:has([role="checkbox"]) {
    padding-right: 0;
  }
}

.tableCell {
  padding: 1rem;
  vertical-align: middle;

  &:has([role="checkbox"]) {
    padding-right: 0;
  }
}

.tableCaption {
  margin-top: 1rem; 
  font-size: 0.875rem; 
  color: $muted-foreground;
}
</file>

<file path="src/ui/table/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className={styles.tableWrapper}>
      <table ref={ref} className={cn(styles.table, className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <thead ref={ref} className={cn(styles.tableHeader, className)} {...props} />
  ),
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn(styles.tableBody, className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn(styles.tableFooter, className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr ref={ref} className={cn(styles.tableRow, className)} {...props} />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th ref={ref} className={cn(styles.tableHead, className)} {...props} />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn(styles.tableCell, className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn(styles.tableCaption, className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };
</file>

<file path="src/ui/tooltip/index.module.scss">
@use "../../styles/vars" as *;


.tooltipContent {
  z-index: 50;
  overflow: hidden;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $popover;
  padding: 0.375rem 0.75rem;
  font-size: 0.875rem;
  color: $popover-foreground;
  box-shadow: $shadow-medium;
  
  &[data-state="open"] {
    animation: fade-in 0.2s ease;
  }
  &[data-state="closed"] {
    animation: fade-out 0.2s ease;
  }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}
</file>

<file path="src/ui/tooltip/index.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import cn from "classnames"
import styles from "./index.module.scss";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(styles.tooltipContent, className)}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="src/utils/api.ts">
import axios from "axios";
import { getCookie, setCookie, eraseCookie } from "./cookies";


export interface RegisterData {
  email: string;
  phone_number: string;
  first_name: string;
  last_name: string;
  password: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}

export interface UserResponse {
  id: string;
  email: string;
  phone_number: string;
  first_name: string;
  last_name: string;
  is_active: boolean;
}


const API_URL = import.meta.env.VITE_API_URL || "https://potential-halibut-6x6jgqgvgpxh5q6x-8000.app.github.dev";

const api = axios.create({
  baseURL: API_URL,
});

// Логирование запросов
api.interceptors.request.use((config) => {
  const token = getCookie("access_token");
  if (token && !config.headers.Authorization) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  // Логируем запросы (только в development)
  if (import.meta.env.DEV) {
    console.log(`[API Request] ${config.method?.toUpperCase()} ${config.url}`, {
      params: config.params,
      data: config.data,
    });
  }
  
  return config;
});

// Логирование ответов
api.interceptors.response.use(
  (response) => {
    // Логируем успешные ответы (только в development)
    if (import.meta.env.DEV) {
      console.log(`[API Response] ${response.config.method?.toUpperCase()} ${response.config.url}`, {
        status: response.status,
        data: response.data,
      });
    }
    return response;
  },
  (error) => {
    // Логируем ошибки
    if (error.response) {
      console.error(`[API Error] ${error.config?.method?.toUpperCase()} ${error.config?.url}`, {
        status: error.response.status,
        data: error.response.data,
        headers: error.response.headers,
      });
    } else if (error.request) {
      console.error(`[API Error] No response received`, error.request);
    } else {
      console.error(`[API Error]`, error.message);
    }
    return Promise.reject(error);
  }
);

// для автоматического обновления токена (объединено с логированием выше)
api.interceptors.response.use(
  (response: any) => response,
  async (error: { config: any; response: { status: number; }; }) => {
    const originalRequest = error.config;
    
    // Логируем ошибки (уже делается выше, но добавляем для refresh token)
    if (error.response?.status === 401 && !originalRequest._retry) {
      console.log("[API] Token expired, attempting refresh...");
      originalRequest._retry = true;
      const refreshToken = getCookie("refresh_token");

      if (refreshToken) {
        try {
          const { data } = await axios.post<TokenResponse>(
            `${API_URL}/auth/refresh`,
            { refresh_token: refreshToken }
          );
          setCookie("access_token", data.access_token, 15 / (24 * 60)); // 15 минут
          setCookie("refresh_token", data.refresh_token, 7); // 7 дней
          axios.defaults.headers.common["Authorization"] = `Bearer ${data.access_token}`;
          originalRequest.headers.Authorization = `Bearer ${data.access_token}`;
          console.log("[API] Token refreshed successfully");
          return api(originalRequest);
        } catch (refreshError) {
          console.error("[API] Refresh token failed", refreshError);
          // Очищаем токены при неудачном обновлении
          eraseCookie("access_token");
          eraseCookie("refresh_token");
          delete axios.defaults.headers.common["Authorization"];
          // Не делаем редирект автоматически - пусть компоненты решают сами
          return Promise.reject(refreshError);
        }
      } else {
        // Нет refresh токена - очищаем access токен
        eraseCookie("access_token");
        delete axios.defaults.headers.common["Authorization"];
      }
    }
    return Promise.reject(error);
  }
);



export const register = (data: RegisterData) => {
  console.log("api: send register request: ", data)
  return api.post<UserResponse>("/auth/register", data);
};


export const verifySms = (phone_number: string, code: string) => {
  return api.post("/auth/verify-sms", { phone_number, code });
};

export const login = (email: string, password: string) => {
  return api.post<TokenResponse>("/auth/login", { email, password });
};

export const getMe = () => {
  return api.get<UserResponse>("/users/me");
};

export const startBankOAuth = () => {
  // Просто перенаправляем пользователя на эндпоинт нашего бэкенда
  window.location.href = `${API_URL}/auth/oauth/authorize`;
};

export const logout = () => {
  // Очистка токенов происходит на клиенте
  eraseCookie("access_token");
  eraseCookie("refresh_token");
  delete axios.defaults.headers.common["Authorization"];
  // Можно добавить вызов API для инвалидации токена на сервере, если нужно
};


export interface BankAccount {
  account_id?: string;
  id?: string;
  accountId?: string;
  account_type?: string;
  currency?: string;
  nickname?: string;
  account?: {
    schemeName?: string;
    identification?: string;
    name?: string;
    secondaryIdentification?: string;
    account_id?: string;
  };
  balances?: Array<{
    balanceAmount: {
      amount: string;
      currency: string;
    };
    balanceType: string;
    creditDebitIndicator: string;
  }>;
}

// Вспомогательная функция для получения account_id из разных форматов
export const getAccountId = (account: BankAccount): string | null => {
  return account.account_id || 
         account.id || 
         account.accountId || 
         account.account?.identification || 
         account.account?.account_id || 
         null;
}

export interface BankAccountsResponse {
  success: boolean;
  banks: {
    [bankCode: string]: {
      success: boolean;
      accounts: BankAccount[];
      consent_id?: string;
      count: number;
      error?: string;
    };
  };
  total_accounts: number;
}

export interface BankTransaction {
  transaction_id?: string;
  transactionId?: string;
  transactionReference?: string;
  account_id: string;
  amount?: number;
  currency?: string;
  transaction_type?: string;
  creditDebitIndicator?: string;
  status?: string;
  booking_date?: string;
  bookingDateTime?: string;
  value_date?: string;
  valueDateTime?: string;
  remittance_information?: string;
  transactionInformation?: string;
  remittanceInformation?: {
    unstructured?: string;
  } | string;
  creditor_name?: string;
  creditorName?: string;
  creditor_account?: string;
  creditorAccount?: {
    identification?: string;
  };
  debtor_name?: string;
  debtorName?: string;
  debtor_account?: string;
  debtorAccount?: {
    identification?: string;
  };
}

export interface BankTransactionsResponse {
  success: boolean;
  account_id: string;
  transactions: BankTransaction[];
  total_count: number;
}

export interface BankBalance {
  accountId?: string;
  amount?: {
    amount: string;
    currency: string;
  } | string;
  balanceAmount?: {
    amount: string;
    currency: string;
  };
  type?: string;
  balanceType?: string;
  creditDebitIndicator?: string;
  dateTime?: string;
}

export interface BankBalancesResponse {
  success: boolean;
  balances: BankBalance[] | {
    data?: {
      balance?: BankBalance[];
    };
    Data?: {
      Balance?: BankBalance[];
    };
    balance?: BankBalance[];
  };
}

// Получить все счета из всех банков
export const getAllBankAccounts = () => {
  return api.get<BankAccountsResponse>("/api/v1/banks/accounts/all");
};

// Получить счета из конкретного банка
export const getBankAccounts = (bankCode: string) => {
  return api.get<{ success: boolean; accounts: BankAccount[]; consent_id?: string; auto_approved?: boolean }>(
    `/api/v1/banks/accounts?bank_code=${bankCode}`
  );
};

// Получить балансы счета
export const getAccountBalances = (
  accountId: string,
  bankCode: string,
  consentId?: string
) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  
  // Используем согласие из куки, если не указано явно
  const effectiveConsentId = getCookie(`consent_${bankCode}`);
  if (effectiveConsentId) {
    params.append("consent_id", effectiveConsentId);
  }
  
  return api.get<BankBalancesResponse>(
    `/api/v1/banks/accounts/${accountId}/balances?${params.toString()}`
  );
};

// Утилита для извлечения баланса из ответа API
export const extractBalanceFromResponse = (response: { data: BankBalancesResponse }): number => {
  let balances = response.data.balances;
  
  // Поддерживаем разные форматы ответа
  if (balances && !Array.isArray(balances)) {
    // Формат: { data: { balance: [...] } }
    if ((balances as any).data?.balance) {
      balances = (balances as any).data.balance;
    }
    // Формат: { Data: { Balance: [...] } }
    else if ((balances as any).Data?.Balance) {
      balances = (balances as any).Data.Balance;
    }
    // Формат: массив напрямую
    else if (Array.isArray((balances as any).balance)) {
      balances = (balances as any).balance;
    }
  }
  
  if (Array.isArray(balances) && balances.length > 0) {
    // Ищем баланс типа "InterimAvailable" или "InterimBooked"
    // Поддерживаем оба формата: balanceType/type и balanceAmount/amount
    const balance = balances.find(
      (b: any) => 
        (b.type === "InterimAvailable" || b.balanceType === "InterimAvailable") ||
        (b.type === "InterimBooked" || b.balanceType === "InterimBooked")
    ) || balances[0];
    
    // Извлекаем сумму из разных форматов
    // Поддерживаем: amount.amount, balanceAmount.amount, amount (строка)
    let amountStr: string | undefined;
    
    if (balance?.amount) {
      if (typeof balance.amount === "object" && balance.amount.amount) {
        amountStr = balance.amount.amount;
      } else if (typeof balance.amount === "string") {
        amountStr = balance.amount;
      }
    }
    
    if (!amountStr && balance?.balanceAmount) {
      if (typeof balance.balanceAmount === "object" && balance.balanceAmount.amount) {
        amountStr = balance.balanceAmount.amount;
      } else if (typeof balance.balanceAmount === "string") {
        amountStr = balance.balanceAmount;
      }
    }
    
    if (amountStr) {
      const parsed = parseFloat(String(amountStr));
      if (!isNaN(parsed)) {
        return parsed;
      }
    }
  }
  
  return 0;
};

export const getAccountTransactions = (
  accountId: string,
  bankCode: string,
  consentId?: string,
  fromDate?: string,
  toDate?: string
) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  
  // Используем согласие из куки, если не указано явно
  const effectiveConsentId = getCookie(`consent_${bankCode}`);
  if (effectiveConsentId) {
    params.append("consent_id", effectiveConsentId);
  }
  
  if (fromDate) params.append("from_date", fromDate);
  if (toDate) params.append("to_date", toDate);
  
  return api.get<BankTransactionsResponse>(
    `/api/v1/banks/accounts/${accountId}/transactions?${params.toString()}`
  );
};



export interface BankUser {
  id: number;
  user_id: number;
  bank_code: string;
  bank_user_id: string;
  consent_id?: string;
  created_at: string;
  updated_at: string;
}

export interface BankUsersResponse {
  bank_users: Record<string, string>;
}

export interface BankUserCreate {
  bank_code: string;
  bank_user_id: string;
}

// Получить все bank_user_id пользователя
export const getUserBankUsers = () => {
  return api.get<BankUsersResponse>("/users/me/bank-users");
};

// Сохранить или обновить bank_user_id
export const saveBankUser = (bankUser: BankUserCreate) => {
  return api.post<BankUser>("/users/me/bank-users", bankUser);
};

// Удалить bank_user_id
export const deleteBankUser = (bankCode: string) => {
  return api.delete(`/users/me/bank-users/${bankCode}`);
};

// ==================== CONSENTS API ====================

export interface BankConsent {
  consent_id: string;
  bank_code: string;
  status: string;
  auto_approved: boolean;
  expires_at?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateConsentResponse {
  success: boolean;
  consent_id: string;
  status: string;
  auto_approved: boolean;
  permissions: string[];
  expires_at: string;
  message: string;
}

export interface ConsentsResponse {
  success: boolean;
  consents: BankConsent[];
}

// Создать согласие для банка
export const createAccountConsent = (bankCode: string, permissions?: string[]) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  if (permissions && permissions.length > 0) {
    permissions.forEach(perm => params.append("permissions", perm));
  }
  
  return api.post<CreateConsentResponse>(
    `/api/v1/banks/account-consents?${params.toString()}`
  );
};

// Получить список согласий пользователя
export const getUserConsents = () => {
  return api.get<ConsentsResponse>("/api/v1/banks/consents");
};

// ==================== ANALYTICS API ====================

export interface HealthMetrics {
  success: boolean;
  metrics?: {
    total_revenue: number;
    total_expenses: number;
    net_income: number;
    total_assets: number;
    total_liabilities: number;
    net_worth: number;
    current_ratio?: number;
    quick_ratio?: number;
    total_ar: number;
    overdue_ar: number;
    ar_turnover_days?: number;
    operating_cash_flow: number;
    cash_flow_trend?: string;
    health_score?: number;
    health_status?: string;
  };
  error?: string;
}

export interface DashboardSummary {
  success: boolean;
  summary?: {
    total_balance: number;
    total_revenue: number;
    total_expenses: number;
    net_income: number;
    total_ar: number;
    overdue_ar: number;
    accounts_count: number;
  };
  error?: string;
}

export const getHealthMetrics = (periodStart?: string, periodEnd?: string) => {
  const params = new URLSearchParams();
  if (periodStart) params.append("period_start", periodStart);
  if (periodEnd) params.append("period_end", periodEnd);
  return api.get<HealthMetrics>(`/api/v1/analytics/health-metrics?${params.toString()}`);
};

export const getDashboardSummary = () => {
  return api.get<DashboardSummary>("/api/v1/analytics/dashboard");
};

// ==================== PREDICTIONS API ====================

export interface CashFlowPrediction {
  success: boolean;
  predictions?: Array<{
    prediction_date: string;
    predicted_inflow: number;
    predicted_outflow: number;
    predicted_balance: number;
    gap_probability?: number;
    gap_amount?: number;
    confidence_score?: number;
  }>;
  error?: string;
}

export interface CashFlowGap {
  success: boolean;
  gaps?: Array<{
    date: string;
    gap_amount: number;
    probability: number;
    severity: string;
  }>;
  error?: string;
}

export const getCashFlowPredictions = (weeksAhead: number = 4, predictionDate?: string) => {
  const params = new URLSearchParams({ weeks_ahead: weeksAhead.toString() });
  if (predictionDate) params.append("prediction_date", predictionDate);
  return api.get<CashFlowPrediction>(`/api/v1/predictions/cash-flow?${params.toString()}`);
};

export const getCashFlowGaps = (weeksAhead: number = 4) => {
  return api.get<CashFlowGap>(`/api/v1/predictions/cash-flow-gaps?weeks_ahead=${weeksAhead}`);
};

// ==================== ACCOUNTS RECEIVABLE API ====================

export interface Invoice {
  id: number;
  counterparty_id: number;
  counterparty_name: string;
  invoice_number: string;
  invoice_date: string;
  due_date: string;
  amount: number;
  paid_amount: number;
  currency: string;
  status: string;
  description?: string;
  days_overdue?: number;
}

export interface InvoicesResponse {
  success: boolean;
  invoices?: Invoice[];
  error?: string;
}

export interface ARSummary {
  success: boolean;
  summary?: {
    total_ar: number;
    overdue_ar: number;
    pending_count: number;
    overdue_count: number;
    paid_count: number;
  };
  error?: string;
}

export const getInvoices = (status?: string, counterpartyId?: number) => {
  const params = new URLSearchParams();
  if (status) params.append("status", status);
  if (counterpartyId) params.append("counterparty_id", counterpartyId.toString());
  return api.get<InvoicesResponse>(`/api/v1/ar/invoices?${params.toString()}`);
};

export const getOverdueInvoices = () => {
  return api.get<InvoicesResponse>("/api/v1/ar/overdue");
};

export const getARSummary = () => {
  return api.get<ARSummary>("/api/v1/ar/summary");
};

// ==================== OAUTH API ====================

export const initiateBankOAuth = (bankCode: string) => {
  // This will redirect to backend, which redirects to bank
  window.location.href = `${API_URL}/auth/oauth/authorize/${bankCode}`;
};
</file>

<file path="src/utils/cookies.ts">
import Cookies from 'js-cookie';


export function setCookie(name: string, value: string, days: number) {

  Cookies.set(name, value, { expires: days, path: '/' });
}

export function getCookie(name: string): string | null {
  return Cookies.get(name) || null;
}

export function eraseCookie(name: string) {
  Cookies.remove(name, { path: '/' });
}
</file>

<file path="src/utils/zod.ts">
import { z } from 'zod';

const passwordSchema = z.string()
    .min(8, 'Пароль должен содержать минимум 8 символов')
    .max(100, 'Пароль не должен превышать 100 символов')
    .regex(/[A-Z]/, 'Пароль должен содержать хотя бы одну заглавную букву')
    .regex(/[a-z]/, 'Пароль должен содержать хотя бы одну строчную букву')
    .regex(/[0-9]/, 'Пароль должен содержать хотя бы одну цифру')
    .default("");


export const zUserSignIn = z.object({
    email: z.email()
        .min(5, 'Email должен содержать минимум 5 символов')
        .max(100, 'Email не должен превышать 100 символов')
        .default(""),

    password: passwordSchema
})


export const zUserSignUp = zUserSignIn.extend({
    firstName: z.string()
        .min(2, 'Имя должно содержать минимум 2 символа')
        .max(50, 'Имя не должно превышать 50 символов')
        .regex(/^[a-zA-Zа-яА-ЯёЁ\s\-]+$/, 'Имя может содержать только буквы, пробелы и дефисы')
        .default(""),

    lastName: z.string()
        .min(2, 'Фамилия должна содержать минимум 2 символа')
        .max(50, 'Фамилия не должна превышать 50 символов')
        .regex(/^[a-zA-Zа-яА-ЯёЁ\s\-]+$/, 'Фамилия может содержать только буквы, пробелы и дефисы')
        .default(""),

    phone: z.string()
        .min(10, 'Телефон должен содержать минимум 10 цифр')
        .max(15, 'Телефон не должен превышать 15 символов')
        .regex(/^\+?[0-9\s\-\(\)]+$/, 'Введите корректный номер телефона')
        .default(""),

});

export type RegisterFormData = z.infer<typeof zUserSignUp>;
export type SignInFormData = z.infer<typeof zUserSignIn>;
</file>

<file path="src/App.tsx">
import { TooltipProvider } from "./ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Toaster } from "./ui/sonner";
import Home from "./pages/home";
import Profile from "./pages/Profile";
import CashFlow from "./pages/CashFlow";
import Health from "./pages/Health";
import Receivables from "./pages/Receivables";
import Payments from "./pages/Payments";
import Settings from "./pages/Settings";
import OAuthSuccess from "./pages/Auth/OAuthSuccess";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Toaster 
        position="top-center"
        richColors
        closeButton={false}
        duration={1500}
        toastOptions={{
          style: {
            minWidth: '400px',
            fontSize: '16px',
            padding: '16px 20px',
          },
          className: 'custom-toast',
        }}
      />
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="/cash-flow" element={<CashFlow />} />
          <Route path="/health" element={<Health />} />
          <Route path="/receivables" element={<Receivables />} />
          <Route path="/payments" element={<Payments />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/auth/success" element={<OAuthSuccess />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import "./styles/main.scss";
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path=".dockerignore">
node_modules
dist
.git
.gitignore
.env
.env.local
.DS_Store
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.vscode
.idea
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Windows Zone Identifier files
*.Zone.Identifier

# Codebase dumps
backend.xml
frontend.txt
</file>

<file path="Dockerfile">
# Multi-stage build for frontend
FROM node:20-alpine as builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build the app
RUN npm run build

# Production stage with nginx
FROM nginx:alpine

# Copy built files from builder
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="Dockerfile.dev">
# Development Dockerfile for frontend
FROM node:20-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy source code
COPY . .

# Expose Vite dev server port
EXPOSE 5173

# Start development server
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    rules: {
      '@typescript-eslint/no-unused-vars': 'warn',
      'no-useless-escape': "off",
      'react-refresh/only-export-components': 'off'
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend-2</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="nginx.conf">
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript;

    # SPA routing - all routes go to index.html
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API proxy to backend
    location /api/ {
        proxy_pass http://app:8000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Auth endpoints (direct proxy)
    location /auth/ {
        proxy_pass http://app:8000/auth/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Users endpoints (direct proxy)
    location /users/ {
        proxy_pass http://app:8000/users/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
</file>

<file path="openapi.json">
{"openapi":"3.1.0","info":{"title":"Virtual Bank API","version":"2.1"},"paths":{"/auth/bank-token":{"post":{"tags":["0 Аутентификация вызывающей системы","0 Аутентификация вызывающей системы"],"summary":"Create Bank Token","description":"## 🎯 Получение токена для работы с API банка\n\n**Этот endpoint - точка входа для всех участников хакатона!**\n\nТокен выдается банком, У КОТОРОГО вы запрашиваете данные.\nКаждый банк подписывает токен своим приватным ключом (RS256).\n\n### Где взять credentials?\n\nПолучите у организаторов хакатона:\n- `client_id` — код вашей команды (например: team200)\n- `client_secret` — ваш секретный ключ (API key)\n\n### Пример запроса:\n\n```bash\n# Получить токен для запросов к VBank\nPOST https://vbank.open.bankingapi.ru/auth/bank-token\n?client_id=team200\n&client_secret=5OAaa4DYzYKfnOU6zbR34ic5qMm7VSMB\n\n# Ответ:\n{\n  \"access_token\": \"eyJ...\",\n  \"token_type\": \"bearer\",\n  \"client_id\": \"team200\",\n  \"expires_in\": 86400\n}\n```\n\n### Использование токена:\n\n```bash\nGET https://vbank.open.bankingapi.ru/accounts\nHeaders:\n  Authorization: Bearer eyJ...\n```\n\n### Важно:\n\n- Токен валиден 24 часа\n- Для каждого банка нужен свой токен (VBank, ABank, SBank)\n- Токен подписан приватным ключом банка (RS256)\n- Публичный ключ: `/.well-known/jwks.json`\n\n### Межбанковые запросы:\n\nДля получения данных клиента из другого банка добавьте:\n```\nX-Requesting-Bank: your_client_id\n```\nИ создайте согласие: `POST /account-consents`","operationId":"create_bank_token_auth_bank_token_post","parameters":[{"name":"client_id","in":"query","required":true,"schema":{"type":"string","description":"ID команды от организаторов","title":"Client Id"},"description":"ID команды от организаторов","example":"team200"},{"name":"client_secret","in":"query","required":true,"schema":{"type":"string","description":"Secret команды от организаторов","title":"Client Secret"},"description":"Secret команды от организаторов","example":"5OAaa4DYzYKfnOU6zbR34ic5qMm7VSMB"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts":{"get":{"tags":["2 Счета и балансы"],"summary":"1. Получить список счетов","description":"## 💳 Получение списка счетов клиента\n\n### Два режима работы:\n\n#### 1️⃣ Запрос своих счетов (в том же банке)\n```bash\nGET /accounts\nHeaders:\n  Authorization: Bearer <client_token>\n```\n\n#### 2️⃣ Межбанковый запрос (с согласием)\n```bash\nGET /accounts?client_id=cli-ab-001\nHeaders:\n  Authorization: Bearer <bank_token>\n  X-Requesting-Bank: team200\n  X-Consent-Id: <consent_id>\n```\n\n### Ответ содержит:\n- `account_id` — уникальный идентификатор счета\n- `currency` — валюта (RUB, USD, EUR)\n- `account_type` — тип счета (Personal, Business)\n- `nickname` — название счета\n- `servicer` — информация о банке\n\n### ⚠️ Важно для межбанковых запросов:\n1. Сначала создайте согласие: `POST /account-consents/request`\n2. Клиент должен одобрить согласие в банке-владельце счетов\n3. Используйте полученный `consent_id` в заголовке `X-Consent-Id`\n4. Укажите свой банк в `X-Requesting-Bank`\n\n### Примечание:\n- Без согласия межбанковый запрос вернет 403 с подсказкой, как получить согласие\n- Согласие имеет срок действия (обычно 90 дней)","operationId":"get_accounts_accounts_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (например team200-1). Обязателен для межбанковых запросов","title":"Client Id"},"description":"ID клиента (например team200-1). Обязателен для межбанковых запросов","example":"team200-1"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["2 Счета и балансы"],"summary":"5. Создать счет","description":"Создание нового счета\n\nПоддерживаемые типы: checking, savings\n\n### 🔑 Аутентификация:\n- **client_token**: Клиент создает счет САМОСТОЯТЕЛЬНО - согласие НЕ требуется\n- **bank_token**: Другой банк создает счет ОТ ИМЕНИ клиента - ТРЕБУЕТСЯ согласие!\n\n### 🔐 Требования для межбанкового создания счета:\nПри использовании `bank_token` обязательно:\n1. **Query parameter:** `client_id` - ID клиента\n2. **Header:** `X-Requesting-Bank` - ваш bank_code\n3. **Header:** `X-Consent-Id` - ID активного согласия\n4. **Согласие должно иметь permission:** `ManageAccounts`\n\n### Получение согласия:\n```bash\nPOST /account-consents\n{\n  \"data\": {\n    \"permissions\": [\"ManageAccounts\"],\n    \"expirationDateTime\": \"2025-12-31T23:59:59Z\"\n  }\n}\n```\n\nКлиент должен одобрить согласие в своем банке.","operationId":"create_account_accounts_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID запрашивающего банка","title":"X-Requesting-Bank"},"description":"ID запрашивающего банка"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия","title":"X-Consent-Id"},"description":"ID согласия"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateAccountRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}":{"get":{"tags":["2 Счета и балансы"],"summary":"2. Получить детали счета","description":"Получение детальной информации о счете\n\n**Требует:** Client token (для своих счетов) или Bank token с согласием (межбанк)","operationId":"get_account_accounts__account_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/balances":{"get":{"tags":["2 Счета и балансы"],"summary":"3. Получить баланс счета","description":"Получение баланса счета\n\n**Требует:** Client token (для своих счетов) или Bank token с согласием (межбанк)","operationId":"get_balances_accounts__account_id__balances_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/transactions":{"get":{"tags":["2 Счета и балансы"],"summary":"4. Получить историю транзакций","description":"Получение списка транзакций по счету\n\n**Пагинация:**\n- `page` — номер страницы (по умолчанию: 1)\n- `limit` — количество транзакций на странице (по умолчанию: 50, макс: 500)\n\n**Примеры:**\n- `GET /accounts/acc-1/transactions` — первые 50 транзакций\n- `GET /accounts/acc-1/transactions?page=2&limit=100` — следующие 100 транзакций\n- `GET /accounts/acc-1/transactions?limit=200` — первые 200 транзакций","operationId":"get_transactions_accounts__account_id__transactions_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"from_booking_date_time","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"From Booking Date Time"},"example":"2025-01-01T00:00:00Z"},{"name":"to_booking_date_time","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"To Booking Date Time"},"example":"2025-12-31T23:59:59Z"},{"name":"page","in":"query","required":false,"schema":{"type":"integer","default":1,"title":"Page"},"example":1},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"default":50,"title":"Limit"},"example":50},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/status":{"put":{"tags":["2 Счета и балансы"],"summary":"6. Изменить статус счета","description":"Изменение статуса счета (закрытие)\n\nДопустимые статусы: active, closed\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"update_account_status_accounts__account_id__status_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","title":"Account Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AccountStatusUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/close":{"put":{"tags":["2 Счета и балансы"],"summary":"7. Закрыть счет с остатком","description":"Закрытие счета с переводом остатка или дарением банку\n\nActions:\n- transfer: перевести остаток на другой счет\n- donate: подарить остаток банку (увеличить capital)\n\n### 🔑 Аутентификация:\n- **client_token**: Клиент закрывает счет САМОСТОЯТЕЛЬНО - согласие НЕ требуется\n- **bank_token**: Другой банк закрывает счет ОТ ИМЕНИ клиента - ТРЕБУЕТСЯ согласие!\n\n### 🔐 Требования для межбанкового закрытия счета:\nПри использовании `bank_token` обязательно:\n1. **Query parameter:** `client_id` - ID клиента\n2. **Header:** `X-Requesting-Bank` - ваш bank_code\n3. **Header:** `X-Consent-Id` - ID активного согласия\n4. **Согласие должно иметь permission:** `ManageAccounts`","operationId":"close_account_with_balance_accounts__account_id__close_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","title":"Account Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID запрашивающего банка","title":"X-Requesting-Bank"},"description":"ID запрашивающего банка"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия","title":"X-Consent-Id"},"description":"ID согласия"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AccountCloseRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards":{"get":{"tags":["8 Карты"],"summary":"1. Получить список карт","description":"Получить список всех карт клиента\n\n**Возвращает:**\n- Список карт с маскированными номерами\n- Информацию о привязанных счетах\n- Лимиты и статусы\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ReadCards`\n- Заголовки: `X-Requesting-Bank`, `X-Consent-Id`","operationId":"get_cards_cards_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["8 Карты"],"summary":"3. Выпустить новую карту","description":"Выпустить новую карту и привязать к счету\n\n**Требования:**\n- Счет должен быть типа checking или savings\n- Счет должен принадлежать клиенту\n- К одному счету можно привязать несколько карт\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"create_card_cards_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateCardRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}":{"get":{"tags":["8 Карты"],"summary":"2. Получить детали карты","description":"Получить детальную информацию о карте\n\n**Параметры:**\n- `show_full_number=true` - показать полный номер (только для владельца)\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ReadCards`\n- Полный номер карты доступен только владельцу (локальный запрос)","operationId":"get_card_details_cards__card_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"show_full_number","in":"query","required":false,"schema":{"type":"boolean","description":"Показать полный номер карты","default":false,"title":"Show Full Number"},"description":"Показать полный номер карты"},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["8 Карты"],"summary":"6. Удалить карту","description":"Удалить карту (перевыпуск или закрытие)\n\n**Важно:** Счет остается активным, удаляется только карта\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"delete_card_cards__card_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}/status":{"put":{"tags":["8 Карты"],"summary":"4. Изменить статус карты","description":"Изменить статус карты (блокировка/разблокировка)\n\n**Статусы:**\n- `active` - активна\n- `blocked` - заблокирована\n- `expired` - истек срок действия\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"update_card_status_cards__card_id__status_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateCardStatusRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}/limits":{"put":{"tags":["8 Карты"],"summary":"5. Обновить лимиты карты","description":"Обновить дневной и месячный лимиты карты\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"update_card_limits_cards__card_id__limits_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CardLimitsRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/account-consents/request":{"post":{"tags":["1 Согласия на доступ к счетам"],"summary":"1. Создать согласие","description":"Создание согласия на доступ к счетам клиента\n\nСогласия нужны для доступа к данным клиентов из других банков.\nПосле создания согласия вы сможете запрашивать счета, балансы и транзакции.\n\n### Пример использования:\n\n```bash\n# 1. Получить токен банка, где лежат данные клиента\nPOST https://vbank.open.bankingapi.ru/auth/bank-token\n?client_id=team200&client_secret=YOUR_SECRET\n→ {\"access_token\": \"eyJhbG...\"}\n\n# 2. Запросить согласие (авто-одобрение)\nPOST https://vbank.open.bankingapi.ru/account-consents/request\nHeaders:\n  Authorization: Bearer eyJhbG...\n  X-Requesting-Bank: team200\nBody:\n{\n  \"client_id\": \"team200-1\",\n  \"permissions\": [\"ReadAccountsDetail\", \"ReadBalances\"],\n  \"reason\": \"Агрегация счетов для HackAPI\",\n  \"requesting_bank\": \"team200\",\n  \"requesting_bank_name\": \"Team 200 App\"\n}\n\n→ {\"status\": \"approved\", \"consent_id\": \"consent-abc123\", \"auto_approved\": true}\n\n# 3. Запросить данные\nGET https://vbank.open.bankingapi.ru/accounts?client_id=team200-1\nHeaders:\n  Authorization: Bearer eyJhbG...\n  X-Requesting-Bank: team200\n  X-Consent-Id: consent-abc123\n\n→ 200 OK {\"accounts\": [...]}\n```\n\n### ⚠️ Частые ошибки:\n\n1. **X-Requesting-Bank: team200-1** ❌ НЕПРАВИЛЬНО!  \n   Должно быть **team200** (ID команды, без суффикса клиента)\n\n2. **Забыли X-Consent-Id** → получите 403 CONSENT_REQUIRED\n\n3. **Используете client_token вместо bank_token** → 401 Unauthorized\n\n### Что происходит внутри:\n1. Создаётся запрос согласия для клиента\n2. Если банк настроен на авто-одобрение (VBank, ABank):\n   - Согласие одобряется автоматически\n   - Можно сразу запрашивать данные\n3. Если банк требует ручное одобрение (SBank):\n   - Клиент увидит запрос в своём UI\n   - Должен подтвердить через кнопку \"Подписать\"\n   - После этого ваше приложение может запрашивать данные","operationId":"request_consent_account_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для создания согласия","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для создания согласия","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConsentRequestBody"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/account-consents/{consent_id}":{"get":{"tags":["1 Согласия на доступ к счетам"],"summary":"2. Получить согласие по ID","description":"Получение ресурса согласия\n\nВозвращает информацию о согласии и его текущий статус.","operationId":"get_account_access_consents_consent_id_account_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","description":"ID согласия","title":"Consent Id"},"description":"ID согласия","example":"consent-d8f0724a4775"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Fapi-Interaction-Id"},"example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConsentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["1 Согласия на доступ к счетам"],"summary":"3. Отозвать согласие","description":"Удаление ресурса согласия (отзыв)\n\nИзменяет статус согласия на \"Revoked\" (отозвано).","operationId":"delete_account_access_consents_consent_id_account_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","description":"ID согласия для отзыва","title":"Consent Id"},"description":"ID согласия для отзыва","example":"consent-d8f0724a4775"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Fapi-Interaction-Id"},"example":"team200"}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payment-consents/request":{"post":{"tags":["3 Согласия на переводы"],"summary":"1. Создать запрос согласия на перевод","description":"## 💳 Создание запроса на согласие для платежа\n\n**OpenBanking Russia Payment Consents API**\n\n### Поддерживаемые типы:\n\n#### 1. Single Use (одноразовый)\n\n**С указанием получателя (платеж только на этот счет):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"single_use\",\n  \"amount\": 5000.00,\n  \"debtor_account\": \"40817810...\",\n  \"creditor_account\": \"40817820...\",\n  \"creditor_name\": \"Иван Иванов\",\n  \"reference\": \"Оплата услуг\"\n}\n```\n\n**БЕЗ указания получателя (платеж любому, но только один раз):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"single_use\",\n  \"amount\": 5000.00,\n  \"debtor_account\": \"40817810...\",\n  \"reference\": \"Оплата услуг\"\n}\n```\n\n#### 2. Multi Use (многоразовый)\n\n**С ограничением по получателям:**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"multi_use\",\n  \"debtor_account\": \"40817810...\",\n  \"max_uses\": 10,\n  \"max_amount_per_payment\": 5000.00,\n  \"max_total_amount\": 50000.00,\n  \"allowed_creditor_accounts\": [\"40817820...\", \"40817830...\"],\n  \"valid_until\": \"2025-12-31T23:59:59\"\n}\n```\n\n**БЕЗ ограничения по получателям (любые счета в рамках лимитов):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"multi_use\",\n  \"debtor_account\": \"40817810...\",\n  \"max_uses\": 10,\n  \"max_amount_per_payment\": 5000.00,\n  \"max_total_amount\": 50000.00,\n  \"valid_until\": \"2025-12-31T23:59:59\"\n}\n```\n\n#### 3. VRP (переменные платежи)\n\n**Без ограничений по получателям (типичный случай для подписок):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"vrp\",\n  \"debtor_account\": \"40817810...\",\n  \"vrp_max_individual_amount\": 1000.00,\n  \"vrp_daily_limit\": 3000.00,\n  \"vrp_monthly_limit\": 50000.00,\n  \"valid_until\": \"2026-01-01T00:00:00\"\n}\n```","operationId":"create_payment_consent_request_payment_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для создания согласия на переводы","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для создания согласия на переводы","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentConsentRequestData"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Create Payment Consent Request Payment Consents Request Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payment-consents/{consent_id}":{"get":{"tags":["3 Согласия на переводы"],"summary":"2. Получить согласие по ID","description":"## 📋 Получение согласия на платеж\n\nВозвращает детали согласия со всеми лимитами и использованием","operationId":"get_payment_consent_payment_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Get Payment Consent Payment Consents  Consent Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["3 Согласия на переводы"],"summary":"3. Отозвать согласие","description":"## 🗑️ Отзыв согласия на платеж","operationId":"revoke_payment_consent_payment_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payments":{"post":{"tags":["4 Переводы"],"summary":"1. Создать платеж","description":"## 💸 Создание платежа (разовый перевод)\n\n### 🔑 Аутентификация:\n- **С bank_token**: Укажите параметр `client_id` (например: team200-1)\n- **С client_token**: Параметр `client_id` не нужен\n\n### Два типа платежей:\n\n#### 1️⃣ Внутрибанковский перевод (тот же банк)\n```json\n{\n  \"data\": {\n    \"initiation\": {\n      \"instructedAmount\": {\n        \"amount\": \"1000.00\",\n        \"currency\": \"RUB\"\n      },\n      \"debtorAccount\": {\n        \"schemeName\": \"RU.CBR.PAN\",\n        \"identification\": \"40817810099910004312\"\n      },\n      \"creditorAccount\": {\n        \"schemeName\": \"RU.CBR.PAN\",\n        \"identification\": \"40817810099910005423\"\n      },\n      \"comment\": \"Оплата за услуги\"\n    }\n  }\n}\n```\n\n💡 **Поле `comment`** - необязательное, но рекомендуется для удобства учета\n\n#### 2️⃣ Межбанковский перевод\nДобавьте в `creditorAccount`:\n```json\n{\n  \"creditorAccount\": {\n    \"identification\": \"40817810099910001234\",\n    \"bank_code\": \"abank\"  // Код банка получателя\n  }\n}\n```\n\n### Статусы платежа:\n- `pending` — ожидает обработки\n- `completed` — успешно выполнен\n- `failed` — ошибка (недостаточно средств, счет не найден)\n\n### Проверка статуса:\n```bash\nGET /payments/{payment_id}\n```\n\n### ⚠️ Важно:\n- **bank_token**: укажите `client_id` в параметрах запроса (обязательно)\n- Проверяйте баланс счета перед платежом: `GET /accounts/{account_id}/balances`\n- Счет списания (`debtorAccount`) должен принадлежать авторизованному клиенту\n- Для межбанковых переводов используйте правильный `bank_code`\n- Коды банков: `vbank`, `abank`, `sbank`\n\n### Sandbox особенности:\n- Межбанковые переводы выполняются мгновенно\n- Комиссия не взимается\n- Все валюты конвертируются по курсу 1:1 для упрощения","operationId":"create_payment_payments_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей транзакции для отслеживания","title":"X-Fapi-Interaction-Id"},"description":"(Опционально) ID вашей транзакции для отслеживания","example":"team200-pay-001"},{"name":"x-fapi-customer-ip-address","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) IP адрес клиента","title":"X-Fapi-Customer-Ip-Address"},"description":"(Опционально) IP адрес клиента","example":"192.168.1.100"},{"name":"x-payment-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID согласия на перевод","title":"X-Payment-Consent-Id"},"description":"(Опционально) ID согласия на перевод","example":"pcon-49ecbbe683b4"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей команды для межбанковых переводов","title":"X-Requesting-Bank"},"description":"(Опционально) ID вашей команды для межбанковых переводов","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentRequest"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payments/{payment_id}":{"get":{"tags":["4 Переводы"],"summary":"2. Получить статус платежа","description":"Получение статуса платежа\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"get_payment_payments__payment_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"payment_id","in":"path","required":true,"schema":{"type":"string","title":"Payment Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей транзакции для отслеживания","title":"X-Fapi-Interaction-Id"},"description":"(Опционально) ID вашей транзакции для отслеживания","example":"team200-pay-001"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/products":{"get":{"tags":["5 Каталог продуктов"],"summary":"1. Получить каталог продуктов","description":"## 🧩 Каталог банковских продуктов\n\n### Получение списка всех доступных продуктов банка\n\n#### Типы продуктов:\n- `deposit` — вклады/депозиты\n- `loan` — кредиты (потребительские, ипотека, авто)\n- `card` — банковские карты (дебетовые, кредитные)\n- `account` — расчетные счета\n\n#### Фильтрация:\n```bash\nGET /products?product_type=deposit\n```\n\n### Ответ содержит:\n- `productId` — уникальный ID продукта\n- `productType` — тип продукта\n- `productName` — название\n- `description` — описание\n- `interestRate` — процентная ставка (для депозитов/кредитов)\n- `minAmount` / `maxAmount` — лимиты по сумме\n- `termMonths` — срок (в месяцах)\n\n### 🚀 Продуктовая воронка:\n\n1. **Каталог** → `GET /products` (этот endpoint)\n2. **Лид** → `POST /customer-leads` (оставить заявку на консультацию)\n3. **Предложение** → `GET /product-offers` (получить персональное предложение)\n4. **Заявка** → `POST /product-application` (подать заявку на продукт)\n5. **Договор** → `POST /product-agreements` (открыть продукт)\n\n### Примеры продуктов в sandbox:\n- **Вклад \"Надежный\"**: 8.5% годовых, от 10,000₽\n- **Потребительский кредит**: 12.9% годовых, до 3,000,000₽\n- **Дебетовая карта \"Свобода\"**: с кэшбэком 2%\n\n### 🔐 Аутентификация:\n- **Client token**: клиент просматривает продукты своего банка\n- **Bank token**: другой банк просматривает продукты для межбанковских операций\n\n### ⚠️ Обратите внимание:\n- Каталог требует авторизацию (client или bank token)\n- Для подачи заявки требуется авторизация клиента\n- Условия могут отличаться для разных банков","operationId":"get_products_products_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"product_type","in":"query","required":false,"schema":{"type":"string","title":"Product Type"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/products/{product_id}":{"get":{"tags":["5 Каталог продуктов"],"summary":"2. Получить детали продукта","description":"## 📋 Детальная информация о продукте\n\nПолучение подробных условий конкретного банковского продукта.\n\n### Пример запроса:\n```bash\nGET /products/prod-vb-deposit-001\n```\n\n### Когда использовать:\n- После выбора продукта из каталога\n- Перед созданием лида или заявки\n- Для отображения деталей на странице продукта\n\n### Полезно для UI:\n- Показать полные условия\n- Вычислить предварительную сумму выплат по кредиту\n- Сравнить с другими продуктами","operationId":"get_product_products__product_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"product_id","in":"path","required":true,"schema":{"type":"string","title":"Product Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreements":{"get":{"tags":["7 Договоры с продуктами"],"summary":"1. Получить список договоров","description":"Получить список договоров клиента\n\nВозвращает все активные договоры с продуктами (депозиты, кредиты, карты)\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `read_product_agreements`","operationId":"get_agreements_product_agreements_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["7 Договоры с продуктами"],"summary":"2. Открыть продукт","description":"Открыть договор с продуктом (депозит, кредит, карта)\n\n- Депозит: создается счет, деньги списываются с основного счета\n- Кредит: проверяется капитал банка, создается счет с кредитными средствами\n- Карта: создается счет с лимитом\n\n### 🎯 Скоринг для кредитов:\nМаксимальная **СУММАРНАЯ** сумма всех активных кредитов зависит от сегмента клиента:\n- **student** (студент): до 900,000₽ (30% от лимита)\n- **pensioner** (пенсионер): до 1,200,000₽ (40%)\n- **employee** (сотрудник): до 1,800,000₽ (60%)\n- **entrepreneur** (ИП): до 2,400,000₽ (80%)\n- **vip**: до 3,000,000₽ (100%)\n- **business** (бизнес): до 3,000,000₽ (100%)\n\n⚠️ Проверяется сумма ВСЕХ активных кредитов клиента!\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `open_product_agreements`\n- Сумма не должна превышать `max_amount` согласия\n- Тип продукта должен быть в списке `allowed_product_types`","operationId":"create_agreement_product_agreements_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProductAgreementRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreements/{agreement_id}":{"get":{"tags":["7 Договоры с продуктами"],"summary":"3. Получить детали договора","description":"Получить детали договора\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `read_product_agreements`","operationId":"get_agreement_product_agreements__agreement_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"agreement_id","in":"path","required":true,"schema":{"type":"string","title":"Agreement Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["7 Договоры с продуктами"],"summary":"4. Закрыть договор","description":"Закрыть договор\n\n- Депозит: закрыть счет\n- Кредит: погасить задолженность из указанного счета\n- Карта: заблокировать\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `close_product_agreements`","operationId":"close_agreement_product_agreements__agreement_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"agreement_id","in":"path","required":true,"schema":{"type":"string","title":"Agreement Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"requestBody":{"content":{"application/json":{"schema":{"anyOf":[{"$ref":"#/components/schemas/CloseAgreementRequest"},{"type":"null"}],"title":"Request"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreement-consents/request":{"post":{"tags":["6 Согласия на управление договорами"],"summary":"1. Создать запрос согласия на управление договорами","description":"## 📋 Создание запроса на согласие для управления договорами\n\n**OpenBanking Russia Products API Extension**\n\n### 🔑 Аутентификация:\n- **bank_token** (type=\"team\"): укажите `client_id` в query параметре\n- **client_token** (type=\"client\"): `client_id` определится автоматически\n\n### Use Case:\nФинансовый агрегатор или маркетплейс хочет:\n- Показывать все продукты клиента из разных банков\n- Открывать депозиты/карты от имени клиента\n- Закрывать неактуальные договоры\n\n### Пример запроса:\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"read_product_agreements\": true,\n  \"open_product_agreements\": true,\n  \"close_product_agreements\": false,\n  \"allowed_product_types\": [\"deposit\", \"card\"],\n  \"max_amount\": 1000000.00,\n  \"valid_until\": \"2025-12-31T23:59:59\",\n  \"reason\": \"Финансовый агрегатор для управления продуктами\"\n}\n```\n\n### Разрешения:\n- `read_product_agreements`: просмотр списка договоров (депозиты, кредиты, карты)\n- `open_product_agreements`: открытие новых продуктов\n- `close_product_agreements`: закрытие существующих договоров\n\n### Ограничения:\n- `allowed_product_types`: только указанные типы продуктов\n- `max_amount`: макс сумма для открытия одного продукта","operationId":"create_product_agreement_consent_request_product_agreement_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProductAgreementConsentRequestData"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Create Product Agreement Consent Request Product Agreement Consents Request Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreement-consents/{consent_id}":{"get":{"tags":["6 Согласия на управление договорами"],"summary":"2. Получить согласие по ID","description":"## 📋 Получение согласия на управление договорами\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"get_product_agreement_consent_product_agreement_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Get Product Agreement Consent Product Agreement Consents  Consent Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["6 Согласия на управление договорами"],"summary":"3. Отозвать согласие","description":"## 🗑️ Отзыв согласия на управление договорами\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"revoke_product_agreement_consent_product_agreement_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/.well-known/jwks.json":{"get":{"tags":["Technical: Well-Known"],"summary":"Get Jwks","description":"JWKS endpoint - публичные ключи банка\n\nOpenID Connect Discovery\nRFC 7517 - JSON Web Key (JWK)\n\nИспользуется другими банками для проверки JWT подписей\nпри межбанковских запросах.","operationId":"get_jwks__well_known_jwks_json_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/":{"get":{"summary":"Root","description":"Root endpoint","operationId":"root__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/health":{"get":{"summary":"Health","description":"Health check endpoint","operationId":"health_health_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}}},"components":{"schemas":{"AccountCloseRequest":{"properties":{"action":{"type":"string","title":"Action"},"destination_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Destination Account Id"}},"type":"object","required":["action"],"title":"AccountCloseRequest","description":"Запрос на закрытие счета с переводом остатка"},"AccountStatusUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"AccountStatusUpdate","description":"Обновление статуса счета"},"CardLimitsRequest":{"properties":{"daily_limit":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Daily Limit","description":"Дневной лимит"},"monthly_limit":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Monthly Limit","description":"Месячный лимит"}},"type":"object","title":"CardLimitsRequest","description":"Запрос на обновление лимитов карты"},"CloseAgreementRequest":{"properties":{"repayment_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Repayment Account Id"},"repayment_amount":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Repayment Amount"}},"type":"object","title":"CloseAgreementRequest","description":"Запрос на закрытие договора с погашением"},"ConsentData":{"properties":{"consentId":{"type":"string","title":"Consentid"},"status":{"type":"string","title":"Status"},"creationDateTime":{"type":"string","title":"Creationdatetime"},"statusUpdateDateTime":{"type":"string","title":"Statusupdatedatetime"},"permissions":{"items":{"type":"string"},"type":"array","title":"Permissions"},"expirationDateTime":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Expirationdatetime"}},"type":"object","required":["consentId","status","creationDateTime","statusUpdateDateTime","permissions"],"title":"ConsentData","description":"Данные согласия в ответе"},"ConsentRequestBody":{"properties":{"client_id":{"type":"string","title":"Client Id","description":"Person ID клиента","example":"team200-1"},"permissions":{"items":{"type":"string"},"type":"array","title":"Permissions","description":"Список разрешений","example":["ReadAccountsDetail","ReadBalances","ReadTransactionsDetail"]},"reason":{"type":"string","title":"Reason","description":"Причина запроса","default":"","example":"Агрегация счетов для мультибанк-приложения"},"requesting_bank":{"type":"string","title":"Requesting Bank","description":"ID вашей команды (БЕЗ суффикса!)","default":"test_bank","example":"team200"},"requesting_bank_name":{"type":"string","title":"Requesting Bank Name","description":"Название приложения","default":"Test Bank","example":"Team 200 App"}},"type":"object","required":["client_id","permissions"],"title":"ConsentRequestBody","description":"Body для запроса согласия"},"ConsentResponse":{"properties":{"data":{"$ref":"#/components/schemas/ConsentData"},"links":{"type":"object","title":"Links"},"meta":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Meta","default":{}}},"type":"object","required":["data","links"],"title":"ConsentResponse","description":"Ответ с согласием"},"CreateAccountRequest":{"properties":{"account_type":{"type":"string","title":"Account Type"},"initial_balance":{"type":"number","title":"Initial Balance","default":0}},"type":"object","required":["account_type"],"title":"CreateAccountRequest","description":"Запрос на создание нового счета"},"CreateCardRequest":{"properties":{"account_number":{"type":"string","title":"Account Number","description":"Номер счета для привязки карты"},"card_name":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Card Name","description":"Название карты","default":"Visa Classic"},"card_type":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Card Type","description":"Тип карты: debit или credit","default":"debit"}},"type":"object","required":["account_number"],"title":"CreateCardRequest","description":"Запрос на создание новой карты"},"HTTPValidationError":{"properties":{"detail":{"items":{"$ref":"#/components/schemas/ValidationError"},"type":"array","title":"Detail"}},"type":"object","title":"HTTPValidationError"},"PaymentConsentRequestData":{"properties":{"requesting_bank":{"type":"string","title":"Requesting Bank","description":"Код банка-инициатора"},"client_id":{"type":"string","title":"Client Id","description":"ID клиента"},"consent_type":{"$ref":"#/components/schemas/PaymentConsentType","description":"Тип согласия","default":"single_use"},"amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Amount","description":"Сумма платежа"},"currency":{"type":"string","title":"Currency","description":"Валюта","default":"RUB"},"debtor_account":{"type":"string","title":"Debtor Account","description":"Счет списания"},"creditor_account":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Creditor Account","description":"Счет получателя (для single_use)"},"creditor_name":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Creditor Name","description":"Имя получателя"},"reference":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reference","description":"Назначение платежа"},"max_uses":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Max Uses","description":"Макс количество использований"},"max_amount_per_payment":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Amount Per Payment","description":"Макс сумма одного платежа"},"max_total_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Total Amount","description":"Макс общая сумма"},"allowed_creditor_accounts":{"anyOf":[{"items":{"type":"string"},"type":"array"},{"type":"null"}],"title":"Allowed Creditor Accounts","description":"Разрешенные счета"},"vrp_max_individual_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Max Individual Amount","description":"VRP: макс сумма платежа"},"vrp_daily_limit":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Daily Limit","description":"VRP: дневной лимит"},"vrp_monthly_limit":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Monthly Limit","description":"VRP: месячный лимит"},"valid_from":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid From","description":"Действует с"},"valid_until":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid Until","description":"Действует до"},"reason":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reason","description":"Причина запроса"}},"type":"object","required":["requesting_bank","client_id","debtor_account"],"title":"PaymentConsentRequestData","description":"Запрос на создание согласия"},"PaymentConsentType":{"type":"string","enum":["single_use","multi_use","vrp"],"title":"PaymentConsentType","description":"Типы согласий на платежи"},"PaymentData":{"properties":{"paymentId":{"type":"string","title":"Paymentid"},"status":{"type":"string","title":"Status"},"creationDateTime":{"type":"string","title":"Creationdatetime"},"statusUpdateDateTime":{"type":"string","title":"Statusupdatedatetime"},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description"},"amount":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Amount"},"currency":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Currency"}},"type":"object","required":["paymentId","status","creationDateTime","statusUpdateDateTime"],"title":"PaymentData","description":"Данные платежа в ответе"},"PaymentRequest":{"properties":{"data":{"type":"object","title":"Data","description":"Содержит initiation"},"risk":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Risk","default":{}}},"type":"object","required":["data"],"title":"PaymentRequest","description":"Запрос создания платежа"},"PaymentResponse":{"properties":{"data":{"$ref":"#/components/schemas/PaymentData"},"links":{"type":"object","title":"Links"},"meta":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Meta","default":{}}},"type":"object","required":["data","links"],"title":"PaymentResponse","description":"Ответ с платежом"},"ProductAgreementConsentRequestData":{"properties":{"requesting_bank":{"type":"string","title":"Requesting Bank","description":"Код банка-инициатора"},"client_id":{"type":"string","title":"Client Id","description":"ID клиента"},"read_product_agreements":{"type":"boolean","title":"Read Product Agreements","description":"Читать список договоров","default":false},"open_product_agreements":{"type":"boolean","title":"Open Product Agreements","description":"Открывать новые договоры","default":false},"close_product_agreements":{"type":"boolean","title":"Close Product Agreements","description":"Закрывать договоры","default":false},"allowed_product_types":{"anyOf":[{"items":{"type":"string"},"type":"array"},{"type":"null"}],"title":"Allowed Product Types","description":"Разрешенные типы продуктов: deposit, card, credit"},"max_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Amount","description":"Макс сумма открытия продукта"},"valid_until":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid Until","description":"Действует до"},"reason":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reason","description":"Причина запроса"}},"type":"object","required":["requesting_bank","client_id"],"title":"ProductAgreementConsentRequestData","description":"Запрос на создание согласия для управления договорами"},"ProductAgreementRequest":{"properties":{"product_id":{"type":"string","title":"Product Id","description":"ID продукта из каталога","example":"prod-vbank-deposit-001"},"amount":{"type":"number","title":"Amount","description":"Сумма продукта (депозита, кредита, лимита карты)","example":50000.0},"term_months":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Term Months","description":"Срок в месяцах (для депозитов и кредитов)","example":12},"source_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Source Account Id","description":"Номер счета для списания средств (обязательно для депозитов и карт, не нужно для кредитов)","example":"40817810200010318134"}},"type":"object","required":["product_id","amount"],"title":"ProductAgreementRequest","description":"Запрос на открытие продукта"},"UpdateCardStatusRequest":{"properties":{"status":{"type":"string","title":"Status","description":"Новый статус: active, blocked, expired"}},"type":"object","required":["status"],"title":"UpdateCardStatusRequest","description":"Запрос на изменение статуса карты"},"ValidationError":{"properties":{"loc":{"items":{"anyOf":[{"type":"string"},{"type":"integer"}]},"type":"array","title":"Location"},"msg":{"type":"string","title":"Message"},"type":{"type":"string","title":"Error Type"}},"type":"object","required":["loc","msg","type"],"title":"ValidationError"}},"securitySchemes":{"HTTPBearer":{"type":"http","scheme":"bearer"}}},"tags":[{"name":"0 Аутентификация вызывающей системы","description":"Получите токен для работы с API"},{"name":"1 Согласия на доступ к счетам","description":"Создание и управление согласиями для доступа к данным клиентов"},{"name":"2 Счета и балансы","description":"Просмотр счетов, балансов и истории транзакций"},{"name":"3 Согласия на переводы","description":"Согласия для совершения платежей от имени клиента"},{"name":"4 Переводы","description":"Создание платежей и проверка их статуса"},{"name":"5 Каталог продуктов","description":"Депозиты, кредиты, карты — каталог банковских продуктов"},{"name":"6 Согласия на управление договорами","description":"Согласия на открытие/закрытие продуктов от имени клиента"},{"name":"7 Договоры с продуктами","description":"Открытие и закрытие депозитов, кредитов и карт"},{"name":"8 Карты","description":"Управление банковскими картами (привязка к счетам, блокировка, лимиты)"},{"name":"Technical: Well-Known","description":"JWKS — публичные ключи для проверки JWT"}]}
</file>

<file path="package.json">
{
  "name": "frontend-2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.6",
    "axios": "^1.13.2",
    "classnames": "^2.5.1",
    "formik": "^2.4.6",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.552.0",
    "next-themes": "^0.4.6",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.5",
    "recharts": "^3.3.0",
    "sass": "^1.93.3",
    "sonner": "^2.0.7",
    "zod": "^4.1.12",
    "zod-formik-adapter": "^2.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/classnames": "^2.3.0",
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "paths": {
      "@/*": ["./src/*"]
    },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0', // Needed for Docker
    port: 5173,
    watch: {
      usePolling: true, // Needed for Docker on some systems
    },
    proxy: {
      '/api': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      },
      '/auth': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
      },
      '/users': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
      }
    }
  }
})
</file>

</files>
