This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  worktrees.json
app/
  security/
    __init__.py
    jwt_handler.py
    oauth2.py
    password.py
  services/
    ar_management_service.py
    bank_oauth_service.py
    counterparty_service.py
    data_aggregation_service.py
    financial_analytics_service.py
    ml_prediction_service.py
    oauth_service.py
    sms_service.py
    universal_bank_service.py
  tasks/
    __init__.py
    sync_tasks.py
  utils/
    __init__.py
    exceptions.py
    validators.py
  __init__.py
  analytics_router.py
  ar_router.py
  auth_router.py
  auth_schemas.py
  bank_api_router.py
  bank_schemas.py
  config.py
  counterparty_router.py
  database.py
  models.py
  predictions_router.py
  schemas.py
  sync_router.py
  users_router.py
docker/
  docker.sh
  README.md
frontend/
  public/
    capybara.webp
    kitty.webp
    vite.svg
  src/
    assets/
      react.svg
    components/
      BankAccountList/
        index.module.scss
        index.tsx
      CashFlowChart/
        index.module.scss
        index.tsx
      Layout/
        index.module.scss
        index.tsx
      ReceivablesTable/
        index.module.scss
        index.tsx
      StatCard/
        index.module.scss
        index.tsx
    hooks/
      useAuth.ts
    pages/
      Auth/
        AuthForm.module.scss
        AuthForm.tsx
        index.module.scss
        index.tsx
        OAuthSuccess.module.scss
        OAuthSuccess.tsx
      CashFlow/
        index.module.scss
        index.tsx
      Health/
        index.module.scss
        index.tsx
      home/
        index.module.scss
        index.tsx
      Landing/
        index.module.scss
        index.tsx
      NotFound/
        index.module.scss
        index.tsx
      Payments/
        index.module.scss
        index.tsx
      Profile/
        index.module.scss
        index.tsx
      Receivables/
        index.module.scss
        index.tsx
      Settings/
        index.module.scss
        index.tsx
    styles/
      colors.ts
      globals.scss
      main.scss
      mixins.scss
      vars.scss
    ui/
      badge/
        index.module.scss
        index.tsx
      button/
        index.module.scss
        index.tsx
      card/
        index.module.scss
        index.tsx
      input/
        index.module.scss
        index.tsx
      label/
        index.module.scss
        index.tsx
      sonner/
        index.tsx
        sonner.module.scss
      table/
        index.module.scss
        index.tsx
      tooltip/
        index.module.scss
        index.tsx
    utils/
      api.ts
      cookies.ts
      zod.ts
    App.tsx
    main.tsx
  .dockerignore
  .gitignore
  Dockerfile
  Dockerfile.dev
  eslint.config.js
  index.html
  nginx.conf
  openapi.json
  package.json
  README.md
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
tests/
  __init__.py
  conftest.py
  README.md
  test_auth.py
  test_health.py
.env.bak2
.gitignore
create_bank_users_table.sql
DATABASE_FIX.md
DOCKER_FIX_GUIDE.md
DOCKER_STRUCTURE.md
docker-compose.prod.yml
docker-compose.yml
docker.sh
Dockerfile
env.example
fix_database.sh
main.py
PORTS.md
pytest.ini
README.md
requirements.txt
run_tests.sh
stop.sh
TESTING.md
vtb_api_hack.session.sql
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/worktrees.json">
{
  "setup-worktree": [
    "npm install"
  ]
}
</file>

<file path="app/security/__init__.py">

</file>

<file path="app/security/jwt_handler.py">
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.config import get_settings

settings = get_settings()

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(user_id: int) -> str:
    data = {
        "sub": str(user_id),
        "type": "refresh"
    }
    expires_delta = timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    return create_access_token(data, expires_delta)

def verify_token(token: str) -> Optional[Dict[str, Any]]:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None

def decode_token(token: str) -> Optional[int]:
    payload = verify_token(token)
    if payload:
        user_id = payload.get("sub")
        if user_id:
            return int(user_id)
    return None
</file>

<file path="app/services/ar_management_service.py">
"""
Сервис для управления дебиторской задолженностью (Accounts Receivable)
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from app.models import AccountsReceivable, Counterparty, BankTransaction

logger = logging.getLogger(__name__)


class ARManagementService:
    """Сервис для управления дебиторской задолженностью"""
    
    async def create_invoice(
        self,
        db: AsyncSession,
        user_id: int,
        counterparty_id: int,
        invoice_number: str,
        invoice_date: datetime,
        due_date: datetime,
        amount: Decimal,
        currency: str = "RUB",
        description: Optional[str] = None,
        auto_reminder_enabled: bool = True,
        reminder_days_before: int = 3
    ) -> Dict:
        """
        Создать счет к получению
        
        Returns:
            dict: Созданный счет
        """
        try:
            # Проверяем существование контрагента
            counterparty = await db.get(Counterparty, counterparty_id)
            if not counterparty or counterparty.user_id != user_id:
                return {
                    "success": False,
                    "error": "Counterparty not found"
                }
            
            # Проверяем, не существует ли уже счет с таким номером
            stmt = select(AccountsReceivable).where(
                and_(
                    AccountsReceivable.user_id == user_id,
                    AccountsReceivable.invoice_number == invoice_number
                )
            )
            result = await db.execute(stmt)
            existing = result.scalar_one_or_none()
            
            if existing:
                return {
                    "success": False,
                    "error": "Invoice with this number already exists"
                }
            
            # Определяем статус
            status = "overdue" if due_date < datetime.utcnow() else "pending"
            
            # Создаем счет
            invoice = AccountsReceivable(
                user_id=user_id,
                counterparty_id=counterparty_id,
                invoice_number=invoice_number,
                invoice_date=invoice_date,
                due_date=due_date,
                amount=amount,
                currency=currency,
                description=description,
                status=status,
                auto_reminder_enabled=auto_reminder_enabled,
                reminder_days_before=reminder_days_before
            )
            
            db.add(invoice)
            await db.commit()
            await db.refresh(invoice)
            
            return {
                "success": True,
                "invoice": {
                    "id": invoice.id,
                    "invoice_number": invoice.invoice_number,
                    "counterparty_name": counterparty.name,
                    "amount": float(invoice.amount),
                    "due_date": invoice.due_date.isoformat(),
                    "status": invoice.status
                }
            }
            
        except Exception as e:
            logger.error(f"Error creating invoice: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def mark_as_paid(
        self,
        db: AsyncSession,
        user_id: int,
        invoice_id: int,
        paid_amount: Optional[Decimal] = None,
        payment_transaction_id: Optional[int] = None
    ) -> Dict:
        """
        Отметить счет как оплаченный
        
        Args:
            db: Database session
            user_id: ID пользователя
            invoice_id: ID счета
            paid_amount: Сумма оплаты (если None - полная оплата)
            payment_transaction_id: ID транзакции оплаты
        """
        try:
            invoice = await db.get(AccountsReceivable, invoice_id)
            if not invoice or invoice.user_id != user_id:
                return {
                    "success": False,
                    "error": "Invoice not found"
                }
            
            if paid_amount is None:
                paid_amount = invoice.amount - invoice.paid_amount
            
            invoice.paid_amount += paid_amount
            
            # Обновляем статус
            if invoice.paid_amount >= invoice.amount:
                invoice.status = "paid"
                invoice.paid_at = datetime.utcnow()
            elif invoice.paid_amount > 0:
                invoice.status = "partial"
            
            if payment_transaction_id:
                invoice.payment_transaction_id = payment_transaction_id
            
            await db.commit()
            await db.refresh(invoice)
            
            return {
                "success": True,
                "invoice": {
                    "id": invoice.id,
                    "status": invoice.status,
                    "paid_amount": float(invoice.paid_amount),
                    "remaining_amount": float(invoice.amount - invoice.paid_amount)
                }
            }
            
        except Exception as e:
            logger.error(f"Error marking invoice as paid: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def auto_match_payments(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """
        Автоматически сопоставить входящие платежи со счетами
        
        Returns:
            dict: Результат сопоставления
        """
        try:
            # Получаем неоплаченные счета
            stmt = select(AccountsReceivable).where(
                and_(
                    AccountsReceivable.user_id == user_id,
                    AccountsReceivable.status.in_(["pending", "partial"]),
                    AccountsReceivable.payment_transaction_id.is_(None)
                )
            )
            result = await db.execute(stmt)
            unpaid_invoices = result.scalars().all()
            
            # Получаем входящие транзакции без привязки к счетам
            tx_stmt = select(BankTransaction).where(
                and_(
                    BankTransaction.user_id == user_id,
                    BankTransaction.category == "income",
                    BankTransaction.counterparty_id.isnot(None)
                )
            ).order_by(BankTransaction.booking_date.desc())
            
            tx_result = await db.execute(tx_stmt)
            income_transactions = tx_result.scalars().all()
            
            matched_count = 0
            
            for invoice in unpaid_invoices:
                remaining = invoice.amount - invoice.paid_amount
                
                # Ищем транзакцию от того же контрагента с похожей суммой
                for tx in income_transactions:
                    if tx.counterparty_id == invoice.counterparty_id:
                        # Проверяем сумму (допускаем небольшую погрешность)
                        if abs(float(tx.amount) - float(remaining)) < 0.01:
                            # Сопоставляем
                            invoice.paid_amount = invoice.amount
                            invoice.status = "paid"
                            invoice.payment_transaction_id = tx.id
                            invoice.paid_at = tx.booking_date
                            matched_count += 1
                            break
            
            await db.commit()
            
            return {
                "success": True,
                "matched_invoices": matched_count
            }
            
        except Exception as e:
            logger.error(f"Error auto-matching payments: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_overdue_invoices(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """Получить просроченные счета"""
        try:
            now = datetime.utcnow()
            
            stmt = select(AccountsReceivable).where(
                and_(
                    AccountsReceivable.user_id == user_id,
                    AccountsReceivable.status.in_(["pending", "partial"]),
                    AccountsReceivable.due_date < now
                )
            ).order_by(AccountsReceivable.due_date)
            
            result = await db.execute(stmt)
            overdue = result.scalars().all()
            
            # Обновляем статус на overdue
            for invoice in overdue:
                if invoice.status != "overdue":
                    invoice.status = "overdue"
            
            await db.commit()
            
            return {
                "success": True,
                "overdue_invoices": [
                    {
                        "id": inv.id,
                        "invoice_number": inv.invoice_number,
                        "counterparty_id": inv.counterparty_id,
                        "amount": float(inv.amount),
                        "paid_amount": float(inv.paid_amount),
                        "remaining": float(inv.amount - inv.paid_amount),
                        "due_date": inv.due_date.isoformat(),
                        "days_overdue": (now - inv.due_date).days
                    }
                    for inv in overdue
                ],
                "total_overdue": sum(
                    float(inv.amount - inv.paid_amount)
                    for inv in overdue
                )
            }
            
        except Exception as e:
            logger.error(f"Error getting overdue invoices: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_ar_summary(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """Получить сводку по дебиторской задолженности"""
        try:
            stmt = select(AccountsReceivable).where(
                AccountsReceivable.user_id == user_id
            )
            result = await db.execute(stmt)
            all_invoices = result.scalars().all()
            
            total_ar = sum(
                inv.amount - inv.paid_amount
                for inv in all_invoices
                if inv.status != "paid"
            )
            
            overdue_ar = sum(
                inv.amount - inv.paid_amount
                for inv in all_invoices
                if inv.status == "overdue" or (inv.due_date < datetime.utcnow() and inv.status != "paid")
            )
            
            pending_count = len([inv for inv in all_invoices if inv.status == "pending"])
            overdue_count = len([inv for inv in all_invoices if inv.status == "overdue"])
            
            return {
                "success": True,
                "summary": {
                    "total_ar": float(total_ar),
                    "overdue_ar": float(overdue_ar),
                    "pending_count": pending_count,
                    "overdue_count": overdue_count,
                    "total_invoices": len(all_invoices)
                }
            }
            
        except Exception as e:
            logger.error(f"Error getting AR summary: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_invoices(
        self,
        db: AsyncSession,
        user_id: int,
        status: Optional[str] = None,
        counterparty_id: Optional[int] = None
    ) -> Dict:
        """Получить список счетов"""
        try:
            conditions = [AccountsReceivable.user_id == user_id]
            
            if status:
                conditions.append(AccountsReceivable.status == status)
            
            if counterparty_id:
                conditions.append(AccountsReceivable.counterparty_id == counterparty_id)
            
            stmt = select(AccountsReceivable).where(
                and_(*conditions)
            ).order_by(AccountsReceivable.due_date.desc())
            
            result = await db.execute(stmt)
            invoices = result.scalars().all()
            
            return {
                "success": True,
                "invoices": [
                    {
                        "id": inv.id,
                        "invoice_number": inv.invoice_number,
                        "counterparty_id": inv.counterparty_id,
                        "amount": float(inv.amount),
                        "paid_amount": float(inv.paid_amount),
                        "remaining": float(inv.amount - inv.paid_amount),
                        "invoice_date": inv.invoice_date.isoformat(),
                        "due_date": inv.due_date.isoformat(),
                        "status": inv.status,
                        "description": inv.description
                    }
                    for inv in invoices
                ]
            }
            
        except Exception as e:
            logger.error(f"Error getting invoices: {e}")
            return {
                "success": False,
                "error": str(e)
            }


# Глобальный экземпляр
ar_management_service = ARManagementService()
</file>

<file path="app/services/counterparty_service.py">
"""
Сервис для управления контрагентами
"""
import logging
from datetime import datetime
from typing import Dict, List, Optional
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func

from app.models import Counterparty, BankTransaction, AccountsReceivable

logger = logging.getLogger(__name__)


class CounterpartyService:
    """Сервис для управления контрагентами"""
    
    async def create_counterparty(
        self,
        db: AsyncSession,
        user_id: int,
        name: str,
        type: str,  # customer, supplier, other
        inn: Optional[str] = None,
        kpp: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        account_number: Optional[str] = None,
        bank_name: Optional[str] = None,
        bic: Optional[str] = None,
        correspondent_account: Optional[str] = None,
        notes: Optional[str] = None
    ) -> Dict:
        """
        Создать контрагента
        
        Returns:
            dict: Созданный контрагент
        """
        try:
            if type not in ["customer", "supplier", "other"]:
                return {
                    "success": False,
                    "error": "Invalid type. Must be: customer, supplier, other"
                }
            
            counterparty = Counterparty(
                user_id=user_id,
                name=name,
                type=type,
                inn=inn,
                kpp=kpp,
                email=email,
                phone=phone,
                account_number=account_number,
                bank_name=bank_name,
                bic=bic,
                correspondent_account=correspondent_account,
                notes=notes
            )
            
            db.add(counterparty)
            await db.commit()
            await db.refresh(counterparty)
            
            return {
                "success": True,
                "counterparty": {
                    "id": counterparty.id,
                    "name": counterparty.name,
                    "type": counterparty.type
                }
            }
            
        except Exception as e:
            logger.error(f"Error creating counterparty: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def update_counterparty(
        self,
        db: AsyncSession,
        user_id: int,
        counterparty_id: int,
        **kwargs
    ) -> Dict:
        """Обновить данные контрагента"""
        try:
            counterparty = await db.get(Counterparty, counterparty_id)
            if not counterparty or counterparty.user_id != user_id:
                return {
                    "success": False,
                    "error": "Counterparty not found"
                }
            
            # Обновляем только переданные поля
            allowed_fields = [
                "name", "type", "inn", "kpp", "email", "phone",
                "account_number", "bank_name", "bic", "correspondent_account",
                "notes", "is_active"
            ]
            
            for field, value in kwargs.items():
                if field in allowed_fields and hasattr(counterparty, field):
                    setattr(counterparty, field, value)
            
            counterparty.updated_at = datetime.utcnow()
            
            await db.commit()
            await db.refresh(counterparty)
            
            return {
                "success": True,
                "counterparty": self._format_counterparty(counterparty)
            }
            
        except Exception as e:
            logger.error(f"Error updating counterparty: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_counterparty(
        self,
        db: AsyncSession,
        user_id: int,
        counterparty_id: int
    ) -> Dict:
        """Получить контрагента с деталями"""
        try:
            counterparty = await db.get(Counterparty, counterparty_id)
            if not counterparty or counterparty.user_id != user_id:
                return {
                    "success": False,
                    "error": "Counterparty not found"
                }
            
            # Получаем статистику транзакций
            stats = await self._get_counterparty_stats(db, counterparty_id)
            
            return {
                "success": True,
                "counterparty": {
                    **self._format_counterparty(counterparty),
                    "statistics": stats
                }
            }
            
        except Exception as e:
            logger.error(f"Error getting counterparty: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def list_counterparties(
        self,
        db: AsyncSession,
        user_id: int,
        type: Optional[str] = None,
        search: Optional[str] = None
    ) -> Dict:
        """Получить список контрагентов"""
        try:
            conditions = [Counterparty.user_id == user_id]
            
            if type:
                conditions.append(Counterparty.type == type)
            
            if search:
                conditions.append(
                    Counterparty.name.ilike(f"%{search}%")
                )
            
            stmt = select(Counterparty).where(
                and_(*conditions)
            ).order_by(Counterparty.name)
            
            result = await db.execute(stmt)
            counterparties = result.scalars().all()
            
            return {
                "success": True,
                "counterparties": [
                    self._format_counterparty(cp)
                    for cp in counterparties
                ]
            }
            
        except Exception as e:
            logger.error(f"Error listing counterparties: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def auto_create_from_transaction(
        self,
        db: AsyncSession,
        user_id: int,
        transaction_id: int
    ) -> Dict:
        """
        Автоматически создать контрагента из транзакции
        
        Returns:
            dict: Созданный контрагент
        """
        try:
            transaction = await db.get(BankTransaction, transaction_id)
            if not transaction or transaction.user_id != user_id:
                return {
                    "success": False,
                    "error": "Transaction not found"
                }
            
            # Определяем тип контрагента
            if transaction.category == "income":
                cp_type = "customer"
                name = transaction.creditor_name or "Unknown Customer"
            else:
                cp_type = "supplier"
                name = transaction.debtor_name or "Unknown Supplier"
            
            # Проверяем, не существует ли уже такой контрагент
            stmt = select(Counterparty).where(
                and_(
                    Counterparty.user_id == user_id,
                    Counterparty.name == name
                )
            )
            result = await db.execute(stmt)
            existing = result.scalar_one_or_none()
            
            if existing:
                # Привязываем транзакцию к существующему контрагенту
                transaction.counterparty_id = existing.id
                await db.commit()
                return {
                    "success": True,
                    "counterparty": self._format_counterparty(existing),
                    "created": False
                }
            
            # Создаем нового контрагента
            counterparty = Counterparty(
                user_id=user_id,
                name=name,
                type=cp_type,
                account_number=transaction.creditor_account if cp_type == "customer" else transaction.debtor_account
            )
            
            db.add(counterparty)
            await db.commit()
            await db.refresh(counterparty)
            
            # Привязываем транзакцию
            transaction.counterparty_id = counterparty.id
            await db.commit()
            
            return {
                "success": True,
                "counterparty": self._format_counterparty(counterparty),
                "created": True
            }
            
        except Exception as e:
            logger.error(f"Error auto-creating counterparty: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def update_counterparty_stats(
        self,
        db: AsyncSession,
        counterparty_id: int
    ):
        """Обновить статистику контрагента"""
        try:
            counterparty = await db.get(Counterparty, counterparty_id)
            if not counterparty:
                return
            
            # Получаем статистику
            stats = await self._get_counterparty_stats(db, counterparty_id)
            
            # Обновляем
            counterparty.total_received = Decimal(str(stats["total_received"]))
            counterparty.total_paid = Decimal(str(stats["total_paid"]))
            counterparty.transaction_count = stats["transaction_count"]
            counterparty.updated_at = datetime.utcnow()
            
            await db.commit()
            
        except Exception as e:
            logger.error(f"Error updating counterparty stats: {e}")
    
    # ==================== PRIVATE METHODS ====================
    
    async def _get_counterparty_stats(
        self,
        db: AsyncSession,
        counterparty_id: int
    ) -> Dict:
        """Получить статистику по контрагенту"""
        # Транзакции
        stmt = select(BankTransaction).where(
            BankTransaction.counterparty_id == counterparty_id
        )
        result = await db.execute(stmt)
        transactions = result.scalars().all()
        
        total_received = sum(
            tx.amount
            for tx in transactions
            if tx.category == "income"
        )
        
        total_paid = sum(
            tx.amount
            for tx in transactions
            if tx.category == "expense"
        )
        
        # Дебиторская задолженность
        ar_stmt = select(AccountsReceivable).where(
            AccountsReceivable.counterparty_id == counterparty_id
        )
        ar_result = await db.execute(ar_stmt)
        ar_list = ar_result.scalars().all()
        
        total_ar = sum(
            ar.amount - ar.paid_amount
            for ar in ar_list
            if ar.status != "paid"
        )
        
        return {
            "total_received": float(total_received),
            "total_paid": float(total_paid),
            "transaction_count": len(transactions),
            "total_ar": float(total_ar),
            "ar_count": len([ar for ar in ar_list if ar.status != "paid"])
        }
    
    def _format_counterparty(self, counterparty: Counterparty) -> Dict:
        """Форматировать контрагента для ответа"""
        return {
            "id": counterparty.id,
            "name": counterparty.name,
            "type": counterparty.type,
            "inn": counterparty.inn,
            "kpp": counterparty.kpp,
            "email": counterparty.email,
            "phone": counterparty.phone,
            "account_number": counterparty.account_number,
            "bank_name": counterparty.bank_name,
            "bic": counterparty.bic,
            "total_received": float(counterparty.total_received),
            "total_paid": float(counterparty.total_paid),
            "transaction_count": counterparty.transaction_count,
            "is_active": counterparty.is_active,
            "created_at": counterparty.created_at.isoformat()
        }


# Глобальный экземпляр
counterparty_service = CounterpartyService()
</file>

<file path="app/services/data_aggregation_service.py">
"""
Сервис для агрегации и синхронизации данных из банков
"""
import logging
from datetime import datetime, timedelta
from typing import List, Optional, Dict
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from sqlalchemy.orm import selectinload

from app.models import (
    BankAccount, BankTransaction, BankConsent, 
    User, Counterparty
)
from app.services.universal_bank_service import universal_bank_service

logger = logging.getLogger(__name__)


class DataAggregationService:
    """Сервис для синхронизации данных из банков"""
    
    def __init__(self):
        self.bank_service = universal_bank_service
    
    async def sync_user_accounts(
        self,
        db: AsyncSession,
        user_id: int,
        bank_code: Optional[str] = None
    ) -> Dict:
        """
        Синхронизировать счета пользователя из банков
        
        Args:
            db: Database session
            user_id: ID пользователя
            bank_code: Код банка (если None - все банки)
        
        Returns:
            dict: Результат синхронизации
        """
        try:
            bank_codes = [bank_code] if bank_code else ["vbank", "abank", "sbank"]
            results = {}
            
            for bank_code in bank_codes:
                try:
                    # Получаем данные из банка (используя bank_user_id из БД если доступен)
                    bank_result = await self.bank_service.get_all_accounts_full_cycle(
                        bank_code=bank_code,
                        user_id=str(user_id),  # Fallback если нет bank_user_id в БД
                        db=db,
                        internal_user_id=user_id
                    )
                    
                    if not bank_result.get("success"):
                        error_msg = bank_result.get("error", "Unknown error")
                        # Проверяем, не связана ли ошибка с отсутствием bank_user_id
                        if "No bank_user_id" in error_msg or "bank_user_id" in error_msg.lower():
                            results[bank_code] = {
                                "success": False,
                                "error": f"{error_msg}. Please set bank_user_id in your profile first."
                            }
                        else:
                            results[bank_code] = {
                                "success": False,
                                "error": error_msg
                            }
                        continue
                    
                    # Сохраняем согласие
                    consent_id = bank_result.get("consent_id")
                    if consent_id:
                        await self._save_consent(
                            db=db,
                            user_id=user_id,
                            bank_code=bank_code,
                            consent_id=consent_id,
                            auto_approved=bank_result.get("auto_approved", True)
                        )
                    
                    # Сохраняем счета
                    accounts = bank_result.get("accounts", [])
                    saved_count = 0
                    for account_data in accounts:
                        account_id = account_data.get("account_id") or account_data.get("id")
                        if not account_id:
                            continue
                        
                        await self._save_account(
                            db=db,
                            user_id=user_id,
                            bank_code=bank_code,
                            account_id=account_id,
                            account_data=account_data,
                            consent_id=consent_id
                        )
                        saved_count += 1
                    
                    results[bank_code] = {
                        "success": True,
                        "accounts_synced": saved_count
                    }
                    
                except Exception as e:
                    logger.error(f"Error syncing {bank_code} for user {user_id}: {e}")
                    results[bank_code] = {
                        "success": False,
                        "error": str(e)
                    }
            
            return {
                "success": True,
                "results": results
            }
            
        except Exception as e:
            logger.error(f"Error in sync_user_accounts: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def sync_account_transactions(
        self,
        db: AsyncSession,
        user_id: int,
        account_id: int,
        bank_code: str,
        consent_id: str,
        days_back: int = 90
    ) -> Dict:
        """
        Синхронизировать транзакции по счету
        
        Args:
            db: Database session
            user_id: ID пользователя
            account_id: ID счета в нашей БД
            bank_code: Код банка
            consent_id: ID согласия
            days_back: За сколько дней назад получать транзакции
        
        Returns:
            dict: Результат синхронизации
        """
        try:
            # Получаем account_id из банка
            account = await db.get(BankAccount, account_id)
            if not account:
                return {"success": False, "error": "Account not found"}
            
            bank_account_id = account.account_id
            
            # Получаем токен банка
            access_token = await self.bank_service.get_bank_access_token(bank_code)
            if not access_token:
                return {"success": False, "error": "Failed to get bank token"}
            
            # Вычисляем даты
            to_date = datetime.utcnow()
            from_date = to_date - timedelta(days=days_back)
            
            # Получаем транзакции из банка
            # Преобразуем даты в формат ISO 8601
            from_booking_date_time = from_date.strftime("%Y-%m-%dT00:00:00Z")
            to_booking_date_time = to_date.strftime("%Y-%m-%dT23:59:59Z")
            
            transactions_data = await self.bank_service.get_account_transactions(
                bank_code=bank_code,
                access_token=access_token,
                account_id=bank_account_id,
                consent_id=consent_id,
                from_booking_date_time=from_booking_date_time,
                to_booking_date_time=to_booking_date_time,
                page=None,  # Получаем все транзакции без пагинации при синхронизации
                limit=None
            )
            
            if not transactions_data:
                return {"success": False, "error": "Failed to fetch transactions"}
            
            transactions = transactions_data.get("transactions", [])
            saved_count = 0
            
            for tx_data in transactions:
                await self._save_transaction(
                    db=db,
                    user_id=user_id,
                    account_id=account_id,
                    bank_code=bank_code,
                    transaction_data=tx_data
                )
                saved_count += 1
            
            # Обновляем время последней синхронизации
            account.last_synced_at = datetime.utcnow()
            await db.commit()
            
            return {
                "success": True,
                "transactions_synced": saved_count
            }
            
        except Exception as e:
            logger.error(f"Error syncing transactions: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def sync_all_accounts_transactions(
        self,
        db: AsyncSession,
        user_id: int,
        days_back: int = 90
    ) -> Dict:
        """Синхронизировать транзакции по всем счетам пользователя"""
        try:
            # Получаем все активные счета пользователя
            stmt = select(BankAccount).where(
                and_(
                    BankAccount.user_id == user_id,
                    BankAccount.is_active == True
                )
            )
            result = await db.execute(stmt)
            accounts = result.scalars().all()
            
            results = {}
            for account in accounts:
                # Получаем согласие
                consent = await self._get_active_consent(
                    db=db,
                    user_id=user_id,
                    bank_code=account.bank_code
                )
                
                if not consent:
                    results[account.id] = {
                        "success": False,
                        "error": "No active consent"
                    }
                    continue
                
                result = await self.sync_account_transactions(
                    db=db,
                    user_id=user_id,
                    account_id=account.id,
                    bank_code=account.bank_code,
                    consent_id=consent.consent_id,
                    days_back=days_back
                )
                results[account.id] = result
            
            return {
                "success": True,
                "results": results
            }
            
        except Exception as e:
            logger.error(f"Error syncing all transactions: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    # ==================== PRIVATE METHODS ====================
    
    async def _save_consent(
        self,
        db: AsyncSession,
        user_id: int,
        bank_code: str,
        consent_id: str,
        auto_approved: bool = True
    ):
        """Сохранить или обновить согласие"""
        stmt = select(BankConsent).where(
            and_(
                BankConsent.user_id == user_id,
                BankConsent.bank_code == bank_code,
                BankConsent.consent_id == consent_id
            )
        )
        result = await db.execute(stmt)
        consent = result.scalar_one_or_none()
        
        if consent:
            consent.status = "approved"
            consent.auto_approved = auto_approved
            consent.updated_at = datetime.utcnow()
        else:
            consent = BankConsent(
                user_id=user_id,
                bank_code=bank_code,
                consent_id=consent_id,
                status="approved",
                auto_approved=auto_approved
            )
            db.add(consent)
        
        await db.commit()
        return consent
    
    async def _save_account(
        self,
        db: AsyncSession,
        user_id: int,
        bank_code: str,
        account_id: str,
        account_data: Dict,
        consent_id: Optional[str] = None
    ):
        """Сохранить или обновить счет"""
        stmt = select(BankAccount).where(
            and_(
                BankAccount.user_id == user_id,
                BankAccount.bank_code == bank_code,
                BankAccount.account_id == account_id
            )
        )
        result = await db.execute(stmt)
        account = result.scalar_one_or_none()
        
        # Извлекаем баланс
        balance_data = account_data.get("balances", [])
        current_balance = None
        available_balance = None
        
        if balance_data:
            for balance in balance_data:
                balance_type = balance.get("balance_type", "").lower()
                amount = balance.get("amount", {}).get("amount") or balance.get("balance_amount")
                if amount:
                    if "current" in balance_type or "interim" in balance_type:
                        current_balance = Decimal(str(amount))
                    elif "available" in balance_type:
                        available_balance = Decimal(str(amount))
        
        if account:
            # Обновляем существующий счет
            account.account_type = account_data.get("account_type") or account.account_type
            account.currency = account_data.get("currency") or account.currency or "RUB"
            account.account_name = account_data.get("account_name") or account_data.get("name") or account.account_name
            account.iban = account_data.get("iban") or account.iban
            account.bic = account_data.get("bic") or account.bic
            account.current_balance = current_balance or account.current_balance
            account.available_balance = available_balance or account.available_balance
            account.balance_updated_at = datetime.utcnow()
            account.consent_id = consent_id or account.consent_id
            account.last_synced_at = datetime.utcnow()
            account.is_active = True
        else:
            # Создаем новый счет
            account = BankAccount(
                user_id=user_id,
                bank_code=bank_code,
                account_id=account_id,
                consent_id=consent_id,
                account_type=account_data.get("account_type"),
                currency=account_data.get("currency") or "RUB",
                account_name=account_data.get("account_name") or account_data.get("name"),
                iban=account_data.get("iban"),
                bic=account_data.get("bic"),
                current_balance=current_balance,
                available_balance=available_balance,
                balance_updated_at=datetime.utcnow(),
                last_synced_at=datetime.utcnow()
            )
            db.add(account)
        
        await db.commit()
        return account
    
    async def _save_transaction(
        self,
        db: AsyncSession,
        user_id: int,
        account_id: int,
        bank_code: str,
        transaction_data: Dict
    ):
        """Сохранить транзакцию"""
        tx_id = transaction_data.get("transaction_id") or transaction_data.get("id")
        
        if tx_id:
            # Проверяем, существует ли уже транзакция
            stmt = select(BankTransaction).where(
                and_(
                    BankTransaction.user_id == user_id,
                    BankTransaction.transaction_id == tx_id,
                    BankTransaction.account_id == account_id
                )
            )
            result = await db.execute(stmt)
            existing_tx = result.scalar_one_or_none()
            
            if existing_tx:
                return existing_tx  # Уже существует
        
        # Извлекаем данные
        amount = transaction_data.get("amount", {}).get("amount") or transaction_data.get("amount")
        if not amount:
            return None
        
        amount = Decimal(str(amount))
        currency = transaction_data.get("currency") or transaction_data.get("amount", {}).get("currency") or "RUB"
        
        # Определяем тип транзакции
        tx_type = transaction_data.get("transaction_type") or transaction_data.get("credit_debit_indicator")
        if not tx_type:
            # Пытаемся определить по знаку суммы
            tx_type = "credit" if amount >= 0 else "debit"
        
        # Определяем категорию
        category = "expense" if tx_type.lower() == "debit" else "income"
        
        # Парсим даты
        booking_date_str = transaction_data.get("booking_date") or transaction_data.get("bookingDateTime")
        value_date_str = transaction_data.get("value_date") or transaction_data.get("valueDateTime")
        
        booking_date = None
        if booking_date_str:
            try:
                if isinstance(booking_date_str, str):
                    booking_date = datetime.fromisoformat(booking_date_str.replace("Z", "+00:00"))
                else:
                    booking_date = booking_date_str
            except:
                booking_date = datetime.utcnow()
        else:
            booking_date = datetime.utcnow()
        
        value_date = None
        if value_date_str:
            try:
                if isinstance(value_date_str, str):
                    value_date = datetime.fromisoformat(value_date_str.replace("Z", "+00:00"))
                else:
                    value_date = value_date_str
            except:
                pass
        
        # Создаем транзакцию
        transaction = BankTransaction(
            user_id=user_id,
            account_id=account_id,
            bank_code=bank_code,
            transaction_id=tx_id,
            amount=abs(amount),
            currency=currency,
            transaction_type=tx_type.lower(),
            booking_date=booking_date,
            value_date=value_date,
            remittance_information=transaction_data.get("remittance_information") or transaction_data.get("remittanceInformation"),
            creditor_name=transaction_data.get("creditor_name") or transaction_data.get("creditorName"),
            creditor_account=transaction_data.get("creditor_account") or transaction_data.get("creditorAccount", {}).get("iban"),
            debtor_name=transaction_data.get("debtor_name") or transaction_data.get("debtorName"),
            debtor_account=transaction_data.get("debtor_account") or transaction_data.get("debtorAccount", {}).get("iban"),
            category=category
        )
        
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        
        return transaction
    
    async def _get_active_consent(
        self,
        db: AsyncSession,
        user_id: int,
        bank_code: str
    ) -> Optional[BankConsent]:
        """Получить активное согласие"""
        stmt = select(BankConsent).where(
            and_(
                BankConsent.user_id == user_id,
                BankConsent.bank_code == bank_code,
                BankConsent.status == "approved"
            )
        ).order_by(BankConsent.created_at.desc())
        
        result = await db.execute(stmt)
        return result.scalar_one_or_none()


# Глобальный экземпляр
data_aggregation_service = DataAggregationService()
</file>

<file path="app/services/financial_analytics_service.py">
"""
Сервис для расчета финансовых метрик и аналитики
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, Optional, List
from decimal import Decimal
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func, case
from sqlalchemy.orm import selectinload

from app.models import (
    BankAccount, BankTransaction, FinancialHealthMetrics,
    AccountsReceivable, User, BankUser, BankConsent
)
from app.services.universal_bank_service import universal_bank_service

logger = logging.getLogger(__name__)


class FinancialAnalyticsService:
    """Сервис для расчета финансовых метрик"""
    
    async def calculate_health_metrics(
        self,
        db: AsyncSession,
        user_id: int,
        period_start: Optional[datetime] = None,
        period_end: Optional[datetime] = None
    ) -> Dict:
        """
        Рассчитать метрики финансового здоровья за период
        
        Args:
            db: Database session
            user_id: ID пользователя
            period_start: Начало периода (по умолчанию - 30 дней назад)
            period_end: Конец периода (по умолчанию - сейчас)
        
        Returns:
            dict: Метрики финансового здоровья
        """
        try:
            if not period_end:
                period_end = datetime.utcnow()
            if not period_start:
                period_start = period_end - timedelta(days=30)
            
            # Получаем транзакции за период
            transactions = await self._get_transactions_in_period(
                db=db,
                user_id=user_id,
                period_start=period_start,
                period_end=period_end
            )
            
            # Получаем счета
            accounts = await self._get_user_accounts(db=db, user_id=user_id)
            
            # Получаем дебиторскую задолженность
            ar_data = await self._get_ar_data(db=db, user_id=user_id)
            
            # Рассчитываем метрики
            metrics = {
                # Доходы и расходы
                "total_revenue": self._calculate_revenue(transactions),
                "total_expenses": self._calculate_expenses(transactions),
                "net_income": Decimal(0),
                
                # Балансы
                "total_assets": self._calculate_total_assets(accounts),
                "total_liabilities": Decimal(0),  # Упрощенно, можно расширить
                "net_worth": Decimal(0),
                
                # Метрики ликвидности
                "current_ratio": None,
                "quick_ratio": None,
                
                # Дебиторская задолженность
                "total_ar": ar_data["total"],
                "overdue_ar": ar_data["overdue"],
                "ar_turnover_days": None,
                
                # Денежный поток
                "operating_cash_flow": Decimal(0),
                "cash_flow_trend": None,
                
                # Health score
                "health_score": None,
                "health_status": None
            }
            
            # Вычисляем производные метрики
            metrics["net_income"] = metrics["total_revenue"] - metrics["total_expenses"]
            metrics["net_worth"] = metrics["total_assets"] - metrics["total_liabilities"]
            metrics["operating_cash_flow"] = metrics["net_income"]
            
            # Коэффициенты ликвидности
            current_assets = metrics["total_assets"]
            current_liabilities = metrics["total_liabilities"] or Decimal(1)  # Избегаем деления на 0
            if current_liabilities > 0:
                metrics["current_ratio"] = current_assets / current_liabilities
            
            # Оборачиваемость ДЗ
            if metrics["total_revenue"] > 0:
                ar_turnover = metrics["total_ar"] / metrics["total_revenue"]
                days_in_period = (period_end - period_start).days
                metrics["ar_turnover_days"] = (ar_turnover * days_in_period) if days_in_period > 0 else None
            
            # Тренд денежного потока
            metrics["cash_flow_trend"] = await self._calculate_cash_flow_trend(
                db=db,
                user_id=user_id,
                current_period_start=period_start,
                current_period_end=period_end
            )
            
            # Health score (0-100)
            metrics["health_score"] = self._calculate_health_score(metrics)
            metrics["health_status"] = self._get_health_status(metrics["health_score"])
            
            # Сохраняем метрики
            await self._save_metrics(
                db=db,
                user_id=user_id,
                period_start=period_start,
                period_end=period_end,
                metrics=metrics
            )
            
            return {
                "success": True,
                "period": {
                    "start": period_start.isoformat(),
                    "end": period_end.isoformat()
                },
                "metrics": self._format_metrics(metrics)
            }
            
        except Exception as e:
            logger.error(f"Error calculating health metrics: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_dashboard_summary(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """
        Получить сводку для дашборда
        
        Returns:
            dict: Сводка с основными метриками
        """
        try:
            # Текущий баланс
            accounts = await self._get_user_accounts(db=db, user_id=user_id)
            total_balance = sum(
                (acc.current_balance or Decimal(0)) 
                for acc in accounts 
                if acc.is_active
            )
            
            # Доходы и расходы за последние 30 дней из банков напрямую
            period_end = datetime.utcnow()
            period_start = period_end - timedelta(days=30)
            
            # Получаем транзакции из всех банков напрямую через API
            all_transactions = await self._get_transactions_from_banks(
                db=db,
                user_id=user_id,
                period_start=period_start,
                period_end=period_end
            )
            
            total_revenue = self._calculate_revenue_from_bank_transactions(all_transactions)
            total_expenses = self._calculate_expenses_from_bank_transactions(all_transactions)
            net_income = total_revenue - total_expenses
            
            # Дебиторская задолженность
            ar_data = await self._get_ar_data(db=db, user_id=user_id)
            
            # Последние метрики здоровья
            latest_metrics = await self._get_latest_metrics(db=db, user_id=user_id)
            
            return {
                "success": True,
                "summary": {
                    "total_balance": float(total_balance),
                    "total_revenue": float(total_revenue),
                    "total_expenses": float(total_expenses),
                    "net_income": float(net_income),
                    "total_ar": float(ar_data["total"]),
                    "overdue_ar": float(ar_data["overdue"]),
                    "health_score": latest_metrics.get("health_score"),
                    "health_status": latest_metrics.get("health_status"),
                    "accounts_count": len([a for a in accounts if a.is_active])
                }
            }
            
        except Exception as e:
            logger.error(f"Error getting dashboard summary: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    # ==================== PRIVATE METHODS ====================
    
    async def _get_transactions_in_period(
        self,
        db: AsyncSession,
        user_id: int,
        period_start: datetime,
        period_end: datetime
    ) -> List:
        """Получить транзакции за период"""
        stmt = select(BankTransaction).where(
            and_(
                BankTransaction.user_id == user_id,
                BankTransaction.booking_date >= period_start,
                BankTransaction.booking_date <= period_end
            )
        )
        result = await db.execute(stmt)
        return result.scalars().all()
    
    async def _get_user_accounts(
        self,
        db: AsyncSession,
        user_id: int
    ) -> List:
        """Получить активные счета пользователя"""
        stmt = select(BankAccount).where(
            and_(
                BankAccount.user_id == user_id,
                BankAccount.is_active == True
            )
        )
        result = await db.execute(stmt)
        return result.scalars().all()
    
    async def _get_ar_data(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """Получить данные по дебиторской задолженности"""
        stmt = select(AccountsReceivable).where(
            and_(
                AccountsReceivable.user_id == user_id,
                AccountsReceivable.status.in_(["pending", "partial", "overdue"])
            )
        )
        result = await db.execute(stmt)
        ar_list = result.scalars().all()
        
        total = sum(
            (ar.amount - ar.paid_amount) 
            for ar in ar_list
        )
        
        overdue = sum(
            (ar.amount - ar.paid_amount)
            for ar in ar_list
            if ar.status == "overdue" or (ar.due_date < datetime.utcnow() and ar.status != "paid")
        )
        
        return {
            "total": total,
            "overdue": overdue,
            "count": len(ar_list)
        }
    
    def _calculate_revenue(self, transactions: List) -> Decimal:
        """Рассчитать доходы из транзакций БД"""
        return sum(
            tx.amount 
            for tx in transactions 
            if tx.category == "income" or tx.transaction_type == "credit"
        )
    
    def _calculate_expenses(self, transactions: List) -> Decimal:
        """Рассчитать расходы из транзакций БД"""
        return sum(
            tx.amount 
            for tx in transactions 
            if tx.category == "expense" or tx.transaction_type == "debit"
        )
    
    def _calculate_revenue_from_bank_transactions(self, transactions: List[Dict]) -> Decimal:
        """Рассчитать доходы из транзакций банков"""
        total = Decimal(0)
        for tx in transactions:
            # Проверяем тип транзакции (Credit = доход)
            transaction_type = tx.get("transaction_type") or tx.get("creditDebitIndicator", "").lower()
            if transaction_type.lower() == "credit":
                amount = tx.get("amount")
                if amount:
                    if isinstance(amount, (int, float)):
                        total += Decimal(str(amount))
                    elif isinstance(amount, str):
                        try:
                            total += Decimal(amount)
                        except:
                            pass
        return total
    
    def _calculate_expenses_from_bank_transactions(self, transactions: List[Dict]) -> Decimal:
        """Рассчитать расходы из транзакций банков"""
        total = Decimal(0)
        for tx in transactions:
            # Проверяем тип транзакции (Debit = расход)
            transaction_type = tx.get("transaction_type") or tx.get("creditDebitIndicator", "").lower()
            if transaction_type.lower() == "debit":
                amount = tx.get("amount")
                if amount:
                    if isinstance(amount, (int, float)):
                        total += Decimal(str(abs(amount)))  # Берем абсолютное значение
                    elif isinstance(amount, str):
                        try:
                            total += Decimal(str(abs(float(amount))))
                        except:
                            pass
        return total
    
    async def _get_transactions_from_banks(
        self,
        db: AsyncSession,
        user_id: int,
        period_start: datetime,
        period_end: datetime
    ) -> List[Dict]:
        """Получить транзакции из всех банков напрямую через API"""
        all_transactions = []
        
        try:
            # Получаем все активные счета пользователя
            accounts = await self._get_user_accounts(db=db, user_id=user_id)
            
            # Группируем счета по банкам
            accounts_by_bank = {}
            for account in accounts:
                if account.is_active:
                    bank_code = account.bank_code
                    if bank_code not in accounts_by_bank:
                        accounts_by_bank[bank_code] = []
                    accounts_by_bank[bank_code].append(account)
            
            # Получаем транзакции из каждого банка
            for bank_code, bank_accounts in accounts_by_bank.items():
                try:
                    # Получаем bank_user_id и consent_id
                    bank_user_stmt = select(BankUser).where(
                        and_(
                            BankUser.user_id == user_id,
                            BankUser.bank_code == bank_code
                        )
                    )
                    bank_user_result = await db.execute(bank_user_stmt)
                    bank_user = bank_user_result.scalar_one_or_none()
                    
                    if not bank_user:
                        logger.warning(f"No bank_user_id for user {user_id} and bank {bank_code}")
                        continue
                    
                    # Получаем активное согласие
                    consent_stmt = select(BankConsent).where(
                        and_(
                            BankConsent.user_id == user_id,
                            BankConsent.bank_code == bank_code,
                            BankConsent.status == "approved"
                        )
                    ).order_by(BankConsent.created_at.desc())
                    consent_result = await db.execute(consent_stmt)
                    consent = consent_result.scalar_one_or_none()
                    
                    if not consent:
                        logger.warning(f"No active consent for user {user_id} and bank {bank_code}")
                        continue
                    
                    # Получаем токен банка
                    access_token = await universal_bank_service.get_bank_access_token(bank_code)
                    if not access_token:
                        logger.warning(f"Failed to get access token for bank {bank_code}")
                        continue
                    
                    # Получаем транзакции для каждого счета
                    for account in bank_accounts:
                        try:
                            # Форматируем даты в ISO 8601
                            from_date = period_start.strftime("%Y-%m-%dT%H:%M:%SZ")
                            to_date = period_end.strftime("%Y-%m-%dT%H:%M:%SZ")
                            
                            transactions_data = await universal_bank_service.get_account_transactions(
                                bank_code=bank_code,
                                access_token=access_token,
                                account_id=account.account_id,
                                consent_id=consent.consent_id,
                                from_booking_date_time=from_date,
                                to_booking_date_time=to_date
                            )
                            
                            if transactions_data and "transactions" in transactions_data:
                                transactions = transactions_data["transactions"]
                                if isinstance(transactions, list):
                                    all_transactions.extend(transactions)
                        except Exception as e:
                            logger.error(f"Error fetching transactions for account {account.account_id} from {bank_code}: {e}")
                            continue
                            
                except Exception as e:
                    logger.error(f"Error fetching transactions from bank {bank_code}: {e}")
                    continue
            
        except Exception as e:
            logger.error(f"Error getting transactions from banks: {e}")
        
        return all_transactions
    
    def _calculate_total_assets(self, accounts: List) -> Decimal:
        """Рассчитать общие активы (балансы счетов)"""
        return sum(
            (acc.current_balance or Decimal(0))
            for acc in accounts
            if acc.is_active
        )
    
    async def _calculate_cash_flow_trend(
        self,
        db: AsyncSession,
        user_id: int,
        current_period_start: datetime,
        current_period_end: datetime
    ) -> Optional[str]:
        """Рассчитать тренд денежного потока"""
        try:
            # Текущий период
            current_txs = await self._get_transactions_in_period(
                db=db,
                user_id=user_id,
                period_start=current_period_start,
                period_end=current_period_end
            )
            current_cf = self._calculate_revenue(current_txs) - self._calculate_expenses(current_txs)
            
            # Предыдущий период (такой же длины)
            period_length = current_period_end - current_period_start
            prev_period_end = current_period_start
            prev_period_start = prev_period_end - period_length
            
            prev_txs = await self._get_transactions_in_period(
                db=db,
                user_id=user_id,
                period_start=prev_period_start,
                period_end=prev_period_end
            )
            prev_cf = self._calculate_revenue(prev_txs) - self._calculate_expenses(prev_txs)
            
            if prev_cf == 0:
                return "stable"
            
            change_pct = ((current_cf - prev_cf) / abs(prev_cf)) * 100
            
            if change_pct > 10:
                return "increasing"
            elif change_pct < -10:
                return "decreasing"
            else:
                return "stable"
                
        except Exception as e:
            logger.error(f"Error calculating cash flow trend: {e}")
            return None
    
    def _calculate_health_score(self, metrics: Dict) -> int:
        """
        Рассчитать общий health score (0-100)
        
        Факторы:
        - Положительный денежный поток: 30 баллов
        - Низкая просроченная ДЗ: 25 баллов
        - Хорошая ликвидность: 25 баллов
        - Рост доходов: 20 баллов
        """
        score = 0
        
        # Денежный поток (0-30)
        if metrics["net_income"] > 0:
            score += 30
        elif metrics["net_income"] == 0:
            score += 15
        else:
            # Штраф за отрицательный поток
            score += max(0, 15 + int(metrics["net_income"] / metrics["total_revenue"] * 15) if metrics["total_revenue"] > 0 else 0)
        
        # Просроченная ДЗ (0-25)
        if metrics["total_ar"] > 0:
            overdue_ratio = metrics["overdue_ar"] / metrics["total_ar"]
            score += int((1 - overdue_ratio) * 25)
        else:
            score += 25  # Нет ДЗ - отлично
        
        # Ликвидность (0-25)
        if metrics["current_ratio"]:
            if metrics["current_ratio"] >= 2:
                score += 25
            elif metrics["current_ratio"] >= 1:
                score += 15
            else:
                score += max(0, int(metrics["current_ratio"] * 15))
        
        # Тренд денежного потока (0-20)
        if metrics["cash_flow_trend"] == "increasing":
            score += 20
        elif metrics["cash_flow_trend"] == "stable":
            score += 10
        else:
            score += 5
        
        return min(100, max(0, score))
    
    def _get_health_status(self, score: Optional[int]) -> str:
        """Определить статус здоровья по score"""
        if score is None:
            return "unknown"
        elif score >= 80:
            return "excellent"
        elif score >= 60:
            return "good"
        elif score >= 40:
            return "fair"
        elif score >= 20:
            return "poor"
        else:
            return "critical"
    
    def _format_metrics(self, metrics: Dict) -> Dict:
        """Форматировать метрики для ответа"""
        return {
            "revenue": {
                "total": float(metrics["total_revenue"]),
                "expenses": float(metrics["total_expenses"]),
                "net_income": float(metrics["net_income"])
            },
            "balance": {
                "total_assets": float(metrics["total_assets"]),
                "total_liabilities": float(metrics["total_liabilities"]),
                "net_worth": float(metrics["net_worth"])
            },
            "liquidity": {
                "current_ratio": float(metrics["current_ratio"]) if metrics["current_ratio"] else None,
                "quick_ratio": float(metrics["quick_ratio"]) if metrics["quick_ratio"] else None
            },
            "accounts_receivable": {
                "total": float(metrics["total_ar"]),
                "overdue": float(metrics["overdue_ar"]),
                "turnover_days": float(metrics["ar_turnover_days"]) if metrics["ar_turnover_days"] else None
            },
            "cash_flow": {
                "operating_cash_flow": float(metrics["operating_cash_flow"]),
                "trend": metrics["cash_flow_trend"]
            },
            "health": {
                "score": metrics["health_score"],
                "status": metrics["health_status"]
            }
        }
    
    async def _save_metrics(
        self,
        db: AsyncSession,
        user_id: int,
        period_start: datetime,
        period_end: datetime,
        metrics: Dict
    ):
        """Сохранить метрики в БД"""
        health_metrics = FinancialHealthMetrics(
            user_id=user_id,
            period_start=period_start,
            period_end=period_end,
            total_revenue=metrics["total_revenue"],
            total_expenses=metrics["total_expenses"],
            net_income=metrics["net_income"],
            total_assets=metrics["total_assets"],
            total_liabilities=metrics["total_liabilities"],
            net_worth=metrics["net_worth"],
            current_ratio=metrics["current_ratio"],
            quick_ratio=metrics["quick_ratio"],
            total_ar=metrics["total_ar"],
            overdue_ar=metrics["overdue_ar"],
            ar_turnover_days=metrics["ar_turnover_days"],
            operating_cash_flow=metrics["operating_cash_flow"],
            cash_flow_trend=metrics["cash_flow_trend"],
            health_score=metrics["health_score"],
            health_status=metrics["health_status"]
        )
        
        db.add(health_metrics)
        await db.commit()
        return health_metrics
    
    async def _get_latest_metrics(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Dict:
        """Получить последние метрики"""
        stmt = select(FinancialHealthMetrics).where(
            FinancialHealthMetrics.user_id == user_id
        ).order_by(FinancialHealthMetrics.calculated_at.desc()).limit(1)
        
        result = await db.execute(stmt)
        metrics = result.scalar_one_or_none()
        
        if metrics:
            return {
                "health_score": metrics.health_score,
                "health_status": metrics.health_status,
                "net_income": float(metrics.net_income) if metrics.net_income else 0
            }
        return {}


# Глобальный экземпляр
financial_analytics_service = FinancialAnalyticsService()
</file>

<file path="app/services/ml_prediction_service.py">
"""
Сервис для ML-прогнозирования денежных потоков
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from decimal import Decimal
import numpy as np
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from app.models import (
    BankTransaction, CashFlowPrediction, BankAccount,
    AccountsReceivable
)

logger = logging.getLogger(__name__)


class MLPredictionService:
    """
    Сервис для прогнозирования денежных потоков с использованием ML
    
    Для MVP используем упрощенные статистические модели:
    - Moving Average для базового прогноза
    - Seasonal decomposition для учета сезонности
    - Trend analysis для трендов
    """
    
    def __init__(self):
        self.model_version = "v1.0"
    
    async def predict_cash_flow(
        self,
        db: AsyncSession,
        user_id: int,
        weeks_ahead: int = 4,
        prediction_date: Optional[datetime] = None
    ) -> Dict:
        """
        Прогнозировать денежный поток на несколько недель вперед
        
        Args:
            db: Database session
            user_id: ID пользователя
            weeks_ahead: На сколько недель вперед прогнозировать (по умолчанию 4)
            prediction_date: Дата начала прогноза (по умолчанию - сейчас)
        
        Returns:
            dict: Прогнозы на каждую неделю
        """
        try:
            if not prediction_date:
                prediction_date = datetime.utcnow()
            
            # Получаем исторические данные (последние 6 месяцев)
            historical_data = await self._get_historical_cash_flow(
                db=db,
                user_id=user_id,
                months_back=6
            )
            
            if len(historical_data) < 4:  # Минимум 4 недели данных
                return {
                    "success": False,
                    "error": "Insufficient historical data for prediction"
                }
            
            # Получаем ожидаемые поступления (AR)
            expected_inflows = await self._get_expected_inflows(
                db=db,
                user_id=user_id,
                weeks_ahead=weeks_ahead,
                start_date=prediction_date
            )
            
            # Генерируем прогнозы
            predictions = []
            for week_num in range(1, weeks_ahead + 1):
                week_date = prediction_date + timedelta(weeks=week_num)
                
                # Прогнозируем приток
                predicted_inflow = self._predict_inflow(
                    historical_data=historical_data,
                    week_num=week_num,
                    expected_inflows=expected_inflows.get(week_num, Decimal(0))
                )
                
                # Прогнозируем отток
                predicted_outflow = self._predict_outflow(
                    historical_data=historical_data,
                    week_num=week_num
                )
                
                # Прогнозируем баланс
                current_balance = await self._get_current_balance(db=db, user_id=user_id)
                predicted_balance = current_balance + predicted_inflow - predicted_outflow
                
                # Рассчитываем вероятность кассового разрыва
                gap_probability, gap_amount = self._calculate_gap_probability(
                    predicted_balance=predicted_balance,
                    historical_data=historical_data
                )
                
                # Сохраняем прогноз
                prediction = CashFlowPrediction(
                    user_id=user_id,
                    prediction_date=week_date,
                    predicted_inflow=predicted_inflow,
                    predicted_outflow=predicted_outflow,
                    predicted_balance=predicted_balance,
                    gap_probability=gap_probability,
                    gap_amount=gap_amount,
                    model_version=self.model_version,
                    confidence_score=self._calculate_confidence(historical_data)
                )
                
                db.add(prediction)
                
                predictions.append({
                    "week": week_num,
                    "date": week_date.isoformat(),
                    "predicted_inflow": float(predicted_inflow),
                    "predicted_outflow": float(predicted_outflow),
                    "predicted_balance": float(predicted_balance),
                    "gap_probability": float(gap_probability) if gap_probability else None,
                    "gap_amount": float(gap_amount) if gap_amount else None,
                    "confidence_score": float(prediction.confidence_score) if prediction.confidence_score else None
                })
            
            await db.commit()
            
            return {
                "success": True,
                "predictions": predictions,
                "model_version": self.model_version,
                "current_balance": float(current_balance)
            }
            
        except Exception as e:
            logger.error(f"Error predicting cash flow: {e}")
            await db.rollback()
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_cash_flow_gaps(
        self,
        db: AsyncSession,
        user_id: int,
        weeks_ahead: int = 4
    ) -> Dict:
        """
        Получить прогноз кассовых разрывов
        
        Returns:
            dict: Список потенциальных разрывов
        """
        try:
            # Получаем прогнозы
            prediction_result = await self.predict_cash_flow(
                db=db,
                user_id=user_id,
                weeks_ahead=weeks_ahead
            )
            
            if not prediction_result.get("success"):
                return prediction_result
            
            predictions = prediction_result.get("predictions", [])
            
            # Фильтруем только те, где есть риск разрыва
            gaps = []
            for pred in predictions:
                if pred.get("gap_probability", 0) > 30:  # Вероятность > 30%
                    gaps.append({
                        "date": pred["date"],
                        "week": pred["week"],
                        "predicted_balance": pred["predicted_balance"],
                        "gap_probability": pred["gap_probability"],
                        "gap_amount": pred.get("gap_amount", 0),
                        "predicted_inflow": pred["predicted_inflow"],
                        "predicted_outflow": pred["predicted_outflow"]
                    })
            
            return {
                "success": True,
                "gaps": gaps,
                "total_gaps": len(gaps)
            }
            
        except Exception as e:
            logger.error(f"Error getting cash flow gaps: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    # ==================== PRIVATE METHODS ====================
    
    async def _get_historical_cash_flow(
        self,
        db: AsyncSession,
        user_id: int,
        months_back: int = 6
    ) -> List[Dict]:
        """
        Получить исторические данные о денежных потоках по неделям
        
        Returns:
            list: Список словарей с недельными данными
        """
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=months_back * 30)
        
        # Получаем транзакции
        stmt = select(BankTransaction).where(
            and_(
                BankTransaction.user_id == user_id,
                BankTransaction.booking_date >= start_date,
                BankTransaction.booking_date <= end_date
            )
        ).order_by(BankTransaction.booking_date)
        
        result = await db.execute(stmt)
        transactions = result.scalars().all()
        
        # Группируем по неделям
        weekly_data = {}
        for tx in transactions:
            # Определяем неделю
            week_start = tx.booking_date - timedelta(days=tx.booking_date.weekday())
            week_key = week_start.strftime("%Y-%W")
            
            if week_key not in weekly_data:
                weekly_data[week_key] = {
                    "week_start": week_start,
                    "inflow": Decimal(0),
                    "outflow": Decimal(0)
                }
            
            if tx.category == "income" or tx.transaction_type == "credit":
                weekly_data[week_key]["inflow"] += tx.amount
            else:
                weekly_data[week_key]["outflow"] += tx.amount
        
        # Преобразуем в список и сортируем
        historical = sorted(
            weekly_data.values(),
            key=lambda x: x["week_start"]
        )
        
        return historical
    
    async def _get_expected_inflows(
        self,
        db: AsyncSession,
        user_id: int,
        weeks_ahead: int,
        start_date: datetime
    ) -> Dict[int, Decimal]:
        """
        Получить ожидаемые поступления из дебиторской задолженности
        
        Returns:
            dict: {week_num: amount}
        """
        end_date = start_date + timedelta(weeks=weeks_ahead)
        
        stmt = select(AccountsReceivable).where(
            and_(
                AccountsReceivable.user_id == user_id,
                AccountsReceivable.status.in_(["pending", "partial"]),
                AccountsReceivable.due_date >= start_date,
                AccountsReceivable.due_date <= end_date
            )
        )
        
        result = await db.execute(stmt)
        ar_list = result.scalars().all()
        
        expected = {}
        for ar in ar_list:
            # Определяем неделю
            days_diff = (ar.due_date - start_date).days
            week_num = (days_diff // 7) + 1
            
            if week_num <= weeks_ahead:
                amount = ar.amount - ar.paid_amount
                if week_num not in expected:
                    expected[week_num] = Decimal(0)
                expected[week_num] += amount
        
        return expected
    
    def _predict_inflow(
        self,
        historical_data: List[Dict],
        week_num: int,
        expected_inflows: Decimal = Decimal(0)
    ) -> Decimal:
        """
        Прогнозировать приток денежных средств
        
        Использует:
        - Moving Average для базового прогноза
        - Ожидаемые поступления из AR
        """
        if len(historical_data) == 0:
            return Decimal(0)
        
        # Берем последние 4 недели для MA
        recent_weeks = historical_data[-4:] if len(historical_data) >= 4 else historical_data
        
        # Простое скользящее среднее
        avg_inflow = sum(w["inflow"] for w in recent_weeks) / len(recent_weeks)
        
        # Учитываем тренд
        if len(historical_data) >= 2:
            recent_trend = (recent_weeks[-1]["inflow"] - recent_weeks[0]["inflow"]) / len(recent_weeks)
            trend_adjustment = recent_trend * week_num * Decimal("0.3")  # Смягчаем тренд
        else:
            trend_adjustment = Decimal(0)
        
        predicted = avg_inflow + trend_adjustment + expected_inflows
        
        return max(Decimal(0), predicted)
    
    def _predict_outflow(
        self,
        historical_data: List[Dict],
        week_num: int
    ) -> Decimal:
        """
        Прогнозировать отток денежных средств
        
        Использует Moving Average с учетом тренда
        """
        if len(historical_data) == 0:
            return Decimal(0)
        
        # Берем последние 4 недели для MA
        recent_weeks = historical_data[-4:] if len(historical_data) >= 4 else historical_data
        
        # Простое скользящее среднее
        avg_outflow = sum(w["outflow"] for w in recent_weeks) / len(recent_weeks)
        
        # Учитываем тренд
        if len(historical_data) >= 2:
            recent_trend = (recent_weeks[-1]["outflow"] - recent_weeks[0]["outflow"]) / len(recent_weeks)
            trend_adjustment = recent_trend * week_num * Decimal("0.3")
        else:
            trend_adjustment = Decimal(0)
        
        predicted = avg_outflow + trend_adjustment
        
        return max(Decimal(0), predicted)
    
    def _calculate_gap_probability(
        self,
        predicted_balance: Decimal,
        historical_data: List[Dict]
    ) -> tuple:
        """
        Рассчитать вероятность кассового разрыва
        
        Returns:
            tuple: (probability %, gap_amount)
        """
        if predicted_balance >= 0:
            return None, None
        
        # Рассчитываем вероятность на основе исторической волатильности
        if len(historical_data) < 2:
            return Decimal(50), abs(predicted_balance)
        
        # Вычисляем стандартное отклонение балансов
        balances = []
        running_balance = Decimal(0)
        for week in historical_data:
            running_balance += week["inflow"] - week["outflow"]
            balances.append(float(running_balance))
        
        if len(balances) < 2:
            return Decimal(50), abs(predicted_balance)
        
        std_dev = np.std(balances)
        mean_balance = np.mean(balances)
        
        # Если прогнозируемый баланс отрицательный
        gap_amount = abs(predicted_balance)
        
        # Вероятность зависит от того, насколько далеко от среднего
        if std_dev > 0:
            z_score = abs((float(predicted_balance) - mean_balance) / std_dev)
            # Преобразуем z-score в вероятность (упрощенно)
            probability = min(100, max(10, 50 + int(z_score * 15)))
        else:
            probability = 50 if predicted_balance < 0 else 0
        
        return Decimal(probability), gap_amount
    
    def _calculate_confidence(self, historical_data: List[Dict]) -> Decimal:
        """
        Рассчитать уверенность модели (0-100)
        
        Зависит от количества исторических данных
        """
        if len(historical_data) >= 12:  # 3 месяца
            return Decimal(85)
        elif len(historical_data) >= 8:  # 2 месяца
            return Decimal(70)
        elif len(historical_data) >= 4:  # 1 месяц
            return Decimal(55)
        else:
            return Decimal(40)
    
    async def _get_current_balance(
        self,
        db: AsyncSession,
        user_id: int
    ) -> Decimal:
        """Получить текущий баланс всех счетов"""
        stmt = select(BankAccount).where(
            and_(
                BankAccount.user_id == user_id,
                BankAccount.is_active == True
            )
        )
        result = await db.execute(stmt)
        accounts = result.scalars().all()
        
        total = sum(
            (acc.current_balance or Decimal(0))
            for acc in accounts
        )
        
        return total


# Глобальный экземпляр
ml_prediction_service = MLPredictionService()
</file>

<file path="app/tasks/__init__.py">
"""
Background tasks for periodic data synchronization
"""
</file>

<file path="app/tasks/sync_tasks.py">
"""
Celery tasks for periodic data synchronization
"""
import logging
from datetime import datetime
from celery import Celery
from app.config import get_settings

settings = get_settings()
logger = logging.getLogger(__name__)

# Initialize Celery
celery_app = Celery(
    "multi_banking_tasks",
    broker=settings.REDIS_URL,
    backend=settings.REDIS_URL
)

celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
)


@celery_app.task(name="sync_user_bank_data")
def sync_user_bank_data(user_id: int, days_back: int = 90):
    """
    Периодическая синхронизация банковских данных пользователя
    
    Эта задача должна вызываться из контекста приложения с доступом к БД
    """
    # Note: Для полноценной работы нужен доступ к async DB session
    # В реальном приложении это можно сделать через:
    # 1. Использование async celery workers
    # 2. Или синхронные обертки над async функциями
    # 3. Или прямое использование SQLAlchemy sync API
    
    logger.info(f"Syncing bank data for user {user_id}")
    # Реализация будет зависеть от выбранного подхода
    return {"status": "scheduled", "user_id": user_id}


@celery_app.task(name="update_financial_metrics")
def update_financial_metrics(user_id: int):
    """
    Обновить финансовые метрики пользователя
    """
    logger.info(f"Updating financial metrics for user {user_id}")
    return {"status": "scheduled", "user_id": user_id}


@celery_app.task(name="generate_cash_flow_predictions")
def generate_cash_flow_predictions(user_id: int, weeks_ahead: int = 4):
    """
    Сгенерировать прогнозы денежных потоков
    """
    logger.info(f"Generating cash flow predictions for user {user_id}")
    return {"status": "scheduled", "user_id": user_id}


@celery_app.task(name="check_overdue_invoices")
def check_overdue_invoices(user_id: int = None):
    """
    Проверить просроченные счета и отправить напоминания
    """
    logger.info(f"Checking overdue invoices for user {user_id or 'all'}")
    return {"status": "scheduled"}


# Периодические задачи (beat schedule)
celery_app.conf.beat_schedule = {
    "sync-all-users-data": {
        "task": "sync_user_bank_data",
        "schedule": 3600.0,  # Каждый час
        "args": (None, 90)  # user_id=None означает всех пользователей
    },
    "update-all-metrics": {
        "task": "update_financial_metrics",
        "schedule": 3600.0,  # Каждый час
        "args": (None,)
    },
    "check-overdue-invoices": {
        "task": "check_overdue_invoices",
        "schedule": 86400.0,  # Раз в день
        "args": (None,)
    },
}
</file>

<file path="app/utils/__init__.py">

</file>

<file path="app/utils/exceptions.py">
from fastapi import HTTPException, status

class UserAlreadyExists(HTTPException):
    def __init__(self, detail: str = "User already exists"):
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
        )

class InvalidCredentials(HTTPException):
    def __init__(self, detail: str = "Invalid email or password"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )

class UserNotActive(HTTPException):
    def __init__(self, detail: str = "User is not active"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )

class SMSError(HTTPException):
    def __init__(self, detail: str = "SMS sending error"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail
        )

class InvalidToken(HTTPException):
    def __init__(self, detail: str = "Invalid or expired token"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )
</file>

<file path="app/utils/validators.py">
import re

def validate_password_strength(password: str) -> tuple[bool, str]:
    """Проверка надежности пароля"""
    if len(password) < 8:
        return False, "Пароль должен быть минимум 8 символов"
    
    if not re.search(r'[A-Z]', password):
        return False, "Пароль должен содержать заглавные буквы"
    
    if not re.search(r'[a-z]', password):
        return False, "Пароль должен содержать строчные буквы"
    
    if not re.search(r'\d', password):
        return False, "Пароль должен содержать цифры"
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "Пароль должен содержать спецсимволы"
    
    return True, "OK"

def validate_email_format(email: str) -> bool:
    """Проверка формата email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_phone_format(phone: str) -> bool:
    """Проверка формата телефона"""
    pattern = r'^\+7\d{10}$'
    return re.match(pattern, phone) is not None

def is_email_valid(email: str) -> bool:
    """Расширенная проверка email"""
    return validate_email_format(email)
</file>

<file path="app/__init__.py">

</file>

<file path="app/analytics_router.py">
"""
Роутер для финансовой аналитики
"""
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from datetime import datetime

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.financial_analytics_service import financial_analytics_service

router = APIRouter(prefix="/api/v1/analytics", tags=["Financial Analytics"])


@router.get("/health-metrics")
async def get_health_metrics(
    period_start: Optional[str] = Query(None, description="Начало периода (YYYY-MM-DD)"),
    period_end: Optional[str] = Query(None, description="Конец периода (YYYY-MM-DD)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить метрики финансового здоровья за период
    
    **Параметры:**
    - **period_start**: Начало периода (по умолчанию - 30 дней назад)
    - **period_end**: Конец периода (по умолчанию - сейчас)
    
    **Возвращает:**
    - Метрики финансового здоровья
    """
    try:
        period_start_dt = None
        period_end_dt = None
        
        if period_start:
            period_start_dt = datetime.fromisoformat(period_start)
        if period_end:
            period_end_dt = datetime.fromisoformat(period_end)
        
        result = await financial_analytics_service.calculate_health_metrics(
            db=db,
            user_id=user_id,
            period_start=period_start_dt,
            period_end=period_end_dt
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to calculate metrics")
            )
        
        return result
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid date format: {str(e)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/dashboard")
async def get_dashboard_summary(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить сводку для дашборда
    
    **Возвращает:**
    - Основные метрики для отображения на дашборде
    """
    try:
        result = await financial_analytics_service.get_dashboard_summary(
            db=db,
            user_id=user_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to get dashboard summary")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
</file>

<file path="app/ar_router.py">
"""
Роутер для управления дебиторской задолженностью (Accounts Receivable)
"""
from fastapi import APIRouter, HTTPException, status, Depends, Query, Body
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.ar_management_service import ar_management_service

router = APIRouter(prefix="/api/v1/ar", tags=["Accounts Receivable"])


class CreateInvoiceRequest(BaseModel):
    counterparty_id: int
    invoice_number: str
    invoice_date: str  # ISO format
    due_date: str  # ISO format
    amount: float
    currency: str = "RUB"
    description: Optional[str] = None
    auto_reminder_enabled: bool = True
    reminder_days_before: int = 3


class MarkPaidRequest(BaseModel):
    paid_amount: Optional[float] = None
    payment_transaction_id: Optional[int] = None


@router.post("/invoices")
async def create_invoice(
    request: CreateInvoiceRequest,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Создать счет к получению
    
    **Параметры:**
    - **counterparty_id**: ID контрагента
    - **invoice_number**: Номер счета
    - **invoice_date**: Дата счета (ISO format)
    - **due_date**: Срок оплаты (ISO format)
    - **amount**: Сумма счета
    - **currency**: Валюта (по умолчанию RUB)
    - **description**: Описание
    - **auto_reminder_enabled**: Включить автоматические напоминания
    - **reminder_days_before**: За сколько дней напоминать
    """
    try:
        invoice_date = datetime.fromisoformat(request.invoice_date.replace("Z", "+00:00"))
        due_date = datetime.fromisoformat(request.due_date.replace("Z", "+00:00"))
        
        result = await ar_management_service.create_invoice(
            db=db,
            user_id=user_id,
            counterparty_id=request.counterparty_id,
            invoice_number=request.invoice_number,
            invoice_date=invoice_date,
            due_date=due_date,
            amount=Decimal(str(request.amount)),
            currency=request.currency,
            description=request.description,
            auto_reminder_enabled=request.auto_reminder_enabled,
            reminder_days_before=request.reminder_days_before
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to create invoice")
            )
        
        return result
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid date format: {str(e)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/invoices")
async def get_invoices(
    status: Optional[str] = Query(None, description="Фильтр по статусу"),
    counterparty_id: Optional[int] = Query(None, description="Фильтр по контрагенту"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить список счетов к получению
    
    **Параметры:**
    - **status**: Фильтр по статусу (pending, partial, paid, overdue, cancelled)
    - **counterparty_id**: Фильтр по контрагенту
    """
    try:
        result = await ar_management_service.get_invoices(
            db=db,
            user_id=user_id,
            status=status,
            counterparty_id=counterparty_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to get invoices")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/invoices/{invoice_id}/mark-paid")
async def mark_invoice_paid(
    invoice_id: int,
    request: MarkPaidRequest = Body(...),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Отметить счет как оплаченный
    
    **Параметры:**
    - **invoice_id**: ID счета
    - **paid_amount**: Сумма оплаты (если не указано - полная оплата)
    - **payment_transaction_id**: ID транзакции оплаты
    """
    try:
        paid_amount = Decimal(str(request.paid_amount)) if request.paid_amount else None
        
        result = await ar_management_service.mark_as_paid(
            db=db,
            user_id=user_id,
            invoice_id=invoice_id,
            paid_amount=paid_amount,
            payment_transaction_id=request.payment_transaction_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to mark invoice as paid")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/overdue")
async def get_overdue_invoices(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить просроченные счета
    
    **Возвращает:**
    - Список просроченных счетов с количеством дней просрочки
    """
    try:
        result = await ar_management_service.get_overdue_invoices(
            db=db,
            user_id=user_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to get overdue invoices")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/summary")
async def get_ar_summary(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить сводку по дебиторской задолженности
    
    **Возвращает:**
    - Общая сумма ДЗ, просроченная ДЗ, количество счетов
    """
    try:
        result = await ar_management_service.get_ar_summary(
            db=db,
            user_id=user_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to get AR summary")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/auto-match")
async def auto_match_payments(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Автоматически сопоставить входящие платежи со счетами
    
    **Возвращает:**
    - Количество сопоставленных счетов
    """
    try:
        result = await ar_management_service.auto_match_payments(
            db=db,
            user_id=user_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to auto-match payments")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
</file>

<file path="app/auth_schemas.py">
from pydantic import BaseModel, Field

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int

class TokenRequest(BaseModel):
    email: str
    password: str

class RefreshTokenRequest(BaseModel):
    refresh_token: str

class OAuth2AuthRequest(BaseModel):
    state: str
    code_verifier: str
    provider: str = "bank"

class OAuthCallbackResponse(BaseModel):
    authorization_code: str
    state: str
</file>

<file path="app/bank_schemas.py">
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime


class BankAccountSchema(BaseModel):
    """Схема банковского счета"""
    account_id: str = Field(..., description="ID счета")
    account_type: Optional[str] = Field(None, description="Тип счета")
    currency: Optional[str] = Field(None, description="Валюта")
    account_name: Optional[str] = Field(None, description="Название счета")
    iban: Optional[str] = Field(None, description="IBAN")
    bic: Optional[str] = Field(None, description="BIC")
    
    class Config:
        from_attributes = True


class BankBalanceSchema(BaseModel):
    """Схема баланса счета"""
    account_id: str = Field(..., description="ID счета")
    balance_amount: Optional[float] = Field(None, description="Сумма баланса")
    currency: Optional[str] = Field(None, description="Валюта")
    balance_type: Optional[str] = Field(None, description="Тип баланса")
    date_time: Optional[datetime] = Field(None, description="Дата и время")
    
    class Config:
        from_attributes = True


class BankTransactionSchema(BaseModel):
    """Схема банковской транзакции"""
    transaction_id: Optional[str] = Field(None, description="ID транзакции")
    account_id: str = Field(..., description="ID счета")
    amount: Optional[float] = Field(None, description="Сумма транзакции")
    currency: Optional[str] = Field(None, description="Валюта")
    transaction_type: Optional[str] = Field(None, description="Тип транзакции")
    booking_date: Optional[datetime] = Field(None, description="Дата транзакции")
    value_date: Optional[datetime] = Field(None, description="Дата валютирования")
    remittance_information: Optional[str] = Field(None, description="Назначение платежа")
    creditor_name: Optional[str] = Field(None, description="Имя получателя")
    creditor_account: Optional[str] = Field(None, description="Счет получателя")
    debtor_name: Optional[str] = Field(None, description="Имя плательщика")
    debtor_account: Optional[str] = Field(None, description="Счет плательщика")
    
    class Config:
        from_attributes = True


class GetBankAccountsResponse(BaseModel):
    """Ответ на запрос списка счетов"""
    success: bool = Field(..., description="Успешность операции")
    accounts: List[BankAccountSchema] = Field(default_factory=list, description="Список счетов")
    consent_id: Optional[str] = Field(None, description="ID согласия")
    auto_approved: Optional[bool] = Field(None, description="Автоматически одобрено")
    
    class Config:
        from_attributes = True


class GetBankTransactionsResponse(BaseModel):
    """Ответ на запрос транзакций"""
    success: bool = Field(..., description="Успешность операции")
    account_id: str = Field(..., description="ID счета")
    transactions: List[BankTransactionSchema] = Field(default_factory=list, description="Список транзакций")
    total_count: int = Field(..., description="Общее количество транзакций")
    
    class Config:
        from_attributes = True


class GetBankBalanceHistoryResponse(BaseModel):
    """Ответ на запрос истории балансов"""
    success: bool = Field(..., description="Успешность операции")
    account_id: str = Field(..., description="ID счета")
    balances: List[BankBalanceSchema] = Field(default_factory=list, description="История балансов")
    
    class Config:
        from_attributes = True
</file>

<file path="app/counterparty_router.py">
"""
Роутер для управления контрагентами
"""
from fastapi import APIRouter, HTTPException, status, Depends, Query, Body
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from pydantic import BaseModel

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.counterparty_service import counterparty_service

router = APIRouter(prefix="/api/v1/counterparties", tags=["Counterparties"])


class CreateCounterpartyRequest(BaseModel):
    name: str
    type: str  # customer, supplier, other
    inn: Optional[str] = None
    kpp: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    account_number: Optional[str] = None
    bank_name: Optional[str] = None
    bic: Optional[str] = None
    correspondent_account: Optional[str] = None
    notes: Optional[str] = None


class UpdateCounterpartyRequest(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    inn: Optional[str] = None
    kpp: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    account_number: Optional[str] = None
    bank_name: Optional[str] = None
    bic: Optional[str] = None
    correspondent_account: Optional[str] = None
    notes: Optional[str] = None
    is_active: Optional[bool] = None


@router.post("")
async def create_counterparty(
    request: CreateCounterpartyRequest,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Создать контрагента
    
    **Параметры:**
    - **name**: Название контрагента
    - **type**: Тип (customer, supplier, other)
    - **inn**: ИНН
    - **kpp**: КПП
    - **email**: Email
    - **phone**: Телефон
    - **account_number**: Номер счета
    - **bank_name**: Название банка
    - **bic**: БИК
    - **correspondent_account**: Корреспондентский счет
    - **notes**: Заметки
    """
    try:
        result = await counterparty_service.create_counterparty(
            db=db,
            user_id=user_id,
            name=request.name,
            type=request.type,
            inn=request.inn,
            kpp=request.kpp,
            email=request.email,
            phone=request.phone,
            account_number=request.account_number,
            bank_name=request.bank_name,
            bic=request.bic,
            correspondent_account=request.correspondent_account,
            notes=request.notes
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to create counterparty")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("")
async def list_counterparties(
    type: Optional[str] = Query(None, description="Фильтр по типу (customer, supplier, other)"),
    search: Optional[str] = Query(None, description="Поиск по названию"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить список контрагентов
    
    **Параметры:**
    - **type**: Фильтр по типу
    - **search**: Поиск по названию
    """
    try:
        result = await counterparty_service.list_counterparties(
            db=db,
            user_id=user_id,
            type=type,
            search=search
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to list counterparties")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/{counterparty_id}")
async def get_counterparty(
    counterparty_id: int,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить контрагента с деталями и статистикой
    
    **Параметры:**
    - **counterparty_id**: ID контрагента
    """
    try:
        result = await counterparty_service.get_counterparty(
            db=db,
            user_id=user_id,
            counterparty_id=counterparty_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=result.get("error", "Counterparty not found")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.put("/{counterparty_id}")
async def update_counterparty(
    counterparty_id: int,
    request: UpdateCounterpartyRequest,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Обновить данные контрагента
    
    **Параметры:**
    - **counterparty_id**: ID контрагента
    - Все остальные поля опциональны
    """
    try:
        update_data = {k: v for k, v in request.dict().items() if v is not None}
        
        result = await counterparty_service.update_counterparty(
            db=db,
            user_id=user_id,
            counterparty_id=counterparty_id,
            **update_data
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to update counterparty")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/from-transaction/{transaction_id}")
async def create_counterparty_from_transaction(
    transaction_id: int,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Автоматически создать контрагента из транзакции
    
    **Параметры:**
    - **transaction_id**: ID транзакции
    """
    try:
        result = await counterparty_service.auto_create_from_transaction(
            db=db,
            user_id=user_id,
            transaction_id=transaction_id
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to create counterparty from transaction")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
</file>

<file path="app/database.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from app.config import get_settings

settings = get_settings()

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=True,
    pool_size=20,
    max_overflow=0
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session
</file>

<file path="app/predictions_router.py">
"""
Роутер для ML-прогнозов денежных потоков
"""
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from datetime import datetime

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.ml_prediction_service import ml_prediction_service

router = APIRouter(prefix="/api/v1/predictions", tags=["Cash Flow Predictions"])


@router.get("/cash-flow")
async def predict_cash_flow(
    weeks_ahead: int = Query(4, ge=1, le=12, description="На сколько недель вперед прогнозировать"),
    prediction_date: Optional[str] = Query(None, description="Дата начала прогноза (YYYY-MM-DD)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Прогнозировать денежный поток на несколько недель вперед
    
    **Параметры:**
    - **weeks_ahead**: На сколько недель вперед прогнозировать (1-12, по умолчанию 4)
    - **prediction_date**: Дата начала прогноза (по умолчанию - сейчас)
    
    **Возвращает:**
    - Прогнозы на каждую неделю с вероятностью кассовых разрывов
    """
    try:
        prediction_date_dt = None
        if prediction_date:
            prediction_date_dt = datetime.fromisoformat(prediction_date)
        
        result = await ml_prediction_service.predict_cash_flow(
            db=db,
            user_id=user_id,
            weeks_ahead=weeks_ahead,
            prediction_date=prediction_date_dt
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to generate prediction")
            )
        
        return result
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid date format: {str(e)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/cash-flow-gaps")
async def get_cash_flow_gaps(
    weeks_ahead: int = Query(4, ge=1, le=12, description="На сколько недель вперед проверять"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить прогноз кассовых разрывов
    
    **Параметры:**
    - **weeks_ahead**: На сколько недель вперед проверять (1-12, по умолчанию 4)
    
    **Возвращает:**
    - Список потенциальных кассовых разрывов с вероятностью и размером
    """
    try:
        result = await ml_prediction_service.get_cash_flow_gaps(
            db=db,
            user_id=user_id,
            weeks_ahead=weeks_ahead
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to get cash flow gaps")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
</file>

<file path="app/sync_router.py">
"""
Роутер для синхронизации данных из банков
"""
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.data_aggregation_service import data_aggregation_service

router = APIRouter(prefix="/api/v1/sync", tags=["Data Synchronization"])


@router.post("/accounts")
async def sync_accounts(
    bank_code: Optional[str] = Query(None, description="Код банка (если не указано - все банки)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Синхронизировать счета из банков
    
    **Параметры:**
    - **bank_code**: Код банка (vbank, abank, sbank) или все банки
    """
    try:
        result = await data_aggregation_service.sync_user_accounts(
            db=db,
            user_id=user_id,
            bank_code=bank_code
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to sync accounts")
            )
        
        return result
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/transactions")
async def sync_transactions(
    account_id: Optional[int] = Query(None, description="ID счета (если не указано - все счета)"),
    days_back: int = Query(90, ge=1, le=365, description="За сколько дней назад получать транзакции"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Синхронизировать транзакции из банков
    
    **Параметры:**
    - **account_id**: ID счета (если не указано - все активные счета)
    - **days_back**: За сколько дней назад получать транзакции (1-365, по умолчанию 90)
    """
    try:
        if account_id:
            # Синхронизируем конкретный счет
            from app.models import BankAccount, BankConsent
            
            account = await db.get(BankAccount, account_id)
            if not account or account.user_id != user_id:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Account not found"
                )
            
            # Получаем согласие
            from sqlalchemy import select, and_
            stmt = select(BankConsent).where(
                and_(
                    BankConsent.user_id == user_id,
                    BankConsent.bank_code == account.bank_code,
                    BankConsent.status == "approved"
                )
            ).order_by(BankConsent.created_at.desc())
            
            result = await db.execute(stmt)
            consent = result.scalar_one_or_none()
            
            if not consent:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="No active consent for this bank"
                )
            
            sync_result = await data_aggregation_service.sync_account_transactions(
                db=db,
                user_id=user_id,
                account_id=account_id,
                bank_code=account.bank_code,
                consent_id=consent.consent_id,
                days_back=days_back
            )
            
            if not sync_result.get("success"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=sync_result.get("error", "Failed to sync transactions")
                )
            
            return sync_result
        else:
            # Синхронизируем все счета
            result = await data_aggregation_service.sync_all_accounts_transactions(
                db=db,
                user_id=user_id,
                days_back=days_back
            )
            
            if not result.get("success"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=result.get("error", "Failed to sync transactions")
                )
            
            return result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/all")
async def sync_all(
    days_back: int = Query(90, ge=1, le=365, description="За сколько дней назад получать транзакции"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Полная синхронизация: счета + транзакции
    
    **Параметры:**
    - **days_back**: За сколько дней назад получать транзакции (1-365, по умолчанию 90)
    """
    try:
        # Синхронизируем счета
        accounts_result = await data_aggregation_service.sync_user_accounts(
            db=db,
            user_id=user_id
        )
        
        # Синхронизируем транзакции
        transactions_result = await data_aggregation_service.sync_all_accounts_transactions(
            db=db,
            user_id=user_id,
            days_back=days_back
        )
        
        return {
            "success": True,
            "accounts": accounts_result,
            "transactions": transactions_result
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
</file>

<file path="docker/docker.sh">
#!/bin/bash

# Unified Docker Management Script
# Usage: ./docker.sh [command] [options]
# Commands: start, stop, restart, logs, rebuild, status, clean

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Change to project root
cd "$PROJECT_ROOT"

# Docker compose files
COMPOSE_DEV="docker-compose.yml"
COMPOSE_PROD="docker-compose.prod.yml"

# Function to check if Docker is running
check_docker() {
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}❌ Error: Docker is not running. Please start Docker and try again.${NC}"
        exit 1
    fi
}

# Function to check if .env exists
check_env() {
    if [ ! -f .env ]; then
        if [ "$1" = "prod" ]; then
            echo -e "${RED}❌ Error: .env file not found. Please create it from env.example${NC}"
            exit 1
        else
            echo -e "${YELLOW}⚠️  Warning: .env file not found. Creating from env.example...${NC}"
            cp env.example .env
            echo -e "${GREEN}✅ Created .env file. Please update it with your configuration.${NC}"
        fi
    fi
}

# Function to detect which compose file is active
detect_compose_file() {
    if docker compose ps 2>/dev/null | grep -q "Up"; then
        echo "$COMPOSE_DEV"
    elif docker compose -f "$COMPOSE_PROD" ps 2>/dev/null | grep -q "Up"; then
        echo "$COMPOSE_PROD"
    else
        echo ""
    fi
}

# Function to get compose command
get_compose_cmd() {
    local env=${1:-dev}
    if [ "$env" = "prod" ]; then
        echo "docker compose -f $COMPOSE_PROD"
    else
        echo "docker compose"
    fi
}

# Start services
start_services() {
    local env=${1:-dev}
    local compose_cmd=$(get_compose_cmd "$env")
    
    check_docker
    check_env "$env"
    
    echo -e "${BLUE}🚀 Starting ${env} environment...${NC}"
    echo ""
    
    echo -e "${BLUE}🔨 Building and starting containers...${NC}"
    $compose_cmd up -d --build
    
    # Wait for services
    echo ""
    echo -e "${BLUE}⏳ Waiting for services to be ready...${NC}"
    sleep $([ "$env" = "prod" ] && echo "10" || echo "5")
    
    # Show status
    echo ""
    echo -e "${BLUE}📊 Service Status:${NC}"
    $compose_cmd ps
    
    echo ""
    echo -e "${GREEN}✅ ${env} environment started!${NC}"
    echo ""
    
    if [ "$env" = "dev" ]; then
        echo -e "${BLUE}📍 Access points:${NC}"
        echo "   Frontend:  http://localhost:5173"
        echo "   Backend:   http://localhost:8000"
        echo "   API Docs:  http://localhost:8000/docs"
        echo "   PostgreSQL: localhost:5434"
        echo "   Redis:     localhost:6381"
    else
        echo -e "${BLUE}📍 Access points:${NC}"
        echo "   Frontend:  http://localhost:3000"
        echo "   Backend:   http://localhost:8000"
        echo "   API Docs:  http://localhost:8000/docs"
    fi
    
    echo ""
    echo -e "${BLUE}📝 Useful commands:${NC}"
    echo "   View logs:     ./docker.sh logs [service]"
    echo "   Stop services: ./docker.sh stop"
    echo "   Status:        ./docker.sh status"
    echo ""
}

# Stop services
stop_services() {
    check_docker
    
    local active_file=$(detect_compose_file)
    
    if [ -z "$active_file" ]; then
        echo -e "${YELLOW}No running services found.${NC}"
        exit 0
    fi
    
    local compose_cmd
    if [ "$active_file" = "$COMPOSE_PROD" ]; then
        compose_cmd=$(get_compose_cmd "prod")
        echo -e "${BLUE}🛑 Stopping production environment...${NC}"
    else
        compose_cmd=$(get_compose_cmd "dev")
        echo -e "${BLUE}🛑 Stopping development environment...${NC}"
    fi
    
    $compose_cmd down
    
    echo ""
    echo -e "${GREEN}✅ All services stopped!${NC}"
    echo ""
    echo -e "${BLUE}💡 To remove volumes (database data), use:${NC}"
    echo "   ./docker.sh clean"
    echo ""
}

# Restart services
restart_services() {
    local service=$1
    check_docker
    
    local active_file=$(detect_compose_file)
    
    if [ -z "$active_file" ]; then
        echo -e "${YELLOW}No running services found. Starting development environment...${NC}"
        start_services "dev"
        return
    fi
    
    local compose_cmd
    if [ "$active_file" = "$COMPOSE_PROD" ]; then
        compose_cmd=$(get_compose_cmd "prod")
    else
        compose_cmd=$(get_compose_cmd "dev")
    fi
    
    if [ -z "$service" ]; then
        echo -e "${BLUE}🔄 Restarting all services...${NC}"
        $compose_cmd restart
    else
        echo -e "${BLUE}🔄 Restarting service: $service${NC}"
        $compose_cmd restart "$service"
    fi
    
    echo ""
    echo -e "${GREEN}✅ Restart complete!${NC}"
    echo ""
    $compose_cmd ps
}

# View logs
view_logs() {
    local service=$1
    check_docker
    
    local active_file=$(detect_compose_file)
    
    if [ -z "$active_file" ]; then
        echo -e "${YELLOW}No running services found.${NC}"
        exit 1
    fi
    
    local compose_cmd
    if [ "$active_file" = "$COMPOSE_PROD" ]; then
        compose_cmd=$(get_compose_cmd "prod")
    else
        compose_cmd=$(get_compose_cmd "dev")
    fi
    
    if [ -z "$service" ]; then
        echo -e "${BLUE}📋 Showing logs for all services...${NC}"
        echo -e "${BLUE}   Use: ./docker.sh logs [service_name] to view specific service${NC}"
        echo -e "${BLUE}   Available services: frontend, app, postgres, redis${NC}"
        echo ""
        $compose_cmd logs -f
    else
        echo -e "${BLUE}📋 Showing logs for: $service${NC}"
        echo ""
        $compose_cmd logs -f "$service"
    fi
}

# Rebuild services
rebuild_services() {
    local service=$1
    local env=${2:-dev}
    check_docker
    
    local compose_cmd=$(get_compose_cmd "$env")
    
    if [ -z "$service" ]; then
        echo -e "${BLUE}🔨 Rebuilding all services...${NC}"
        $compose_cmd up -d --build
    else
        echo -e "${BLUE}🔨 Rebuilding service: $service${NC}"
        $compose_cmd up -d --build "$service"
    fi
    
    echo ""
    echo -e "${GREEN}✅ Rebuild complete!${NC}"
    echo ""
    $compose_cmd ps
}

# Show status
show_status() {
    check_docker
    
    echo -e "${BLUE}📊 Service Status:${NC}"
    echo ""
    
    # Check dev
    if docker compose ps 2>/dev/null | grep -q "Up"; then
        echo -e "${GREEN}Development Environment:${NC}"
        docker compose ps
        echo ""
    fi
    
    # Check prod
    if docker compose -f "$COMPOSE_PROD" ps 2>/dev/null | grep -q "Up"; then
        echo -e "${GREEN}Production Environment:${NC}"
        docker compose -f "$COMPOSE_PROD" ps
        echo ""
    fi
    
    if ! docker compose ps 2>/dev/null | grep -q "Up" && ! docker compose -f "$COMPOSE_PROD" ps 2>/dev/null | grep -q "Up"; then
        echo -e "${YELLOW}No services are currently running.${NC}"
        echo ""
        echo "Start services with:"
        echo "   ./docker.sh start        # Development"
        echo "   ./docker.sh start prod   # Production"
    fi
}

# Clean (remove volumes)
clean_volumes() {
    check_docker
    
    local active_file=$(detect_compose_file)
    
    if [ -z "$active_file" ]; then
        echo -e "${YELLOW}No running services found. Cleaning all volumes...${NC}"
        docker compose down -v 2>/dev/null || true
        docker compose -f "$COMPOSE_PROD" down -v 2>/dev/null || true
    else
        local compose_cmd
        if [ "$active_file" = "$COMPOSE_PROD" ]; then
            compose_cmd=$(get_compose_cmd "prod")
        else
            compose_cmd=$(get_compose_cmd "dev")
        fi
        
        echo -e "${YELLOW}⚠️  Warning: This will remove all volumes including database data!${NC}"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            $compose_cmd down -v
            echo -e "${GREEN}✅ Volumes removed!${NC}"
        else
            echo -e "${BLUE}Cancelled.${NC}"
        fi
    fi
}

# Show help
show_help() {
    echo -e "${BLUE}Docker Management Script${NC}"
    echo ""
    echo "Usage: ./docker.sh [command] [options]"
    echo ""
    echo "Commands:"
    echo "  start [dev|prod]     Start services (default: dev)"
    echo "  stop                 Stop all running services"
    echo "  restart [service]    Restart all services or specific service"
    echo "  logs [service]       View logs (all services or specific service)"
    echo "  rebuild [service]    Rebuild services (default: dev)"
    echo "  status               Show status of all services"
    echo "  clean                Remove volumes (database data)"
    echo "  help                 Show this help message"
    echo ""
    echo "Examples:"
    echo "  ./docker.sh start              # Start development environment"
    echo "  ./docker.sh start prod         # Start production environment"
    echo "  ./docker.sh logs               # View all logs"
    echo "  ./docker.sh logs app           # View app logs"
    echo "  ./docker.sh rebuild frontend    # Rebuild frontend service"
    echo "  ./docker.sh restart            # Restart all services"
    echo "  ./docker.sh restart app        # Restart app service"
    echo "  ./docker.sh status             # Show service status"
    echo "  ./docker.sh stop               # Stop all services"
    echo "  ./docker.sh clean              # Remove volumes"
    echo ""
}

# Main command handler
case "${1:-help}" in
    start)
        start_services "${2:-dev}"
        ;;
    stop)
        stop_services
        ;;
    restart)
        restart_services "$2"
        ;;
    logs)
        view_logs "$2"
        ;;
    rebuild)
        rebuild_services "$2" "${3:-dev}"
        ;;
    status)
        show_status
        ;;
    clean)
        clean_volumes
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo ""
        show_help
        exit 1
        ;;
esac
</file>

<file path="docker/README.md">
# Docker Management

This directory contains unified Docker management scripts for the VTB API Hack project.

## Quick Start

From the project root, use the unified Docker script:

```bash
./docker.sh [command] [options]
```

Or directly:

```bash
./docker/docker.sh [command] [options]
```

## Available Commands

### Start Services

```bash
# Start development environment (default)
./docker.sh start
# or
./docker.sh start dev

# Start production environment
./docker.sh start prod
```

### Stop Services

```bash
./docker.sh stop
```

### View Logs

```bash
# View all logs
./docker.sh logs

# View specific service logs
./docker.sh logs app
./docker.sh logs frontend
./docker.sh logs postgres
./docker.sh logs redis
```

### Rebuild Services

```bash
# Rebuild all services (dev)
./docker.sh rebuild

# Rebuild specific service
./docker.sh rebuild frontend
./docker.sh rebuild app

# Rebuild for production
./docker.sh rebuild frontend prod
```

### Restart Services

```bash
# Restart all services
./docker.sh restart

# Restart specific service
./docker.sh restart app
```

### Check Status

```bash
./docker.sh status
```

### Clean Volumes

```bash
# Remove all volumes (including database data)
./docker.sh clean
```

## Service Access Points

### Development Environment

- **Frontend**: http://localhost:5173
- **Backend API**: http://localhost:8000
- **API Documentation**: http://localhost:8000/docs
- **PostgreSQL**: localhost:5434
- **Redis**: localhost:6381

### Production Environment

- **Frontend**: http://localhost:3000
- **Backend API**: http://localhost:8000
- **API Documentation**: http://localhost:8000/docs

## Troubleshooting

### Services won't start

1. Check Docker is running: `docker info`
2. Check logs: `./docker.sh logs`
3. Rebuild services: `./docker.sh rebuild`

### Database issues

1. Check postgres logs: `./docker.sh logs postgres`
2. Clean and restart: `./docker.sh clean && ./docker.sh start`

### Port conflicts

If ports are already in use, check what's using them:

```bash
# macOS/Linux
lsof -i :8000
lsof -i :5173
lsof -i :5434
```

### Reset everything

```bash
./docker.sh stop
./docker.sh clean
./docker.sh start
```

## File Structure

```
docker/
├── docker.sh          # Unified Docker management script
└── README.md          # This file

# Docker compose files (in project root)
├── docker-compose.yml      # Development configuration
└── docker-compose.prod.yml # Production configuration

# Dockerfiles
├── Dockerfile              # Backend Dockerfile
└── frontend/
    ├── Dockerfile          # Frontend production Dockerfile
    └── Dockerfile.dev      # Frontend development Dockerfile
```
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/BankAccountList/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.bankCard {
  @include glass-card(false);
  border: 2px solid $glass-border;
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

}

.bankCardHeader {
  gap: 0.75rem;
}

.headerGroup {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.headerIconBg {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius;
  background-color: rgba($accent, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.headerIcon {
  height: 1.25rem;
  width: 1.25rem;
  color: $accent;
}

.bankCardTitle {
  font-weight: 700;
}

.bankCardSubtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.bankCardContent {
  padding-top: 0.5rem;
}

.accountList {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}


.accountItem {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1.25rem; 
  border-radius: $radius * 1.2;
  border: 1px solid rgba($border, 0.5);
  background-color: rgba($secondary, 0.3);
  transition: all 0.3s ease;

  &:hover {
    background-color: rgba($secondary, 0.5);
    border-color: rgba($accent, 0.3);
  }
}

.itemDetails {
  display: flex;
  align-items: center;
  gap: 1rem;
}


.itemIconBg {
  height: 3rem;
  width: 3rem;
  flex-shrink: 0;
  border-radius: $radius;
  background-color: rgba($accent, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;

  .accountItem:hover & {
    background-color: rgba($accent, 0.3);
  }
}

.itemIcon {
  height: 1.5rem;
  width: 1.5rem;
  color: $accent;
}

.itemBank {
  font-weight: 700;
  color: $foreground;
  font-size: 1.125rem;
}

.itemSync {
  font-size: 0.75rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.itemBalance {
  text-align: right;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
}

.balanceAmount {
  font-size: 1.25rem;
  font-weight: 700;
  color: $foreground;
}

.statusBadge {
  background-color: rgba($accent, 0.2);
  color: $accent;
  border-color: rgba($accent, 0.3);
  &:hover {
    background-color: rgba($accent, 0.3);
  }
}
</file>

<file path="frontend/src/components/CashFlowChart/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.chartCard {
  @include glass-card(false);
  // border: 2px solid rgba($primary, 0.2);
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

//   &:hover {
//     border-color: rgba($primary, 0.4);
//     box-shadow: $shadow-medium, 0 0 40px rgba($primary, 0.2);
//     transform: translateY(-2px);
//   }
}

.chartCardHeader {
  gap: 0.75rem;
}

.headerGroup {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.headerIconBg {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius;
  background-color: rgba($primary, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.headerIcon {
  height: 1.25rem;
  width: 1.25rem;
  color: $primary;
}

.chartCardTitle {
  font-weight: 700;
}

.chartCardSubtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.25rem;
}

.chartCardContent {
  padding-top: 0.5rem;
}

.legend {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  margin-top: 1.5rem;
}

.legendItem {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.legendDot {
  width: 1rem;
  height: 1rem;
  border-radius: $radius-sm;
  
  box-shadow: 0 0 8px rgba($primary, 0.5);
}

.dotActual {
  background-color: $primary;
  box-shadow: 0 0 8px rgba($primary, 0.5);
}

.dotPredicted {
  background-color: $accent;
  box-shadow: 0 0 8px rgba($accent, 0.5);
}

.legendLabel {
  font-size: 0.875rem;
  font-weight: 600;
  color: $muted-foreground;
}
</file>

<file path="frontend/src/components/CashFlowChart/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { TrendingUp } from "lucide-react";
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
  ReferenceLine,
} from "recharts";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getCashFlowPredictions } from "../../utils/api";
import styles from "./index.module.scss";
import {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
  primaryHslParts,
  accentHslParts,
} from "../../styles/colors";

// Утилита для создания HSL-цвета для Recharts (требуется для градиентов)
const getHslColor = (h: string, s: string, l: string) => `hsl(${h}, ${s}, ${l})`;

export default function CashFlowChart() {
  const { isAuthenticated } = useAuth();
  const [data, setData] = useState<Array<{ date: string; actual: number | null; predicted: number | null }>>([]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!isAuthenticated) {
      setData([]);
      return;
    }

    const fetchPredictions = async () => {
      try {
        setIsLoading(true);
        const response = await getCashFlowPredictions(4);
        if (response.data.success && response.data.predictions) {
          const chartData = response.data.predictions.map((p) => ({
            date: new Date(p.prediction_date).toLocaleDateString("ru-RU", {
              day: "2-digit",
              month: "short",
            }),
            actual: null,
            predicted: p.predicted_balance,
          }));
          setData(chartData);
        }
      } catch (err) {
        console.error("Error fetching cash flow predictions:", err);
        setData([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchPredictions();
  }, [isAuthenticated]);

  const primaryHslString = getHslColor(primaryHslParts[0], primaryHslParts[1], primaryHslParts[2]);
  const accentHslString = getHslColor(accentHslParts[0], accentHslParts[1], accentHslParts[2]);
  const RefLine = ReferenceLine;
  
  const hasData = data.length > 0;
  
  return (
    <Card className={styles.chartCard}>
      <CardHeader className={styles.chartCardHeader}>
        <div className={styles.headerGroup}>
          <div className={styles.headerIconBg}>
            <TrendingUp className={styles.headerIcon} />
          </div>
          <div>
            <CardTitle className={styles.chartCardTitle}>Cash Flow прогноз</CardTitle>
            <p className={styles.chartCardSubtitle}>
              {hasData ? "Наши предсказания баланса на следующие 4 недели" : "Подключите счета для просмотра прогноза"}
            </p>
          </div>
        </div>
      </CardHeader>
      <CardContent className={styles.chartCardContent}>
        {isLoading ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка прогноза...</p>
          </div>
        ) : !hasData ? (
          <div style={{ padding: "2rem", textAlign: "center", color: muted_foreground }}>
            <p>Нет данных для отображения</p>
            <p style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
              Подключите банковские счета, чтобы увидеть прогноз денежного потока
            </p>
          </div>
        ) : (
        <ResponsiveContainer width="100%" height={320}>
          <AreaChart data={data} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
            <defs>
              {/* Используем SCSS-переменные в SVG-градиентах */}
              <linearGradient id="colorActual" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={primaryHslString} stopOpacity={0.4} />
                <stop offset="95%" stopColor={primaryHslString} stopOpacity={0.05} />
              </linearGradient>
              <linearGradient id="colorPredicted" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={accentHslString} stopOpacity={0.4} />
                <stop offset="95%" stopColor={accentHslString} stopOpacity={0.05} />
              </linearGradient>
            </defs>
            <CartesianGrid strokeDasharray="3 3" stroke={border} opacity={0.3} />
            <XAxis
              dataKey="date"
              stroke={muted_foreground}
              fontSize={12}
              tickLine={false}
              axisLine={{ stroke: border }}
            />
            <YAxis
              stroke={muted_foreground}
              fontSize={12}
              tickLine={false}
              axisLine={{ stroke: border }}
            />
            <Tooltip
              contentStyle={{
                backgroundColor: popover,
                border: `1px solid ${border}`,
                borderRadius: "12px",
                backdropFilter: "blur(12px)",
              }}
              formatter={(value: number) => [`₽${value.toLocaleString()}`, ""]}
            />
            <RefLine y={0} stroke={danger} strokeDasharray="5 5" strokeWidth={2} />
            <Area
              type="monotone"
              dataKey="actual"
              stroke={primary}
              strokeWidth={3}
              fillOpacity={1}
              fill="url(#colorActual)"
              name="Actual"
              dot={{ fill: primary, r: 4 }}
              />
            <Area
              type="monotone"
              dataKey="predicted"
              stroke={accent}
              strokeWidth={3}
              strokeDasharray="8 4"
              fillOpacity={1}
              fill="url(#colorPredicted)"
              name="Predicted"
              dot={{ fill: accent, r: 4 }}
            />
          </AreaChart>
        </ResponsiveContainer>
        )}
        {hasData && <div className={styles.legend}>
          <div className={styles.legendItem}>
            <div className={`${styles.legendDot} ${styles.dotActual}`} />
            <span className={styles.legendLabel}>Баланс</span>
          </div>
          <div className={styles.legendItem}>
            <div className={`${styles.legendDot} ${styles.dotPredicted}`} />
            <span className={styles.legendLabel}>Наш прогноз</span>
          </div>
        </div>}
      </CardContent>
    </Card>
  );
}
</file>

<file path="frontend/src/components/Layout/index.module.scss">
/* Файл: src/styles/sidebar.module.scss */
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.root {
  min-height: 100vh;
  background-color: $background;
  display: block;
}

/* Desktop floating sidebar */
.sidebar {
  display: none;
}

@media (min-width: 1024px) {
  .sidebar {
    display: block;
    position: fixed;
    left: 1.5rem; 
    top: 1.5rem; 
    bottom: 1.5rem; 
    width: 5rem; 
    z-index: 50;
    pointer-events: auto;
  }

  .sidebarInner {
    @include glass-card();
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    padding: 2rem 0;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    border-radius: $radius;
  }

  .brandLink {
    height: 3rem;
    width: 3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: $radius-md;
    background: $gradient-primary;
  }

  .nav {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1 1 auto;
    gap: 0.75rem;
    width: 100%;
  }

  .navItem {
    position: relative;
    height: 3rem;
    width: 3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: $radius-md;
    transition: $transition-smooth;
    color: $muted-foreground;
  }

  .navItemActive {
    background: $primary;
    color: $primary-foreground;
    box-shadow: $shadow-glow;
  }

  .tooltip {
    position: absolute;
    left: 100%;
    margin-left: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: $popover;
    color: $popover-foreground;
    font-size: 0.875rem;
    font-weight: 600;
    border-radius: $radius-md;
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
    white-space: nowrap;
    box-shadow: $shadow-medium;
  }

  .navItem:hover .tooltip {
    opacity: 1;
    pointer-events: auto;
  }
}

/* Mobile header */
.mobileHeader {
  display: block;
}

@media (min-width: 1024px) {
  .mobileHeader {
    display: none;
  }
}

.mobileBar {
  position: fixed;
  left: 0;
  right: 0;
  top: 1rem;
  z-index: 40;
  padding: 0 1rem;
  pointer-events: none; /* Позволяем кликам проходить через пустые области */
}

.mobileInner {
  @include glass-card();
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 4rem;
  padding: 0 1rem;
  border-radius: $radius;
  margin: 0 auto;
  max-width: calc(100% - 2rem); 
  pointer-events: auto;
}

.brandRow {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.brandSmall {
  height: 2rem;
  width: 2rem;
  border-radius: $radius-sm;
  display: flex;
  align-items: center;
  justify-content: center;
  background: $gradient-primary;
}

.mobilePanelOverlay {
  position: fixed;
  inset: 0;
  background: rgba($background, 0.6);
  backdrop-filter: blur(6px);
  z-index: 50;
  animation: fadeIn 0.2s ease-out;
}

.mobilePanel {
  @include glass-card();
  position: fixed;
  top: 1rem;
  bottom: 1rem;
  left: 1rem;
  right: 1rem;
  max-width: calc(100% - 2rem);
  max-height: calc(100% - 2rem);
  z-index: 60;
  border-radius: $radius;
  padding: 2rem;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  animation: slideUp 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0; 
    transform: translateY(20px);
  }
  to { 
    opacity: 1; 
    transform: translateY(0);
  }
}


.menuCloseRow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1.5rem;
}

.navList {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.navListItem a {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem 1rem;
  border-radius: $radius-md;
  font-weight: 700;
  text-decoration: none;
  color: $foreground;
}

.navListItem a:hover {
  background: rgba($foreground, 0.02);
}

.main {
  padding-left: 0;
}

@media (min-width: 1024px) {
  .main {
    padding-left: 8rem;
    padding-top: 0;
  }
}

.contentWrap {
  padding: 1.5rem 1.25rem;
  max-width: 1600px;
  margin: 0 auto;
}

.btn {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius-md;
  background: transparent;
  border: none;
  color: $foreground;
  transition: all 0.2s ease;
  cursor: pointer;
  
  &:hover {
    background: rgba($foreground, 0.1);
  }
}
</file>

<file path="frontend/src/components/Layout/index.tsx">
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import {
  LayoutDashboard,
  TrendingUp,
  Heart,
  Users,
  Calendar,
  Settings,
  Menu,
  X,
  Sparkles,
  CircleUser
} from "lucide-react";
import cn from "classnames"
import styles from "./index.module.scss";

const navigation = [
  { name: "Dashboard", href: "/", icon: LayoutDashboard },
  { name: "Cash Flow", href: "/cash-flow", icon: TrendingUp },
  { name: "Health", href: "/health", icon: Heart },
  { name: "Receivables", href: "/receivables", icon: Users },
  { name: "Payments", href: "/payments", icon: Calendar },
  { name: "Settings", href: "/settings", icon: Settings },
];

export default function Layout({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <div className={styles.root}>
      <aside className={styles.sidebar}>
        <div className={styles.sidebarInner}>
          <Link to="/" className={styles.brandLink} title="FinFlow">
            <Sparkles />
          </Link>
          {/* <Link to="/login" className={styles.brandLink} title="auth">
            <CircleUser />
          </Link> */}
          <nav className={styles.nav} aria-label="Primary">
            {navigation.map((item) => {
              const isActive = location.pathname === item.href;
              const Icon = item.icon;
              return (
                <Link
                  key={item.name}
                  to={item.href}
                  className={cn(styles.navItem, isActive && styles.navItemActive)}
                  title={item.name}
                >
                  <Icon />
                  <div className={styles.tooltip}>{item.name}</div>
                </Link>
              );
            })}
          </nav>
        </div>
      </aside>

      {/* Mobile menu */}
      <div className={styles.mobileHeader}>
        <div className={styles.mobileBar}>
          <div className={styles.mobileInner}>
            <button
              type="button"
              className={styles.btn}
              onClick={() => setMobileMenuOpen(true)}
              aria-label="Open menu"
            >
              <Menu />
            </button>

            <div className={styles.brandRow}>
              <div className={styles.brandSmall}>
                <Sparkles className="h-4 w-4 text-primary-foreground" />
              </div>
              <span className={styles.appName}>FinFlow</span>
            </div>

            <div style={{ width: 40 }} />
          </div>
        </div>

        {mobileMenuOpen && (
          <div>
            <div className={styles.mobilePanelOverlay} onClick={() => setMobileMenuOpen(false)} />
            <div className={styles.mobilePanel} role="dialog" aria-modal="true">
              <div className={styles.menuCloseRow}>
                <div className={styles.brandRow}>
                  <div className={styles.brandSmall}>
                    <Sparkles className="h-5 w-5 text-primary-foreground" />
                  </div>
                  <span className={styles.appName}>FinFlow</span>
                </div>
                <button
                  onClick={() => setMobileMenuOpen(false)}
                  aria-label="Close menu"
                  className={styles.btn}
                >
                  <X />
                </button>
              </div>

              <nav className={styles.mobileNav}>
                <ul className={styles.navList}>
                  {navigation.map((item) => {
                    const isActive = location.pathname === item.href;
                    const Icon = item.icon;
                    return (
                      <li className={styles.navListItem} key={item.name}>
                        <Link
                          to={item.href}
                          onClick={() => setMobileMenuOpen(false)}
                          className={cn(styles.navListItemLink, isActive && styles.navItemActive)}
                        >
                          <Icon />
                          <span className={styles.navItemText}>{item.name}</span>
                        </Link>
                      </li>
                    );
                  })}
                </ul>
              </nav>
            </div>
          </div>
        )}
      </div>

      {/* Main content */}
      <main className={styles.main}>
        <div className={styles.contentWrap}>{children}</div>
      </main>
    </div>
  );
}
</file>

<file path="frontend/src/components/ReceivablesTable/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.header {
  display: flex;
  gap: 1rem;
  align-items: center;

  .headerText {
    text-align: center
  }
}

.iconBox {
  height: 2.5rem;
  width: 2.5rem;
  border-radius: $radius-md;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba($success, 0.2);
}

.title {
  font-size: 1.25rem;
  font-weight: 700;
}

.subtitle {
  margin-top: 0.25rem;
  font-size: 0.875rem;
  color: $muted-foreground;
}

.content {
  padding-top: 0.5rem;
}

.tableWrap {
  @include glass-card();
  border-radius: $radius;
  border: 1px solid rgba($border, 0.5);
  overflow: hidden;
}

.tableRow {
  transition: background-color 160ms ease;
}

.tableRowHover:hover {
  background: rgba($foreground, 0.02);
}

.counterparty {
  font-weight: 600;
}

.amount {
  font-weight: 700;
  font-size: 1.125rem;
}

.dueDate {
  font-weight: 500;
}

.actions {
  display: flex;
  gap: 0.5rem;
}

.badgePending {
  background: rgba($warning, 0.2);
  color: $warning;
  border: 1px solid rgba($warning, 0.3);
  font-weight: 700;
}

.badgeOverdue {
  background: rgba($danger, 0.2);
  color: $danger;
  border: 1px solid rgba($danger, 0.3);
  font-weight: 700;
}

.btnOutlineHover {
  transition: all 160ms ease;
}

.btnOutlineHover:hover {
  background: $primary;
  color: $primary-foreground;
  border-color: $primary;
}
</file>

<file path="frontend/src/components/StatCard/index.module.scss">
/* Файл: src/components/StatCard.module.scss */
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;
@use "sass:color";

@mixin variant-styles($color, $color-foreground) {
  border: 2px solid rgba($color, 0.2);
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

  &:hover {
    border-color: rgba($color, 0.4);
    box-shadow: $shadow-medium, 0 0 40px rgba($color, 0.2);
    transform: translateY(-2px);
  }

  .iconBg {
    background-color: $color;
    color: $color-foreground;
    box-shadow: 0 4px 12px rgba(color.adjust($color, $lightness: -20%), 0.4);
  }

  .trendPositive {
    background-color: rgba($success, 0.2);
    color: $success;
  }
  
  .trendNegative {
    background-color: rgba($danger, 0.2);
    color: $danger;
  }
}


.statCard {
  @include glass-card(false);
  
  &.default {
    @include variant-styles($primary, $primary-foreground);
  }
  &.success {
    @include variant-styles($success, $success-foreground);
  }
  &.warning {
    @include variant-styles($warning, $warning-foreground);
  }
  &.danger {
    @include variant-styles($danger, $danger-foreground);
  }
}


.cardContent {
  padding: 1.5rem;
}

.contentWrapper {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 1rem;
}

.textSection {
  flex: 1 1 0%;
  
  > *:not([hidden]) ~ *:not([hidden]) {
    margin-top: 0.75rem;
  }
}

.title {
  font-size: 0.875rem;
  font-weight: 600;
  color: $muted-foreground;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}


.value {
  font-size: 2.25rem;
  font-weight: 700;
  color: $foreground;
  text-shadow: 0 0 20px rgba($primary, 0.3);
}

.subtitle {
  font-size: 0.875rem;
  color: $muted-foreground;
}


.trendContainer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding-top: 0.5rem;
}


.trendBadge {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.875rem;
  font-weight: 700;
  padding: 0.25rem 0.5rem;
  border-radius: $radius-md;
}


.iconBg {
  border-radius: $radius * 1.25;
  padding: 1rem;
  flex-shrink: 0;
}

.icon {
  height: 1.75rem;
  width: 1.75rem;
}
</file>

<file path="frontend/src/components/StatCard/index.tsx">
import type { LucideIcon } from "lucide-react";
import { Card, CardContent } from "../../ui/card";
import cn from "classnames"
import styles from "./index.module.scss";

type Variant = "default" | "success" | "warning" | "danger";

interface StatCardProps {
  title: string;
  value: string;
  subtitle?: string;
  icon: LucideIcon;
  variant?: Variant;
  trend?: {
    value: string;
    isPositive: boolean;
  };
}

export default function StatCard({
  title,
  value,
  subtitle,
  icon: Icon,
  variant = "default",
  trend,
}: StatCardProps) {


  const trendClass = trend?.isPositive
    ? styles.trendPositive
    : styles.trendNegative;

  return (
    <Card className={cn(styles.statCard, styles[variant])}>
      <CardContent className={styles.cardContent}>
        <div className={styles.contentWrapper}>

          <div className={styles.textSection}>
            <p className={styles.title}>{title}</p>
            <p className={styles.value}>{value}</p>

            {subtitle && (
              <p className={styles.subtitle}>{subtitle}</p>
            )}

            {trend && (
              <div className={styles.trendContainer}>
                <span className={cn(styles.trendBadge, trendClass)}>
                  {trend.isPositive ? "↗" : "↘"} {trend.value}
                </span>
              </div>
            )}
          </div>

          <div className={styles.iconBg}>
            <Icon className={styles.icon} strokeWidth={2.5} />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="frontend/src/hooks/useAuth.ts">
import { useState, useEffect } from "react";
import { getCookie, eraseCookie } from "../utils/cookies";
import { getMe, type UserResponse } from "../utils/api";

export const useAuth = () => {
  const [user, setUser] = useState<UserResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    const checkAuth = async () => {
      const token = getCookie("access_token");
      if (!token) {
        setIsAuthenticated(false);
        setIsLoading(false);
        return;
      }

      try {
        const { data } = await getMe();
        setUser(data);
        setIsAuthenticated(true);
      } catch (error: any) {
        // Если ошибка 401 или 403, токен недействителен - очищаем состояние
        if (error?.response?.status === 401 || error?.response?.status === 403) {
          console.log("Token invalid or expired, clearing auth state");
          eraseCookie("access_token");
          eraseCookie("refresh_token");
        }
        console.error("Failed to get user:", error);
        setIsAuthenticated(false);
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  const refetch = async () => {
    const token = getCookie("access_token");
    if (!token) {
      setUser(null);
      setIsAuthenticated(false);
      return;
    }

    try {
      const { data } = await getMe();
      setUser(data);
      setIsAuthenticated(true);
    } catch (error) {
      console.error("Failed to refetch user:", error);
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  return { user, isLoading, isAuthenticated, refetch };
};
</file>

<file path="frontend/src/pages/Auth/AuthForm.module.scss">
@use "../../styles/vars" as *;

.authForm {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  width: 100%;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 1.25rem;

  h2 {
    font-size: 1.75rem;
    font-weight: 700;
    color: $foreground;
    text-align: center;
    margin-bottom: 0.5rem;
  }
}

.subtitle {
  color: $muted-foreground;
  text-align: center;
  font-size: 0.875rem;
  margin-top: -1rem;
  margin-bottom: 0.5rem;
}

.fieldGroup {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;

  label {
    font-weight: 600;
    font-size: 0.875rem;
    color: $muted-foreground;
  }

  input,
  select {
    width: 100%;
    background-color: $input;
    border: 1px solid $border;
    color: $foreground;
    border-radius: $radius-md;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    transition: all 0.2s ease;

    &:focus {
      outline: none;
      border-color: $primary;
      box-shadow: 0 0 0 2px rgba($primary, 0.3);
    }

    &.fieldError {
      border-color: #ef4444;
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
      
      &:focus {
        border-color: #ef4444;
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
      }
    }

    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-background-clip: text;
      -webkit-text-fill-color: $foreground;
      -webkit-box-shadow: 0 0 0px 1000px $input inset;
      box-shadow: 0 0 0px 1000px $input inset;
      transition: background-color 5000s ease-in-out 0s;
      border-color: $border;
    }
  }
}



.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  width: 100%;
  gap: 1rem;
}

.footer {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-top: 1rem;
}

.switchMode {
  color: $primary-light;
  text-decoration: none;

  &:hover {
    color: $foreground;
    text-decoration: none;
  }
}

.divider {
  display: flex;
  align-items: center;
  text-align: center;
  color: $muted-foreground;
  font-size: 0.75rem;
  font-weight: 600;

  &::before,
  &::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid $border;
  }

  span {
    padding: 0 1rem;
  }
}

.error {
  color: #ef4444;
  font-size: 0.8rem;
  margin-top: 4px;
  text-align: left;
  font-weight: 500;
  min-height: 1.2rem;
  display: block;
}

.loginButton {
  width: 100%;
  margin-top: 0.5rem;
}

.oauthSection {
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid $border;
}

.oauthTitle {
  text-align: center;
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-bottom: 1rem;
  font-weight: 600;
}

.oauthButtons {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.oauthButton {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}
</file>

<file path="frontend/src/pages/Auth/AuthForm.tsx">
/* eslint-disable @typescript-eslint/no-explicit-any */
import React, { useState } from "react";
import { Formik, Form, Field, ErrorMessage } from "formik";
import styles from "./AuthForm.module.scss";
import { Button } from "../../ui/button";
import { toast } from "sonner";
import * as api from "../../utils/api";
import { initiateBankOAuth } from "../../utils/api";
import { setCookie } from "../../utils/cookies";
import { zUserSignIn, zUserSignUp } from "../../utils/zod";
import { toFormikValidationSchema } from 'zod-formik-adapter';
import { Building2 } from "lucide-react";
import axios from "axios";

type View = "login" | "register" | "verify";

interface AuthFormProps {
  onClose: () => void;
}

export const AuthForm: React.FC<AuthFormProps> = ({ onClose }) => {
  const [view, setView] = useState<View>("login");
  
  const [phoneForVerify, setPhoneForVerify] = useState("");

  const handleLogin = async (values: any, { setSubmitting, setFieldError }: any) => {
    try {
      const { data } = await api.login(values.email, values.password);
      setCookie("access_token", data.access_token, 15 / (24 * 60));
      setCookie("refresh_token", data.refresh_token, 7);
      toast.success("Вход выполнен успешно!", {
        description: "Добро пожаловать!",
        duration: 1500,
      });
      onClose();
      // Обновляем страницу, чтобы хук useAuth сработал заново
      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (err: any) {
      console.error("❌ Ошибка входа:", err);
      
      let errorMessage = "Неверный email или пароль";
      let errorDescription = "Проверьте правильность введенных данных";
      
      if (axios.isAxiosError(err)) {
        if (err.response) {
          // Handle 401 Unauthorized specifically
          if (err.response.status === 401) {
            errorMessage = err.response.data?.detail || "Неверный email или пароль";
            errorDescription = "Проверьте правильность email и пароля";
            toast.error(errorMessage, {
              description: errorDescription,
              duration: 1500,
            });
          } else {
            const detail = err.response.data?.detail || err.response.data?.message;
            errorMessage = detail || errorMessage;
            toast.error(errorMessage, {
              description: "Попробуйте еще раз",
              duration: 5000,
            });
          }
          
          // Если есть ошибки валидации, показываем их в полях
          if (err.response.data?.errors && Array.isArray(err.response.data.errors)) {
            err.response.data.errors.forEach((error: any) => {
              const field = error.field || "";
              if (field.includes("email")) {
                setFieldError("email", error.message);
              }
              if (field.includes("password")) {
                setFieldError("password", error.message);
              }
            });
          }
        } else if (err.request) {
          errorMessage = "Ошибка сети";
          errorDescription = "Проверьте подключение к интернету или настройки сервера";
          toast.error(errorMessage, {
            description: errorDescription,
            duration: 1500,
          });
        } else {
          errorMessage = err.message || "Ошибка входа";
          toast.error(errorMessage, {
            description: "Попробуйте еще раз",
            duration: 5000,
          });
        }
      } else {
        toast.error(errorMessage, {
          description: errorDescription,
          duration: 5000,
        });
      }
    }
    setSubmitting(false);
  };

  const handleRegister = async (values: any, { setSubmitting, setFieldError }: any) => {
  try {
    await api.register({
      email: values.email,
      phone_number: values.phone,
      first_name: values.firstName,
      last_name: values.lastName,
      password: values.password,
    });
    
    // После успешной регистрации автоматически логиним пользователя
    toast.success("Регистрация успешна!", {
      description: "Выполняется автоматический вход...",
      duration: 1500,
    });
    
    try {
      const { data } = await api.login(values.email, values.password);
      setCookie("access_token", data.access_token, 15 / (24 * 60));
      setCookie("refresh_token", data.refresh_token, 7);
      toast.success("Добро пожаловать!", {
        description: "Ваш аккаунт успешно создан и активирован",
        duration: 1500,
      });
      onClose();
      // Обновляем страницу, чтобы хук useAuth сработал заново
      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (loginErr: any) {
      console.error("❌ Ошибка автоматического входа после регистрации:", loginErr);
      toast.error("Регистрация успешна, но не удалось войти", {
        description: "Пожалуйста, войдите вручную",
        duration: 1500,
      });
      setView("login");
    }
  } catch (err: any) {
    console.error("❌ Ошибка регистрации:", err);
    
    let errorMessage = "Ошибка регистрации";
    let errorDescription = "Попробуйте позже";
    let hasValidationErrors = false;
    
    if (axios.isAxiosError(err)) {
      if (err.response) {
        const responseData = err.response.data;
        
        // Handle specific error codes
        if (err.response.status === 409) {
          errorMessage = "Пользователь уже существует";
          errorDescription = responseData?.detail || "Email или номер телефона уже зарегистрирован";
        } else if (err.response.status === 422) {
          errorMessage = "Ошибка валидации данных";
          errorDescription = "Проверьте правильность заполнения полей";
        } else {
          errorMessage = responseData?.detail || responseData?.message || "Ошибка регистрации";
          errorDescription = "Попробуйте еще раз";
        }
        
        // Если есть ошибки валидации, показываем их в полях
        if (responseData?.errors && Array.isArray(responseData.errors)) {
          hasValidationErrors = true;
          responseData.errors.forEach((error: any) => {
            const field = error.field || "";
            if (field.includes("email")) {
              setFieldError("email", error.message);
            }
            if (field.includes("phone") || field.includes("phone_number")) {
              setFieldError("phone", error.message);
            }
            if (field.includes("first_name") || field.includes("firstName")) {
              setFieldError("firstName", error.message);
            }
            if (field.includes("last_name") || field.includes("lastName")) {
              setFieldError("lastName", error.message);
            }
            if (field.includes("password")) {
              setFieldError("password", error.message);
            }
          });
        }
        
        // Показываем общее сообщение об ошибке
        if (hasValidationErrors && responseData.errors.length > 0) {
          toast.error("Проверьте правильность заполнения полей", {
            description: "Исправьте ошибки в форме",
            duration: 1500,
          });
        } else {
          toast.error(errorMessage, {
            description: errorDescription,
            duration: 1500,
          });
        }
      } else if (err.request) {
        errorMessage = "Ошибка сети";
        errorDescription = "Проверьте подключение к интернету или настройки сервера";
        toast.error(errorMessage, {
          description: errorDescription,
          duration: 1500,
        });

        if (err.message.includes('Network Error')) {
          toast.error("Ошибка соединения с сервером", {
            description: "Проверьте, запущен ли бэкенд",
            duration: 1500,
          });
        }
      } else {
        errorMessage = err.message || "Неизвестная ошибка";
        toast.error(errorMessage, {
          description: "Попробуйте еще раз",
          duration: 1500,
        });
      }
    } else {
      toast.error(errorMessage, {
        description: errorDescription,
        duration: 1500,
      });
    }
  } finally {
    setSubmitting(false);
  }
};

  const handleVerify = async (values: any, { setSubmitting }: any) => {
    try {
      await api.verifySms(phoneForVerify, values.code);
      toast.success("Телефон успешно подтвержден!", {
        description: "Теперь вы можете войти",
        duration: 1500,
      });
      setView("login");
    } catch (err: any) {
      console.error("❌ Ошибка верификации:", err);
      const errorMessage = err.response?.data?.detail || "Неверный код верификации";
      toast.error("Ошибка верификации", {
        description: errorMessage,
        duration: 1500,
      });
    }
    setSubmitting(false);
  };


  const handleBankOAuth = (bankCode: string) => {
    toast.info("Перенаправление на банк для авторизации...", {
      description: "Вы будете перенаправлены на страницу банка",
      duration: 1500,
    });
    initiateBankOAuth(bankCode);
  };

  const renderLogin = () => (
    <Formik
      initialValues={{ email: "", password: "" }}
      validationSchema={toFormikValidationSchema(zUserSignIn)}
      onSubmit={handleLogin}
    >
      {({ isSubmitting, isValid, dirty, errors, touched }) => (
        <Form className={styles.form}>
          <h2>Вход в FinFlow</h2>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="email">Email</label>
            <Field 
              id="email" 
              name="email" 
              placeholder="user@example.com"
              className={errors.email && touched.email ? styles.fieldError : ""}
            />
            <ErrorMessage name="email" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="password">Пароль</label>
            <Field 
              id="password" 
              name="password" 
              type="password"
              className={errors.password && touched.password ? styles.fieldError : ""}
            />
            <ErrorMessage name="password" component="div" className={styles.error} />
          </div>
          
          <Button 
            type="submit" 
            disabled={isSubmitting || !isValid || !dirty}
            variant="default" 
            size="lg"
            className={styles.loginButton}
          >
            {isSubmitting ? "Вход..." : "Войти"}
          </Button>

          <div className={styles.divider}></div>

          <div className={styles.oauthSection}>
            <p className={styles.oauthTitle}>Войти через</p>
            <div className={styles.oauthButtons}>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("vbank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Virtual Bank
              </Button>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("abank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Awesome Bank
              </Button>
              <Button
                type="button"
                variant="outline"
                size="lg"
                onClick={() => handleBankOAuth("sbank")}
                className={styles.oauthButton}
              >
                <Building2 size={20} />
                Smart Bank
              </Button>
            </div>
          </div>
        </Form>
      )}
    </Formik>
  );

  const renderRegister = () => (
    <Formik
      initialValues={{ firstName: "", lastName: "", email: "", phone: "", password: "" }}
      validationSchema={toFormikValidationSchema(zUserSignUp)}
      onSubmit={handleRegister}
    >
      {({ isSubmitting, isValid, dirty, errors, touched }) => (
        <Form className={styles.form}>
          <h2>Регистрация</h2>
          
          <div className={styles.grid}>
            <div className={styles.fieldGroup}>
              <label htmlFor="firstName">Имя</label>
              <Field 
                id="firstName" 
                name="firstName"
                className={errors.firstName && touched.firstName ? styles.fieldError : ""}
              />
              <ErrorMessage name="firstName" component="div" className={styles.error} />
            </div>
            <div className={styles.fieldGroup}>
              <label htmlFor="lastName">Фамилия</label>
              <Field 
                id="lastName" 
                name="lastName"
                className={errors.lastName && touched.lastName ? styles.fieldError : ""}
              />
              <ErrorMessage name="lastName" component="div" className={styles.error} />
            </div>
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="email">Email</label>
            <Field 
              id="email" 
              name="email" 
              type="email"
              className={errors.email && touched.email ? styles.fieldError : ""}
            />
            <ErrorMessage name="email" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="phone">Телефон</label>
            <Field 
              id="phone" 
              name="phone" 
              placeholder="+79001234567"
              className={errors.phone && touched.phone ? styles.fieldError : ""}
            />
            <ErrorMessage name="phone" component="div" className={styles.error} />
          </div>
          
          <div className={styles.fieldGroup}>
            <label htmlFor="password">Пароль</label>
            <Field 
              id="password" 
              name="password" 
              type="password"
              className={errors.password && touched.password ? styles.fieldError : ""}
            />
            <ErrorMessage name="password" component="div" className={styles.error} />
          </div>
          
          <Button 
            type="submit" 
            disabled={isSubmitting || !isValid || !dirty}
            variant="default" 
            size="lg"
          >
            {isSubmitting ? "Регистрация..." : "Зарегистрироваться"}
          </Button>
        </Form>
      )}
    </Formik>
  );

const renderVerify = () => (
  <Formik 
    initialValues={{ code: "" }} 
    onSubmit={handleVerify}
    validate={(values) => {
      const errors: any = {};
      if (!values.code) {
        errors.code = "Обязательное поле";
      } else if (values.code.length < 6) {
        errors.code = "Код должен содержать 6 цифр";
      } else if (!/^\d+$/.test(values.code)) {
        errors.code = "Код должен содержать только цифры";
      }
      return errors;
    }}
  >
    {({ isSubmitting, values, errors, touched, setFieldValue }) => (
      <Form className={styles.form}>
        <h2>Код из SMS</h2>
        <p className={styles.subtitle}>
          Мы отправили код на номер <strong>{phoneForVerify || ""}</strong>
        </p>
        
        <div className={styles.fieldGroup}>
          <label htmlFor="code">Код</label>
          <Field 
            id="code" 
            name="code" 
            placeholder="123456" 
            maxLength={6}
            value={values.code}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
              // Используем setFieldValue вместо прямого изменения DOM
              const value = e.target.value.replace(/\D/g, '');
              setFieldValue('code', value);
            }}
          />
          <ErrorMessage name="code" component="div" className={styles.error} />
        </div>
        
        <Button 
          type="submit" 
          disabled={isSubmitting || values.code.length < 6 || !!errors.code}
          variant="default" 
          size="lg"
        >
          {isSubmitting ? "Проверка..." : "Подтвердить"}
        </Button>
      </Form>
    )}
  </Formik>
);

  return (
    <div className={styles.authForm}>
      {view === "login" && renderLogin()}
      {view === "register" && renderRegister()}
      {view === "verify" && renderVerify()}

      <div className={styles.footer}>
        {view !== "verify" && (
          <Button
            variant="link"
            className={styles.switchMode}
            onClick={() => setView(view === "login" ? "register" : "login")}
          >
            {view === "login" ? "Нет аккаунта? Регистрация" : "Уже есть аккаунт? Войти"}
          </Button>
        )}
      </div>
    </div>
  );
};
</file>

<file path="frontend/src/pages/Auth/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.authOverlay {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

.authBlur {
  position: absolute;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.4);
}

.authModal {
  position: relative;
  z-index: 101;
  width: 100%;
  max-width: 450px;
  margin: 1rem;
  
  @include glass-card(false);
  border: 1px solid $glass-border;
  padding: 2.5rem;
  border-radius: $radius;
  box-shadow: $shadow-strong;

  animation: slideUp 0.4s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0; 
    transform: translateY(20px);
  }
  to { 
    opacity: 1; 
    transform: translateY(0);
  }
}
</file>

<file path="frontend/src/pages/Auth/index.tsx">
import React from "react";
import styles from "./index.module.scss";
import { AuthForm } from "./AuthForm";
import cn from "classnames";

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const AuthModal: React.FC<AuthModalProps> = ({ isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className={cn(styles.authOverlay, "auth-modal-overlay")}>
      <div className={styles.authBlur} onClick={onClose}></div>

      <div className={styles.authModal}>
        <AuthForm onClose={onClose} />
      </div>
    </div>
  );
};
</file>

<file path="frontend/src/pages/Auth/OAuthSuccess.module.scss">
@use "../../styles/vars" as *;

.container {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
}

.content {
  text-align: center;
  
  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 1rem;
  }
  
  p {
    font-size: 1rem;
    color: $muted-foreground;
  }
}
</file>

<file path="frontend/src/pages/Auth/OAuthSuccess.tsx">
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { setCookie } from "../../utils/cookies";
import { toast } from "sonner";
import Layout from "../../components/Layout";
import styles from "./OAuthSuccess.module.scss";

export default function OAuthSuccess() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  useEffect(() => {
    const accessToken = searchParams.get("access_token");
    const refreshToken = searchParams.get("refresh_token");

    if (accessToken && refreshToken) {
      // Set tokens
      setCookie("access_token", accessToken, 15 / (24 * 60));
      setCookie("refresh_token", refreshToken, 7);

      toast.success("Успешный вход через банк!", {
        description: "Добро пожаловать!",
        duration: 1500,
      });

      // Redirect to home page
      setTimeout(() => {
        window.location.href = "/";
      }, 1000);
    } else {
      toast.error("Ошибка авторизации", {
        description: "Не удалось получить токены",
        duration: 1500,
      });

      setTimeout(() => {
        navigate("/");
      }, 2000);
    }
  }, [searchParams, navigate]);

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.content}>
          <h1>Завершение входа...</h1>
          <p>Пожалуйста, подождите</p>
        </div>
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/CashFlow/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.card {
  margin-bottom: 1.5rem;
}

.chartCard,
.gapsCard {
  margin-bottom: 1.5rem;
}

.icon {
  width: 1.5rem;
  height: 1.5rem;
  color: $primary;
}

.gapsList {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.gapItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background-color: $input;
  border: 1px solid $border;
  border-radius: $radius-md;

  .gapDate {
    font-weight: 600;
    color: $foreground;
    margin-bottom: 0.25rem;
  }

  .gapAmount {
    font-size: 1.25rem;
    font-weight: 700;
    color: $danger;
  }

  .gapMeta {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.5rem;
  }

  .gapProbability {
    font-size: 0.875rem;
    color: $muted-foreground;
  }

  .gapSeverity {
    padding: 0.25rem 0.75rem;
    border-radius: $radius-sm;
    font-size: 0.75rem;
    font-weight: 600;
    background-color: rgba($danger, 0.1);
    color: $danger;
  }
}
</file>

<file path="frontend/src/pages/CashFlow/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { TrendingUp, AlertTriangle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getCashFlowPredictions, getCashFlowGaps, type CashFlowPrediction, type CashFlowGap } from "../../utils/api";
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
  ReferenceLine,
} from "recharts";
import styles from "./index.module.scss";
import {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
  primaryHslParts,
  accentHslParts,
} from "../../styles/colors";
import { toast } from "sonner";

const getHslColor = (h: string, s: string, l: string) => `hsl(${h}, ${s}, ${l})`;

export default function CashFlow() {
  const { isAuthenticated } = useAuth();
  const [predictions, setPredictions] = useState<CashFlowPrediction["predictions"]>([]);
  const [gaps, setGaps] = useState<CashFlowGap["gaps"]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const [predictionsRes, gapsRes] = await Promise.all([
          getCashFlowPredictions(4),
          getCashFlowGaps(4),
        ]);

        if (predictionsRes.data.success && predictionsRes.data.predictions) {
          setPredictions(predictionsRes.data.predictions);
        }

        if (gapsRes.data.success && gapsRes.data.gaps) {
          setGaps(gapsRes.data.gaps);
        }
      } catch (err: any) {
        console.error("Error fetching cash flow data:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить прогноз денежного потока");
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [isAuthenticated]);

  const primaryHslString = getHslColor(primaryHslParts[0], primaryHslParts[1], primaryHslParts[2]);
  const accentHslString = getHslColor(accentHslParts[0], accentHslParts[1], accentHslParts[2]);

  const chartData = predictions?.map((p) => ({
    date: new Date(p.prediction_date).toLocaleDateString("ru-RU", { day: "2-digit", month: "short" }),
    predicted: p.predicted_balance,
    inflow: p.predicted_inflow,
    outflow: p.predicted_outflow,
  })) || [];

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card className={styles.card}>
          <CardHeader>
            <CardTitle>Cash Flow прогноз</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть прогноз денежного потока</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Cash Flow прогноз</h1>
          <p>Прогнозирование денежного потока на следующие 4 недели</p>
        </div>

        {isLoading ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Загрузка данных...</p>
            </CardContent>
          </Card>
        ) : error ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
              <p>{error}</p>
            </CardContent>
          </Card>
        ) : chartData.length === 0 ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Нет данных для отображения</p>
              <p style={{ fontSize: "0.875rem", marginTop: "0.5rem", color: muted_foreground }}>
                Подключите банковские счета для получения прогноза
              </p>
            </CardContent>
          </Card>
        ) : (
          <>
            <Card className={styles.chartCard}>
              <CardHeader>
                <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
                  <TrendingUp className={styles.icon} />
                  <div>
                    <CardTitle>Прогноз баланса</CardTitle>
                    <p style={{ fontSize: "0.875rem", color: muted_foreground, marginTop: "0.25rem" }}>
                      Прогнозируемый баланс на следующие 4 недели
                    </p>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={320}>
                  <AreaChart data={chartData} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
                    <defs>
                      <linearGradient id="colorPredicted" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="5%" stopColor={accentHslString} stopOpacity={0.4} />
                        <stop offset="95%" stopColor={accentHslString} stopOpacity={0.05} />
                      </linearGradient>
                    </defs>
                    <CartesianGrid strokeDasharray="3 3" stroke={border} opacity={0.3} />
                    <XAxis
                      dataKey="date"
                      stroke={muted_foreground}
                      fontSize={12}
                      tickLine={false}
                      axisLine={{ stroke: border }}
                    />
                    <YAxis
                      stroke={muted_foreground}
                      fontSize={12}
                      tickLine={false}
                      axisLine={{ stroke: border }}
                    />
                    <Tooltip
                      contentStyle={{
                        backgroundColor: popover,
                        border: `1px solid ${border}`,
                        borderRadius: "12px",
                      }}
                      formatter={(value: number) => [`₽${value.toLocaleString()}`, ""]}
                    />
                    <ReferenceLine y={0} stroke={danger} strokeDasharray="5 5" strokeWidth={2} />
                    <Area
                      type="monotone"
                      dataKey="predicted"
                      stroke={accent}
                      strokeWidth={3}
                      strokeDasharray="8 4"
                      fillOpacity={1}
                      fill="url(#colorPredicted)"
                      name="Прогноз"
                      dot={{ fill: accent, r: 4 }}
                    />
                  </AreaChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            {gaps && gaps.length > 0 && (
              <Card className={styles.gapsCard}>
                <CardHeader>
                  <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
                    <AlertTriangle className={styles.icon} style={{ color: danger }} />
                    <div>
                      <CardTitle>Потенциальные кассовые разрывы</CardTitle>
                      <p style={{ fontSize: "0.875rem", color: muted_foreground, marginTop: "0.25rem" }}>
                        Даты с высоким риском недостатка средств
                      </p>
                    </div>
                  </div>
                </CardHeader>
                <CardContent>
                  <div className={styles.gapsList}>
                    {gaps.map((gap, index) => (
                      <div key={index} className={styles.gapItem}>
                        <div>
                          <p className={styles.gapDate}>{new Date(gap.date).toLocaleDateString("ru-RU")}</p>
                          <p className={styles.gapAmount}>₽{gap.gap_amount.toLocaleString()}</p>
                        </div>
                        <div className={styles.gapMeta}>
                          <span className={styles.gapProbability}>
                            Вероятность: {gap.probability.toFixed(1)}%
                          </span>
                          <span className={styles.gapSeverity}>{gap.severity}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </>
        )}
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/Health/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.healthScore {
  margin-bottom: 2rem;
}

.scoreContent {
  display: flex;
  align-items: center;
  gap: 2rem;
  padding: 2rem !important;
}

.scoreCircle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 150px;
}

.scoreValue {
  font-size: 3rem;
  font-weight: 700;
  line-height: 1;
}

.scoreLabel {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin-top: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.scoreStatus {
  flex: 1;
}

.statusBadge {
  display: inline-block;
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  color: white;
  font-weight: 600;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

.statusDescription {
  color: $muted-foreground;
  font-size: 0.875rem;
  line-height: 1.6;
}

.metricsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.detailsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

.metricRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 0;
  border-bottom: 1px solid $border;

  &:last-child {
    border-bottom: none;
  }

  span {
    color: $muted-foreground;
    font-size: 0.875rem;
  }

  strong {
    color: $foreground;
    font-weight: 600;
  }
}
</file>

<file path="frontend/src/pages/Health/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Heart, TrendingUp, TrendingDown, AlertCircle, DollarSign } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getHealthMetrics, type HealthMetrics } from "../../utils/api";
import StatCard from "../../components/StatCard";
import styles from "./index.module.scss";
import { toast } from "sonner";

export default function Health() {
  const { isAuthenticated } = useAuth();
  const [metrics, setMetrics] = useState<HealthMetrics["metrics"] | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchMetrics = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await getHealthMetrics();
        if (response.data.success && response.data.metrics) {
          setMetrics(response.data.metrics);
        } else {
          setError(response.data.error || "Не удалось загрузить метрики");
        }
      } catch (err: any) {
        console.error("Error fetching health metrics:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить метрики финансового здоровья");
      } finally {
        setIsLoading(false);
      }
    };

    fetchMetrics();
  }, [isAuthenticated]);

  const getHealthStatusColor = (status?: string) => {
    switch (status?.toLowerCase()) {
      case "excellent":
        return "#10b981";
      case "good":
        return "#3b82f6";
      case "fair":
        return "#f59e0b";
      case "poor":
        return "#ef4444";
      case "critical":
        return "#dc2626";
      default:
        return "#6b7280";
    }
  };

  const getHealthStatusText = (status?: string) => {
    switch (status?.toLowerCase()) {
      case "excellent":
        return "Отлично";
      case "good":
        return "Хорошо";
      case "fair":
        return "Удовлетворительно";
      case "poor":
        return "Плохо";
      case "critical":
        return "Критично";
      default:
        return "Не определено";
    }
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Финансовое здоровье</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть метрики финансового здоровья</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Финансовое здоровье</h1>
          <p>Анализ финансового состояния и ключевые метрики</p>
        </div>

        {isLoading ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Загрузка данных...</p>
            </CardContent>
          </Card>
        ) : error ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
              <p>{error}</p>
            </CardContent>
          </Card>
        ) : !metrics ? (
          <Card>
            <CardContent style={{ padding: "2rem", textAlign: "center" }}>
              <p>Нет данных для отображения</p>
              <p style={{ fontSize: "0.875rem", marginTop: "0.5rem" }}>
                Подключите банковские счета для расчета метрик
              </p>
            </CardContent>
          </Card>
        ) : (
          <>
            <div className={styles.healthScore}>
              <Card>
                <CardContent className={styles.scoreContent}>
                  <div className={styles.scoreCircle}>
                    <div
                      className={styles.scoreValue}
                      style={{ color: getHealthStatusColor(metrics.health_status) }}
                    >
                      {metrics.health_score || 0}
                    </div>
                    <div className={styles.scoreLabel}>Health Score</div>
                  </div>
                  <div className={styles.scoreStatus}>
                    <div
                      className={styles.statusBadge}
                      style={{ backgroundColor: getHealthStatusColor(metrics.health_status) }}
                    >
                      {getHealthStatusText(metrics.health_status)}
                    </div>
                    <p className={styles.statusDescription}>
                      {metrics.health_status === "excellent" && "Ваше финансовое состояние отличное"}
                      {metrics.health_status === "good" && "Ваше финансовое состояние хорошее"}
                      {metrics.health_status === "fair" && "Есть области для улучшения"}
                      {metrics.health_status === "poor" && "Требуется внимание к финансам"}
                      {metrics.health_status === "critical" && "Критическая ситуация, требуется срочное действие"}
                    </p>
                  </div>
                </CardContent>
              </Card>
            </div>

            <div className={styles.metricsGrid}>
              <StatCard
                title="Доходы"
                value={`₽${(metrics.total_revenue || 0).toLocaleString()}`}
                subtitle="За период"
                icon={TrendingUp}
                variant="success"
              />
              <StatCard
                title="Расходы"
                value={`₽${(metrics.total_expenses || 0).toLocaleString()}`}
                subtitle="За период"
                icon={TrendingDown}
                variant="danger"
              />
              <StatCard
                title="Чистая прибыль"
                value={`₽${(metrics.net_income || 0).toLocaleString()}`}
                subtitle={metrics.net_income && metrics.net_income >= 0 ? "Положительный" : "Отрицательный"}
                icon={DollarSign}
                variant={metrics.net_income && metrics.net_income >= 0 ? "success" : "danger"}
              />
              <StatCard
                title="Дебиторская задолженность"
                value={`₽${(metrics.total_ar || 0).toLocaleString()}`}
                subtitle={`Просрочено: ₽${(metrics.overdue_ar || 0).toLocaleString()}`}
                icon={AlertCircle}
                variant="warning"
              />
            </div>

            <div className={styles.detailsGrid}>
              <Card>
                <CardHeader>
                  <CardTitle>Ликвидность</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Коэффициент текущей ликвидности</span>
                    <strong>{metrics.current_ratio?.toFixed(2) || "—"}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Коэффициент быстрой ликвидности</span>
                    <strong>{metrics.quick_ratio?.toFixed(2) || "—"}</strong>
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Денежный поток</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Операционный денежный поток</span>
                    <strong>₽{(metrics.operating_cash_flow || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Тренд</span>
                    <strong>{metrics.cash_flow_trend || "—"}</strong>
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Активы и обязательства</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className={styles.metricRow}>
                    <span>Общие активы</span>
                    <strong>₽{(metrics.total_assets || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Обязательства</span>
                    <strong>₽{(metrics.total_liabilities || 0).toLocaleString()}</strong>
                  </div>
                  <div className={styles.metricRow}>
                    <span>Чистая стоимость</span>
                    <strong>₽{(metrics.net_worth || 0).toLocaleString()}</strong>
                  </div>
                </CardContent>
              </Card>
            </div>
          </>
        )}
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/home/index.module.scss">
@use "../../styles/vars.scss" as *;
@use "../../styles/mixins" as *;

$md: 768px;
$lg: 1024px;
$xl: 1280px;

.headerRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.userButton {
  width: 48px;
  height: 48px;
  border-radius: $radius-md;
  background: $gradient-primary;
  border: 1px solid $primary;
  color: $foreground;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: $transition-smooth;
  box-shadow: $shadow-soft;

  &:hover {
    box-shadow: $shadow-medium, $shadow-glow;
    transform: translateY(-2px);
    border-color: $primary-light;
  }

  &:active {
    transform: translateY(0);
  }
}

.dashboardContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
}


.headerSection {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}


.mainTitle {
  font-size: 3rem;
  font-weight: 700;
  color: $foreground;
  @include text-glow($primary);
}


.subtitle {
  font-size: 1.125rem;
  color: $muted-foreground;
}

.statsGrid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 1.5rem;

  @media (min-width: $md) {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  @media (min-width: $lg) {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }
}

.chartsGrid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 2rem;

  @media (min-width: $xl) {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}
</file>

<file path="frontend/src/pages/Landing/index.module.scss">
@use "../../styles/vars" as *;

.landing {
  min-height: 100vh;
  background: linear-gradient(180deg, $background 0%, rgba($primary, 0.05) 100%);
}

.hero {
  padding: 4rem 2rem;
  text-align: center;
  max-width: 1200px;
  margin: 0 auto;
}

.heroContent {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
}

.brand {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.brandIcon {
  width: 2rem;
  height: 2rem;
  color: $primary;
}

.brandName {
  font-size: 1.5rem;
  font-weight: 700;
  color: $foreground;
}

.heroTitle {
  font-size: 3rem;
  font-weight: 800;
  color: $foreground;
  line-height: 1.2;
  max-width: 800px;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 2rem;
  }
}

.heroDescription {
  font-size: 1.25rem;
  color: $muted-foreground;
  max-width: 600px;
  line-height: 1.6;
  margin: 0;

  @media (max-width: 768px) {
    font-size: 1rem;
  }
}

.heroActions {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  justify-content: center;
}

.ctaButton {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.ctaButtonLarge {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 1.125rem;
  padding: 1rem 2rem;
}

.features,
.benefits,
.cta {
  padding: 4rem 2rem;
}

.sectionContent {
  max-width: 1200px;
  margin: 0 auto;
}

.sectionTitle {
  font-size: 2.5rem;
  font-weight: 700;
  color: $foreground;
  text-align: center;
  margin-bottom: 3rem;

  @media (max-width: 768px) {
    font-size: 2rem;
  }
}

.featuresGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 2rem;
}

.featureCard {
  height: 100%;
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba($primary, 0.15);
  }
}

.featureIcon {
  width: 3rem;
  height: 3rem;
  border-radius: $radius-md;
  background: linear-gradient(135deg, rgba($primary, 0.1), rgba($primary, 0.2));
  display: flex;
  align-items: center;
  justify-content: center;
  color: $primary;
  margin-bottom: 1rem;
}

.benefitsGrid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4rem;
  align-items: center;

  @media (max-width: 968px) {
    grid-template-columns: 1fr;
    gap: 2rem;
  }
}

.benefitsText {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.benefitsDescription {
  font-size: 1.125rem;
  color: $muted-foreground;
  line-height: 1.6;
}

.benefitsList {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.benefitItem {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 1rem;
  color: $foreground;

  span {
    flex: 1;
  }
}

.checkIcon {
  width: 1.25rem;
  height: 1.25rem;
  color: #10b981;
  flex-shrink: 0;
}

.benefitsVisual {
  display: flex;
  justify-content: center;
}

.visualCard {
  width: 100%;
  max-width: 500px;
}

.visualContent {
  padding: 3rem !important;
}

.chartPlaceholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  padding: 2rem;
  color: $muted-foreground;
  text-align: center;

  svg {
    width: 4rem;
    height: 4rem;
    opacity: 0.5;
  }
}

.ctaCard {
  background: linear-gradient(135deg, rgba($primary, 0.1), rgba($primary, 0.05));
  border: 2px solid rgba($primary, 0.2);
}

.ctaContent {
  padding: 3rem !important;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
}

.ctaTitle {
  font-size: 2rem;
  font-weight: 700;
  color: $foreground;
  margin: 0;
}

.ctaDescription {
  font-size: 1.125rem;
  color: $muted-foreground;
  max-width: 600px;
  margin: 0;
}
</file>

<file path="frontend/src/pages/Landing/index.tsx">
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { AuthModal } from "../Auth";
import { Button } from "../../ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import {
  TrendingUp,
  Shield,
  Zap,
  BarChart3,
  ArrowRight,
  CheckCircle,
  Sparkles,
} from "lucide-react";
import styles from "./index.module.scss";

export default function Landing() {
  const [isAuthOpen, setIsAuthOpen] = useState(false);
  const navigate = useNavigate();

  const features = [
    {
      icon: BarChart3,
      title: "Финансовая аналитика",
      description: "Получайте детальную аналитику по всем вашим счетам в одном месте",
    },
    {
      icon: TrendingUp,
      title: "Прогноз денежных потоков",
      description: "ML-прогнозы помогают предсказать кассовые разрывы заранее",
    },
    {
      icon: Shield,
      title: "Безопасность",
      description: "Ваши данные защищены современными стандартами безопасности",
    },
    {
      icon: Zap,
      title: "Мультибанкинг",
      description: "Подключите счета из разных банков и управляйте ими централизованно",
    },
  ];

  const benefits = [
    "Автоматическая синхронизация с банками",
    "Управление дебиторской задолженностью",
    "Прогнозирование денежных потоков",
    "Детальная финансовая аналитика",
    "Отслеживание всех транзакций",
  ];

  return (
    <div className={styles.landing}>
      <AuthModal isOpen={isAuthOpen} onClose={() => setIsAuthOpen(false)} />

      {/* Hero Section */}
      <section className={styles.hero}>
        <div className={styles.heroContent}>
          <div className={styles.brand}>
            <Sparkles className={styles.brandIcon} />
            <span className={styles.brandName}>FinFlow</span>
          </div>
          <h1 className={styles.heroTitle}>
            Управление финансами для предпринимателей
          </h1>
          <p className={styles.heroDescription}>
            Объедините все ваши банковские счета, получите детальную аналитику и прогнозы денежных потоков в одном приложении
          </p>
          <div className={styles.heroActions}>
            <Button
              size="lg"
              onClick={() => setIsAuthOpen(true)}
              className={styles.ctaButton}
            >
              Начать бесплатно
              <ArrowRight size={20} />
            </Button>
            <Button
              size="lg"
              variant="outline"
              onClick={() => {
                setIsAuthOpen(true);
                setTimeout(() => {
                  const loginTab = document.querySelector('[data-view="login"]');
                  if (loginTab) (loginTab as HTMLElement).click();
                }, 100);
              }}
            >
              Войти
            </Button>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className={styles.features}>
        <div className={styles.sectionContent}>
          <h2 className={styles.sectionTitle}>Возможности</h2>
          <div className={styles.featuresGrid}>
            {features.map((feature, index) => {
              const Icon = feature.icon;
              return (
                <Card key={index} className={styles.featureCard}>
                  <CardHeader>
                    <div className={styles.featureIcon}>
                      <Icon />
                    </div>
                    <CardTitle>{feature.title}</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p>{feature.description}</p>
                  </CardContent>
                </Card>
              );
            })}
          </div>
        </div>
      </section>

      {/* Benefits Section */}
      <section className={styles.benefits}>
        <div className={styles.sectionContent}>
          <div className={styles.benefitsGrid}>
            <div className={styles.benefitsText}>
              <h2 className={styles.sectionTitle}>Почему FinFlow?</h2>
              <p className={styles.benefitsDescription}>
                Мы помогаем предпринимателям эффективно управлять финансами, предсказывать проблемы и принимать обоснованные решения
              </p>
              <ul className={styles.benefitsList}>
                {benefits.map((benefit, index) => (
                  <li key={index} className={styles.benefitItem}>
                    <CheckCircle className={styles.checkIcon} />
                    <span>{benefit}</span>
                  </li>
                ))}
              </ul>
              <Button
                size="lg"
                onClick={() => setIsAuthOpen(true)}
                className={styles.ctaButton}
              >
                Попробовать бесплатно
                <ArrowRight size={20} />
              </Button>
            </div>
            <div className={styles.benefitsVisual}>
              <Card className={styles.visualCard}>
                <CardContent className={styles.visualContent}>
                  <div className={styles.chartPlaceholder}>
                    <BarChart3 size={64} />
                    <p>Интерактивные графики и аналитика</p>
                  </div>
                </CardContent>
              </Card>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className={styles.cta}>
        <div className={styles.sectionContent}>
          <Card className={styles.ctaCard}>
            <CardContent className={styles.ctaContent}>
              <h2 className={styles.ctaTitle}>Готовы начать?</h2>
              <p className={styles.ctaDescription}>
                Присоединяйтесь к предпринимателям, которые уже используют FinFlow для управления финансами
              </p>
              <Button
                size="lg"
                onClick={() => setIsAuthOpen(true)}
                className={styles.ctaButtonLarge}
              >
                Создать аккаунт
                <ArrowRight size={20} />
              </Button>
            </CardContent>
          </Card>
        </div>
      </section>
    </div>
  );
}
</file>

<file path="frontend/src/pages/NotFound/index.module.scss">
@use "../../styles/vars" as *;
@use "../../styles/mixins" as *;

.pageContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  text-align: center;
  padding: 2rem;
  background: $gradient-card;
  position: relative;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: $gradient-glow;
    pointer-events: none;
  }

  p {
    font-size: 3rem;
    color: $foreground;
    margin-bottom: 2rem;
    position: relative;
    z-index: 1;
    
    @include gradient-text($gradient-primary);
    
    @include text-glow($primary);
  }

  img {
    max-width: 400px;
    width: 100%;
    height: auto;
    border-radius: $radius-lg;
    
    @include glass-card();
    
    box-shadow: $shadow-medium;
  }

  @media (max-width: 768px) {
    padding: 1rem;
    
    p {
      font-size: 2rem;
      margin-bottom: 1.5rem;
    }
    
    img {
      max-width: 250px;
    }
  }

  @media (max-width: 480px) {
    p {
      font-size: 1.4rem;
    }
    
    img {
      max-width: 200px;
    }
  }
}
</file>

<file path="frontend/src/pages/NotFound/index.tsx">
import css from "./index.module.scss"

export default function NotFound () {
    return (
        <div className={css.pageContainer}>
            <p>Такой страницы не существует</p>
            <img src="/kitty.webp"></img>
        </div>
    )
}
</file>

<file path="frontend/src/pages/Payments/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.tableWrap {
  overflow-x: auto;
}

.description {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.typeIncome,
.typeExpense {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
}

.typeIncome {
  color: #10b981;
}

.typeExpense {
  color: #ef4444;
}

.amountIncome {
  color: #10b981;
  font-weight: 600;
}

.amountExpense {
  color: #ef4444;
  font-weight: 600;
}

.status {
  padding: 0.25rem 0.75rem;
  border-radius: $radius-sm;
  font-size: 0.75rem;
  background-color: rgba(16, 185, 129, 0.1);
  color: #10b981;
}

.filters {
  display: flex;
  gap: 0.5rem;
}

.filterButton,
.filterActive {
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $input;
  color: $foreground;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background-color: $input;
    border-color: $primary;
  }
}

.filterActive {
  background-color: $primary;
  color: white;
  border-color: $primary;
}
</file>

<file path="frontend/src/pages/Profile/index.module.scss">
@use "../../styles/vars.scss" as *;
@use "../../styles/mixins" as *;

.profileContainer {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100%;
  padding: 2rem 1rem;
}

.profileCard {
  width: 100%;
  max-width: 600px;
  @include glass-card(true);
  border-radius: $radius;
  padding: 2.5rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.profileHeader {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.avatar {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  box-shadow: $shadow-glow;
  border: 3px solid $primary;
}

.profileName {
  font-size: 2rem;
  font-weight: 700;
  color: $foreground;
  @include text-glow($primary);
  text-align: center;
}

.profileInfo {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.infoItem {
  display: flex;
  align-items: flex-start;
  gap: 1rem;
  padding: 1.25rem;
  background: $secondary;
  border-radius: $radius-md;
  border: 1px solid $border;
  transition: $transition-smooth;

  &:hover {
    border-color: $primary;
    box-shadow: $shadow-soft;
  }
}

.infoIcon {
  width: 40px;
  height: 40px;
  border-radius: $radius-sm;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  flex-shrink: 0;
}

.infoContent {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.infoLabel {
  font-size: 0.875rem;
  color: $muted-foreground;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.infoValue {
  font-size: 1.125rem;
  color: $foreground;
  font-weight: 500;
}

.profileActions {
  display: flex;
  justify-content: center;
  padding-top: 1rem;
}

.logoutButton {
  min-width: 200px;
}

.loading,
.error {
  text-align: center;
  color: $foreground;
  font-size: 1.25rem;
  padding: 2rem;
}

.error {
  color: $danger;
}

.consentsSection {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding-top: 1rem;
  border-top: 1px solid $border;
}

.sectionTitle {
  font-size: 1.5rem;
  font-weight: 700;
  color: $foreground;
  margin: 0;
}

.sectionDescription {
  font-size: 0.875rem;
  color: $muted-foreground;
  margin: 0;
}

.consentsList {
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.consentItem {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 1.25rem;
  background: $secondary;
  border-radius: $radius-md;
  border: 1px solid $border;
  transition: $transition-smooth;

  &:hover {
    border-color: $primary;
    box-shadow: $shadow-soft;
  }
}

.consentHeader {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.consentIcon {
  width: 32px;
  height: 32px;
  border-radius: $radius-sm;
  background: $gradient-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  color: $foreground;
  flex-shrink: 0;
}

.consentLabel {
  font-size: 1rem;
  font-weight: 600;
  color: $foreground;
}

.consentInputGroup {
  display: flex;
  gap: 0.5rem;
  align-items: flex-start;
}

.consentInput {
  flex: 1;
}

.consentActions {
  display: flex;
  gap: 0.5rem;
}

.saveButton,
.deleteButton {
  white-space: nowrap;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.consentSaved {
  font-size: 0.875rem;
  color: $muted-foreground;
  padding-top: 0.5rem;
  border-top: 1px solid $border;
}
</file>

<file path="frontend/src/pages/Profile/index.tsx">
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../hooks/useAuth";
import { eraseCookie, setCookie, getCookie } from "../../utils/cookies";
import { logout, getUserBankUsers, saveBankUser, deleteBankUser, createAccountConsent, getUserConsents, type BankConsent } from "../../utils/api";
import Layout from "../../components/Layout";
import { Button } from "../../ui/button";
import { Input } from "../../ui/input";
import { Label } from "../../ui/label";
import { CircleUser, Mail, Phone, Building2, Save, Trash2, Shield, CheckCircle2 } from "lucide-react";
import { useState, useEffect, useCallback } from "react";
import { toast } from "sonner";
import styles from "./index.module.scss";

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

export default function Profile() {
  const { user, isLoading } = useAuth();
  const navigate = useNavigate();
  const [bankUsers, setBankUsers] = useState<Record<string, string>>({});
  const [bankUserInputs, setBankUserInputs] = useState<Record<string, string>>({});
  const [isLoadingBankUsers, setIsLoadingBankUsers] = useState(true);
  const [saving, setSaving] = useState<Record<string, boolean>>({});
  const [consents, setConsents] = useState<Record<string, BankConsent>>({});
  const [isLoadingConsents, setIsLoadingConsents] = useState(true);
  const [creatingConsent, setCreatingConsent] = useState<Record<string, boolean>>({});

  const loadBankUsers = useCallback(async () => {
    try {
      setIsLoadingBankUsers(true);
      const response = await getUserBankUsers();
      setBankUsers(response.data.bank_users || {});
      // Инициализируем поля ввода текущими значениями
      setBankUserInputs(response.data.bank_users || {});
    } catch (error) {
      console.error("Error loading bank users:", error);
    } finally {
      setIsLoadingBankUsers(false);
    }
  }, []);

  const loadConsents = useCallback(async () => {
    try {
      setIsLoadingConsents(true);
      const response = await getUserConsents();
      const consentsMap: Record<string, BankConsent> = {};
      (response.data.consents || []).forEach((consent: BankConsent) => {
        consentsMap[consent.bank_code] = consent;
        // Сохраняем согласие в куки для использования в других запросах
        setCookie(`consent_${consent.bank_code}`, consent.consent_id, 365);
      });
      setConsents(consentsMap);
    } catch (error) {
      console.error("Error loading consents:", error);
    } finally {
      setIsLoadingConsents(false);
    }
  }, []);

  useEffect(() => {
    if (user) {
      loadBankUsers();
      loadConsents();
    }
  }, [user, loadBankUsers, loadConsents]);

  const handleSaveBankUser = async (bankCode: string) => {
    const bankUserId = bankUserInputs[bankCode]?.trim();
    if (!bankUserId) {
      toast.error("Введите ID пользователя", {
        description: "Поле не может быть пустым",
        duration: 1500,
      });
      return;
    }

    try {
      setSaving((prev) => ({ ...prev, [bankCode]: true }));
      await saveBankUser({ bank_code: bankCode, bank_user_id: bankUserId });
      setBankUsers((prev) => ({ ...prev, [bankCode]: bankUserId }));
      toast.success(`ID пользователя для ${bankNames[bankCode]} сохранен`, {
        description: "Банковская интеграция настроена",
        duration: 1500,
      });
    } catch (error: any) {
      console.error("Error saving bank user:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при сохранении ID пользователя";
      toast.error("Не удалось сохранить ID пользователя", {
        description: errorMessage,
        duration: 1500,
      });
    } finally {
      setSaving((prev) => ({ ...prev, [bankCode]: false }));
    }
  };

  const handleDeleteBankUser = async (bankCode: string) => {
    // Use toast.promise for confirmation-like behavior
    const confirmed = window.confirm(`Удалить ID пользователя для ${bankNames[bankCode]}?`);
    if (!confirmed) {
      return;
    }

    try {
      await deleteBankUser(bankCode);
      setBankUsers((prev) => {
        const newBankUsers = { ...prev };
        delete newBankUsers[bankCode];
        return newBankUsers;
      });
      setBankUserInputs((prev) => {
        const newInputs = { ...prev };
        delete newInputs[bankCode];
        return newInputs;
      });
      toast.success(`ID пользователя для ${bankNames[bankCode]} удален`, {
        description: "Банковская интеграция отключена",
        duration: 1500,
      });
    } catch (error: any) {
      console.error("Error deleting bank user:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при удалении ID пользователя";
      toast.error("Не удалось удалить ID пользователя", {
        description: errorMessage,
        duration: 1500,
      });
    }
  };

  const handleCreateConsent = async (bankCode: string) => {
    if (!bankUsers[bankCode]) {
      toast.error("Сначала укажите ID пользователя в банке", {
        description: `Для ${bankNames[bankCode]} необходимо указать ID пользователя`,
        duration: 2000,
      });
      return;
    }

    try {
      setCreatingConsent((prev) => ({ ...prev, [bankCode]: true }));
      const response = await createAccountConsent(bankCode);
      
      // Сохраняем согласие в куки
      setCookie(`consent_${bankCode}`, response.data.consent_id, 365);
      
      // Обновляем список согласий
      const newConsent: BankConsent = {
        consent_id: response.data.consent_id,
        bank_code: bankCode,
        status: response.data.status,
        auto_approved: response.data.auto_approved,
        expires_at: response.data.expires_at,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
      
      setConsents((prev) => ({
        ...prev,
        [bankCode]: newConsent,
      }));
      
      toast.success(`Согласие для ${bankNames[bankCode]} создано`, {
        description: `ID: ${response.data.consent_id}`,
        duration: 2000,
      });
    } catch (error: any) {
      console.error("Error creating consent:", error);
      const errorMessage = error.response?.data?.detail || "Ошибка при создании согласия";
      toast.error("Не удалось создать согласие", {
        description: errorMessage,
        duration: 2000,
      });
    } finally {
      setCreatingConsent((prev) => ({ ...prev, [bankCode]: false }));
    }
  };

  const handleLogout = () => {
    logout();
    eraseCookie("access_token");
    eraseCookie("refresh_token");
    toast.success("Вы успешно вышли из аккаунта", {
      description: "До свидания!",
      duration: 1500,
    });
    navigate("/");
    setTimeout(() => {
      window.location.reload();
    }, 500);
  };

  if (isLoading) {
    return (
      <Layout>
        <div className={styles.profileContainer}>
          <div className={styles.loading}>Загрузка...</div>
        </div>
      </Layout>
    );
  }

  if (!user) {
    return (
      <Layout>
        <div className={styles.profileContainer}>
          <div className={styles.error}>Пользователь не найден</div>
        </div>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.profileContainer}>
        <div className={styles.profileCard}>
          <div className={styles.profileHeader}>
            <div className={styles.avatar}>
              <CircleUser size={64} />
            </div>
            <h1 className={styles.profileName}>
              {user.first_name} {user.last_name}
            </h1>
          </div>

          <div className={styles.profileInfo}>
            <div className={styles.infoItem}>
              <div className={styles.infoIcon}>
                <Mail size={20} />
              </div>
              <div className={styles.infoContent}>
                <div className={styles.infoLabel}>Email</div>
                <div className={styles.infoValue}>{user.email}</div>
              </div>
            </div>

            <div className={styles.infoItem}>
              <div className={styles.infoIcon}>
                <Phone size={20} />
              </div>
              <div className={styles.infoContent}>
                <div className={styles.infoLabel}>Телефон</div>
                <div className={styles.infoValue}>{user.phone_number}</div>
              </div>
            </div>
          </div>

          {/* Bank Users Section */}
          <div className={styles.consentsSection}>
            <h2 className={styles.sectionTitle}>ID пользователей в банках</h2>
            <p className={styles.sectionDescription}>
              Введите ваш ID пользователя для каждого банка. После этого вы сможете получать данные о счетах и транзакциях.
            </p>
            
            {isLoadingBankUsers ? (
              <div className={styles.loading}>Загрузка...</div>
            ) : (
              <div className={styles.consentsList}>
                {(["vbank", "abank", "sbank"] as const).map((bankCode) => (
                  <div key={bankCode} className={styles.consentItem}>
                    <div className={styles.consentHeader}>
                      <div className={styles.consentIcon}>
                        <Building2 size={20} />
                      </div>
                      <Label htmlFor={`bank-user-${bankCode}`} className={styles.consentLabel}>
                        {bankNames[bankCode]}
                      </Label>
                    </div>
                    <div className={styles.consentInputGroup}>
                      <Input
                        id={`bank-user-${bankCode}`}
                        type="text"
                        placeholder="Введите ваш ID в банке"
                        value={bankUserInputs[bankCode] || ""}
                        onChange={(e) =>
                          setBankUserInputs((prev) => ({
                            ...prev,
                            [bankCode]: e.target.value,
                          }))
                        }
                        className={styles.consentInput}
                      />
                      <div className={styles.consentActions}>
                        <Button
                          size="sm"
                          onClick={() => handleSaveBankUser(bankCode)}
                          disabled={saving[bankCode]}
                          className={styles.saveButton}
                        >
                          <Save size={16} />
                          {saving[bankCode] ? "Сохранение..." : "Сохранить"}
                        </Button>
                        {bankUsers[bankCode] && (
                          <Button
                            size="sm"
                            variant="destructive"
                            onClick={() => handleDeleteBankUser(bankCode)}
                            className={styles.deleteButton}
                          >
                            <Trash2 size={16} />
                          </Button>
                        )}
                      </div>
                    </div>
                    {bankUsers[bankCode] && (
                      <div className={styles.consentSaved}>
                        Сохранен: {bankUsers[bankCode]}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Consents Section */}
          <div className={styles.consentsSection}>
            <h2 className={styles.sectionTitle}>Согласия на доступ к данным</h2>
            <p className={styles.sectionDescription}>
              Создайте согласие для каждого банка, чтобы получать данные о счетах, балансах и транзакциях.
            </p>
            
            {isLoadingConsents ? (
              <div className={styles.loading}>Загрузка...</div>
            ) : (
              <div className={styles.consentsList}>
                {(["vbank", "abank", "sbank"] as const).map((bankCode) => {
                  const consent = consents[bankCode];
                  const hasBankUser = !!bankUsers[bankCode];
                  
                  return (
                    <div key={bankCode} className={styles.consentItem}>
                      <div className={styles.consentHeader}>
                        <div className={styles.consentIcon}>
                          <Shield size={20} />
                        </div>
                        <Label className={styles.consentLabel}>
                          {bankNames[bankCode]}
                        </Label>
                        {consent && consent.status === "approved" && (
                          <div className={styles.consentStatus}>
                            <CheckCircle2 size={16} className={styles.consentStatusIcon} />
                            <span>Активно</span>
                          </div>
                        )}
                      </div>
                      
                      {consent ? (
                        <div className={styles.consentInfo}>
                          <div className={styles.consentDetails}>
                            <div className={styles.consentDetail}>
                              <span className={styles.consentDetailLabel}>ID согласия:</span>
                              <span className={styles.consentDetailValue}>{consent.consent_id}</span>
                            </div>
                            {consent.expires_at && (
                              <div className={styles.consentDetail}>
                                <span className={styles.consentDetailLabel}>Истекает:</span>
                                <span className={styles.consentDetailValue}>
                                  {new Date(consent.expires_at).toLocaleDateString("ru-RU")}
                                </span>
                              </div>
                            )}
                            <div className={styles.consentDetail}>
                              <span className={styles.consentDetailLabel}>Статус:</span>
                              <span className={styles.consentDetailValue}>{consent.status}</span>
                            </div>
                          </div>
                          <Button
                            size="sm"
                            onClick={() => handleCreateConsent(bankCode)}
                            disabled={creatingConsent[bankCode] || !hasBankUser}
                            className={styles.createConsentButton}
                          >
                            <Shield size={16} />
                            {creatingConsent[bankCode] ? "Создание..." : "Обновить согласие"}
                          </Button>
                        </div>
                      ) : (
                        <div className={styles.consentInfo}>
                          <div className={styles.consentEmpty}>
                            {hasBankUser ? (
                              <p>Согласие не создано. Нажмите кнопку ниже для создания.</p>
                            ) : (
                              <p>Сначала укажите ID пользователя в банке выше.</p>
                            )}
                          </div>
                          <Button
                            size="sm"
                            onClick={() => handleCreateConsent(bankCode)}
                            disabled={creatingConsent[bankCode] || !hasBankUser}
                            className={styles.createConsentButton}
                          >
                            <Shield size={16} />
                            {creatingConsent[bankCode] ? "Создание..." : "Создать согласие"}
                          </Button>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          <div className={styles.profileActions}>
            <Button
              variant="destructive"
              size="lg"
              onClick={handleLogout}
              className={styles.logoutButton}
            >
              Выйти
            </Button>
          </div>
        </div>
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/Receivables/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.summaryGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.tableWrap {
  overflow-x: auto;
}

.invoiceNumber {
  font-weight: 600;
  font-family: monospace;
}

.amount,
.paidAmount {
  font-weight: 600;
}

.overdueDays {
  color: $danger;
  font-size: 0.875rem;
  margin-left: 0.5rem;
}

.filters {
  display: flex;
  gap: 0.5rem;
}

.filterButton,
.filterActive {
  padding: 0.5rem 1rem;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $input;
  color: $foreground;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background-color: $input;
    border-color: $primary;
  }
}

.filterActive {
  background-color: $primary;
  color: white;
  border-color: $primary;
}

.badgeWarning {
  background-color: rgba(251, 191, 36, 0.1);
  color: #f59e0b;
}

.badgeSuccess {
  background-color: rgba(16, 185, 129, 0.1);
  color: #10b981;
}

.badgeDanger {
  background-color: rgba(239, 68, 68, 0.1);
  color: #ef4444;
}

.badgeInfo {
  background-color: rgba(59, 130, 246, 0.1);
  color: #3b82f6;
}

.badgeDefault {
  background-color: rgba(107, 114, 128, 0.1);
  color: #6b7280;
}
</file>

<file path="frontend/src/pages/Receivables/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../../ui/table";
import { Users, AlertCircle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getInvoices, getARSummary, type Invoice, type ARSummary } from "../../utils/api";
import StatCard from "../../components/StatCard";
import styles from "./index.module.scss";
import { toast } from "sonner";

export default function Receivables() {
  const { isAuthenticated } = useAuth();
  const [invoices, setInvoices] = useState<Invoice[]>([]);
  const [summary, setSummary] = useState<ARSummary["summary"] | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<string | undefined>(undefined);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const [invoicesRes, summaryRes] = await Promise.all([
          getInvoices(statusFilter),
          getARSummary(),
        ]);

        if (invoicesRes.data.success && invoicesRes.data.invoices) {
          setInvoices(invoicesRes.data.invoices);
        }

        if (summaryRes.data.success && summaryRes.data.summary) {
          setSummary(summaryRes.data.summary);
        }
      } catch (err: any) {
        console.error("Error fetching receivables:", err);
        setError(err.response?.data?.detail || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить данные о дебиторской задолженности");
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [isAuthenticated, statusFilter]);

  const getStatusBadge = (status: string) => {
    const statusMap: Record<string, { label: string; variant: string }> = {
      pending: { label: "Ожидает оплаты", variant: "warning" },
      partial: { label: "Частично оплачено", variant: "info" },
      paid: { label: "Оплачено", variant: "success" },
      overdue: { label: "Просрочено", variant: "danger" },
      cancelled: { label: "Отменено", variant: "default" },
    };

    const statusInfo = statusMap[status.toLowerCase()] || { label: status, variant: "default" };

    return (
      <Badge className={styles[`badge${statusInfo.variant.charAt(0).toUpperCase() + statusInfo.variant.slice(1)}`]}>
        {statusInfo.label}
      </Badge>
    );
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("ru-RU", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Дебиторская задолженность</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть счета к получению</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Дебиторская задолженность</h1>
          <p>Управление счетами к получению</p>
        </div>

        {summary && (
          <div className={styles.summaryGrid}>
            <StatCard
              title="Общая ДЗ"
              value={`₽${(summary.total_ar || 0).toLocaleString()}`}
              subtitle="Всего к получению"
              icon={Users}
              variant="default"
            />
            <StatCard
              title="Просрочено"
              value={`₽${(summary.overdue_ar || 0).toLocaleString()}`}
              subtitle={`${summary.overdue_count || 0} счетов`}
              icon={AlertCircle}
              variant="danger"
            />
            <StatCard
              title="Ожидает оплаты"
              value={`${summary.pending_count || 0}`}
              subtitle="Счетов"
              icon={Users}
              variant="warning"
            />
            <StatCard
              title="Оплачено"
              value={`${summary.paid_count || 0}`}
              subtitle="Счетов"
              icon={Users}
              variant="success"
            />
          </div>
        )}

        <Card>
          <CardHeader>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <CardTitle>Счета к получению</CardTitle>
              <div className={styles.filters}>
                <button
                  className={statusFilter === undefined ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter(undefined)}
                >
                  Все
                </button>
                <button
                  className={statusFilter === "pending" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("pending")}
                >
                  Ожидают
                </button>
                <button
                  className={statusFilter === "overdue" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("overdue")}
                >
                  Просрочено
                </button>
                <button
                  className={statusFilter === "paid" ? styles.filterActive : styles.filterButton}
                  onClick={() => setStatusFilter("paid")}
                >
                  Оплачено
                </button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Загрузка данных...</p>
              </div>
            ) : error ? (
              <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
                <p>{error}</p>
              </div>
            ) : invoices.length === 0 ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Нет счетов к получению</p>
              </div>
            ) : (
              <div className={styles.tableWrap}>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Номер счета</TableHead>
                      <TableHead>Контрагент</TableHead>
                      <TableHead>Дата</TableHead>
                      <TableHead>Срок оплаты</TableHead>
                      <TableHead>Сумма</TableHead>
                      <TableHead>Оплачено</TableHead>
                      <TableHead>Статус</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {invoices.map((invoice) => (
                      <TableRow key={invoice.id}>
                        <TableCell className={styles.invoiceNumber}>{invoice.invoice_number}</TableCell>
                        <TableCell>{invoice.counterparty_name}</TableCell>
                        <TableCell>{formatDate(invoice.invoice_date)}</TableCell>
                        <TableCell>
                          {formatDate(invoice.due_date)}
                          {invoice.days_overdue && invoice.days_overdue > 0 && (
                            <span className={styles.overdueDays}> ({invoice.days_overdue} дн.)</span>
                          )}
                        </TableCell>
                        <TableCell className={styles.amount}>
                          ₽{invoice.amount.toLocaleString("ru-RU", {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          })}
                        </TableCell>
                        <TableCell className={styles.paidAmount}>
                          ₽{invoice.paid_amount.toLocaleString("ru-RU", {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          })}
                        </TableCell>
                        <TableCell>{getStatusBadge(invoice.status)}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/Settings/index.module.scss">
@use "../../styles/vars" as *;

.container {
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.header {
  margin-bottom: 2rem;

  h1 {
    font-size: 2rem;
    font-weight: 700;
    color: $foreground;
    margin-bottom: 0.5rem;
  }

  p {
    color: $muted-foreground;
    font-size: 1rem;
  }
}

.icon {
  width: 1.5rem;
  height: 1.5rem;
  color: $primary;
}
</file>

<file path="frontend/src/pages/Settings/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Settings as SettingsIcon } from "lucide-react";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";

export default function Settings() {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Настройки</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы изменить настройки</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Настройки</h1>
          <p>Управление настройками приложения</p>
        </div>

        <Card>
          <CardHeader>
            <div style={{ display: "flex", alignItems: "center", gap: "0.75rem" }}>
              <SettingsIcon className={styles.icon} />
              <CardTitle>Настройки профиля</CardTitle>
            </div>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>
              Настройки профиля доступны на странице{" "}
              <a href="/profile" style={{ color: "var(--primary)", textDecoration: "underline" }}>
                Профиль
              </a>
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Уведомления</CardTitle>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>Настройки уведомлений будут доступны в будущих версиях</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Интеграции</CardTitle>
          </CardHeader>
          <CardContent>
            <p style={{ color: "#6b7280" }}>
              Управление банковскими интеграциями доступно на странице{" "}
              <a href="/profile" style={{ color: "var(--primary)", textDecoration: "underline" }}>
                Профиль
              </a>
            </p>
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/styles/colors.ts">
// This file colors for recharts

export const primary_hsl = "270 80% 65%";
export const accent_hsl = "180 95% 55%";

export const primary = `hsl(${primary_hsl})`;
export const accent = `hsl(${accent_hsl})`;

export const danger = `hsl(0 72% 58%)`;
export const border = `hsl(240 8% 18%)`;
export const muted_foreground = `hsl(210 20% 65%)`;
export const popover = `hsl(240 8% 12%)`;

export const primaryHslParts = primary_hsl.split(" ");
export const accentHslParts = accent_hsl.split(" ");

export default {
  primary,
  accent,
  danger,
  border,
  muted_foreground,
  popover,
};
</file>

<file path="frontend/src/styles/globals.scss">
/* Файл: src/styles/globals.scss */
@use "vars" as *;
@use "mixins" as *;

/* Базовые стили */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border-color: $border;
}

body {
  background-color: $background;
  color: $foreground;
  overflow-x: hidden;
  background-image: $gradient-glow;
  background-attachment: fixed;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Глобальные утилитарные классы */
.glass-card {
  @include glass-card(false);
}

.glass-card-hover {
  @include glass-card(true);
}

.gradient-primary {
  background: $gradient-primary;
}

.gradient-accent {
  background: $gradient-accent;
}

.text-glow {
  @include text-glow($primary);
}

/* Стили для скроллбара (по желанию) */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: 	#8c8c8c transparent;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #8c8c8c;
    border-radius: 20px;
  }
}
</file>

<file path="frontend/src/styles/main.scss">
@use "vars";
@use "mixins";
@use "globals";
</file>

<file path="frontend/src/styles/mixins.scss">
/* Файл: src/styles/mixins.scss */
@use "vars" as *;
@use "sass:color";

/* Миксин для "стеклянной" карточки 
  @include glass-card(true) для эффекта при наведении
*/
@mixin glass-card($hover-effect: false) {
  backdrop-filter: $blur-xl ;
  border: 1px solid $glass-border;
  background: $glass-bg;
  transition: all 0.3s ease;
  box-shadow: $shadow-soft;

  @if $hover-effect {
    &:hover {
      border-color: $popover;
      box-shadow: $shadow-medium, $shadow-glow;
      transform: translateY(-2px);
    }
  }
}

/* Миксин для свечения текста */
@mixin text-glow($color: $primary) {
  $as-hsl: color.to-space($color, hsl);
  text-shadow: 0 0 20px hsla(color.channel($as-hsl, "hue"),
      color.channel($as-hsl, "saturation"),
      color.channel($as-hsl, "lightness"),
      0.3);
}

/* Миксин для градиентного текста */
@mixin gradient-text($gradient) {
  background: $gradient;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-fill-color: transparent;
}
</file>

<file path="frontend/src/styles/vars.scss">
// Основные цвета
$background: #0f101a;
$foreground: #edf2f9;
$card: #12131a;
$popover: #171820;
$primary: #c67dff;
$primary-light: #d4a1ff;
$primary-glow: #e9d2ff;
$secondary: #1a1b22;
$accent: #00f5cc;
$accent-light: #33ffd5;
$accent-glow: #a8fff8;
$success: #00d6a3;
$success-light: #33e8b8;
$success-glow: #a3ffe9;
$warning: #ff9933;
$warning-light: #ffaf66;
$danger: #ff505f;
$danger-light: #ff7f8c;
$muted: #1a1b22;
$border: #282a33;
$input: #282a33;
$ring: #c67dff;

// Специальные цвета
$chart-1: $primary;
$chart-2: $accent;
$chart-3: $success;
$chart-4: #cf77ff;
$chart-5: $warning;

// Цвета для текста
$primary-foreground: $foreground;
$secondary-foreground: $foreground;
$accent-foreground: $background;
$success-foreground: $background;
$warning-foreground: $background;
$danger-foreground: $foreground;
$muted-foreground: #a0a7b6;
$destructive: $danger;
$destructive-foreground: $foreground;
$card-foreground: $foreground;
$popover-foreground: $foreground;

// Градиенты
$gradient-primary: linear-gradient(135deg, $primary 0%, #cf77ff 100%);
$gradient-accent: linear-gradient(135deg, $accent 0%, $success 100%);
$gradient-card: linear-gradient(135deg, $card 0%, #1d1e26 100%);
$gradient-glow: radial-gradient(circle at 50% 0%, rgba($primary, 0.15) 0%, transparent 60%);

// Тени
$shadow-soft: 0 2px 16px -4px rgba($primary, 0.15);
$shadow-medium: 0 8px 32px -8px rgba($primary, 0.25);
$shadow-strong: 0 16px 48px -12px rgba($primary, 0.35);
$shadow-glow: 0 0 40px rgba($primary, 0.2);

// Прочие переменные
$radius: 1.25rem;
$radius-md: calc($radius - 2px);
$radius-sm: calc($radius - 4px);
$radius-lg: 10px;
$transition-smooth: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
$transition-bounce: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
$glass-bg: rgba(#1c1d26, 0.4);
$glass-border: rgba($foreground, 0.1);
$blur-xl: blur(20px)
</file>

<file path="frontend/src/ui/badge/index.module.scss">
@use "../../styles/vars" as *;


.badge {
  display: inline-flex;
  align-items: center;
  border-radius: 9999px;
  border: 1px solid;
  padding: 0.125rem 0.625rem;
  font-size: 0.75rem; 
  font-weight: 600; 
  transition: background-color 0.2s, color 0.2s, border-color 0.2s;

  &:focus {
    outline: none;
    box-shadow: 0 0 0 2px $background, 0 0 0 4px $ring;
  }
}


.default {
  border-color: transparent;
  background-color: $primary;
  color: $primary-foreground;
  &:hover {
    background-color: rgba($primary, 0.8);
  }
}

.secondary {
  border-color: transparent;
  background-color: $secondary;
  color: $secondary-foreground;
  &:hover {
    background-color: rgba($secondary, 0.8);
  }
}

.destructive {
  border-color: transparent;
  background-color: $danger;
  color: $destructive-foreground;
  &:hover {
    background-color: rgba($danger, 0.8);
  }
}


.outline {
  color: $foreground;
  border-color: $border; 
}
</file>

<file path="frontend/src/ui/badge/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

type BadgeVariant = "default" | "secondary" | "destructive" | "outline";

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: BadgeVariant;
}

function Badge({ className, variant = "default", ...props }: BadgeProps) {
  return <div className={cn(styles.badge, styles[variant], className)} {...props} />;
}

export { Badge };
</file>

<file path="frontend/src/ui/button/index.module.scss">
@use "../../styles/vars" as *;

.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  white-space: nowrap;
  border-radius: $radius-md;
  font-size: 0.875rem;
  font-weight: 500;
  transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s;
  cursor: pointer;

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px $background, 0 0 0 4px $ring;
  }

  &:disabled {
    pointer-events: none;
    opacity: 0.5;
  }


  > svg {
    pointer-events: none;
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
  }


  height: 2.5rem;
  padding: 0.5rem 1rem;
}


.sm {
  height: 2.25rem;
  padding: 0 0.75rem;
}


.lg {
  height: 2.75rem;
  padding: 0 2rem;
}


.icon {
  height: 2.5rem;
  width: 2.5rem;
  padding: 0;
}



.default {
  background-color: $primary;
  color: $primary-foreground;
  border: 1px solid $primary;
  &:hover {
    background-color: rgba($primary, 0.9);
    border-color: rgba($primary, 0.9);
  }
}


.destructive {
  background-color: $danger;
  color: $destructive-foreground;
  border: 1px solid $danger;
  &:hover {
    background-color: rgba($danger, 0.9);
    border-color: rgba($danger, 0.9);
  }
}

.outline {
  border: 1px solid $input;
  background-color: $background;
  color: $foreground;
  &:hover {
    background-color: $accent;
    color: $accent-foreground;
    border-color: $accent;
  }
}

.secondary {
  background-color: $secondary;
  color: $secondary-foreground;
  border: 1px solid $secondary;
  &:hover {
    background-color: rgba($secondary, 0.8);
    border-color: rgba($secondary, 0.8);
  }
}


.ghost {
  background-color: transparent;
  border: 1px solid transparent;
  color: $foreground;
  &:hover {
    background-color: $accent;
    color: $accent-foreground;
  }
}


.link {
  background-color: transparent;
  border: 1px solid transparent;
  color: $primary;
  text-underline-offset: 4px;
  &:hover {
    text-decoration: underline;
  }
}
</file>

<file path="frontend/src/ui/button/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";


type ButtonVariant = "default" | "destructive" | "outline" | "secondary" | "ghost" | "link";
type ButtonSize = "default" | "sm" | "lg" | "icon";

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = "default", size = "default", ...props }, ref) => {
    return (
      <button
        className={cn(
          styles.button,
          styles[variant],
          size !== "default" && styles[size],
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button };
</file>

<file path="frontend/src/ui/card/index.module.scss">
@use "../../styles/vars" as *;

.card {
  border-radius: $radius-lg;
  border: 1px solid $border;
  background-color: $card;
  color: $card-foreground;
  box-shadow: $shadow-soft;
}


.cardHeader {
  display: flex;
  flex-direction: column;
  padding: 1.5rem;
  
  > *:not([hidden]) ~ *:not([hidden]) {
    margin-top: 0.375rem;
  }
}


.cardTitle {
  font-size: 1.5rem; 
  font-weight: 600;
  line-height: 1;
  letter-spacing: -0.025em;
}

.cardDescription {
  font-size: 0.875rem;
  color: $muted-foreground;
}

.cardContent {
  padding: 1.5rem;
  padding-top: 0;
}

.cardFooter {
  display: flex;
  align-items: center;
  padding: 1.5rem;
  padding-top: 0;
}
</file>

<file path="frontend/src/ui/card/index.tsx">
import {forwardRef, type HTMLAttributes} from "react";
import cn from "classnames";
import styles from "./index.module.scss";


const Card = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
    <div ref={ref} className={cn(styles.card, className)} {...props} />
));
Card.displayName = "Card";

const CardHeader = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => (
        <div ref={ref} className={cn(styles.cardHeader, className)} {...props} />
    ),
);
CardHeader.displayName = "CardHeader";

const CardTitle = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLHeadingElement>>(
    ({ className, ...props }, ref) => (
        <h3 ref={ref} className={cn(styles.cardTitle, className)} {...props} />
    ),
);
CardTitle.displayName = "CardTitle";

const CardDescription = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
    ({ className, ...props }, ref) => (
        <p ref={ref} className={cn(styles.cardDescription, className)} {...props} />
    ),
);
CardDescription.displayName = "CardDescription";

const CardContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => <div ref={ref} className={cn(styles.cardContent, className)} {...props} />,
);
CardContent.displayName = "CardContent";

const CardFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
    ({ className, ...props }, ref) => (
        <div ref={ref} className={cn(styles.cardFooter, className)} {...props} />
    ),
);
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="frontend/src/ui/input/index.module.scss">
@use "../../styles/vars.scss" as *;

.input {
  width: 100%;
  background-color: $input;
  border: 1px solid $border;
  color: $foreground;
  border-radius: $radius-md;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  transition: all 0.2s ease;
  font-family: inherit;

  &:focus {
    outline: none;
    border-color: $primary;
    box-shadow: 0 0 0 2px rgba($primary, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  &::placeholder {
    color: $muted-foreground;
  }

  &:-webkit-autofill,
  &:-webkit-autofill:hover,
  &:-webkit-autofill:focus,
  &:-webkit-autofill:active {
    -webkit-background-clip: text;
    -webkit-text-fill-color: $foreground;
    -webkit-box-shadow: 0 0 0px 1000px $input inset;
    box-shadow: 0 0 0px 1000px $input inset;
    transition: background-color 5000s ease-in-out 0s;
    border-color: $border;
  }
}
</file>

<file path="frontend/src/ui/input/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, ...props }, ref) => {
    return (
      <input
        className={cn(styles.input, className)}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="frontend/src/ui/label/index.module.scss">
@use "../../styles/vars.scss" as *;

.label {
  font-weight: 600;
  font-size: 0.875rem;
  color: $foreground;
  display: block;
  margin-bottom: 0.5rem;
  cursor: pointer;

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
}
</file>

<file path="frontend/src/ui/label/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

export interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {}

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => {
    return (
      <label
        className={cn(styles.label, className)}
        ref={ref}
        {...props}
      />
    );
  },
);
Label.displayName = "Label";

export { Label };
</file>

<file path="frontend/src/ui/sonner/index.tsx">
import { Toaster as Sonner, toast } from "sonner";
import "./sonner.module.scss";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      theme="light"
      className="toaster group"
      {...props}
    />
  );
};

export { Toaster, toast };
</file>

<file path="frontend/src/ui/sonner/sonner.module.scss">
// Custom styles for Sonner toasts - using :global to apply globally
:global {
  [data-sonner-toaster] {
    position: fixed !important;
    top: 20px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    right: auto !important;
    width: auto !important;
    margin: 0 !important;
    padding: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: flex-start !important;
  }
  
  [data-sonner-toaster][data-x-position="center"] {
    left: 50% !important;
    transform: translateX(-50%) !important;
    right: auto !important;
  }

  [data-sonner-toast] {
    min-width: 450px !important;
    max-width: 650px !important;
    font-size: 16px !important;
    padding: 18px 24px !important;
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15) !important;
    margin: 0 auto !important;
    position: relative !important;
    left: auto !important;
    right: auto !important;
    transform: none !important;
    opacity: 1 !important;
    transition: opacity 0.3s ease-out !important;
  }

  [data-sonner-toast][data-styled="true"] {
    min-width: 450px !important;
    max-width: 650px !important;
  }

  // Fade out animation when toast is dismissing
  [data-sonner-toast][data-removed="true"] {
    opacity: 0 !important;
    transition: opacity 0.3s ease-out !important;
  }

  [data-sonner-toast] [data-title] {
    font-size: 18px !important;
    font-weight: 600 !important;
    line-height: 1.4 !important;
    padding-right: 0 !important;
  }

  [data-sonner-toast] [data-description] {
    font-size: 15px !important;
    line-height: 1.5 !important;
    margin-top: 8px !important;
    opacity: 0.9 !important;
    padding-right: 0 !important;
  }

  [data-sonner-toast] [data-button] {
    font-size: 14px !important;
    padding: 8px 16px !important;
  }

  // Hide close button
  [data-sonner-toast] [data-close-button] {
    display: none !important;
  }
}
</file>

<file path="frontend/src/ui/table/index.module.scss">
@use "../../styles/vars" as *;

.tableWrapper {
  position: relative;
  width: 100%;
  overflow-x: auto;
}

.table {
  width: 100%;
  caption-side: bottom;
  font-size: 0.875rem;
}

.tableHeader {

  tr {
    border-bottom: 1px solid $border;
  }
}

.tableBody {
  tr:last-child {
    border-bottom: 0;
  }
}

.tableFooter {
  border-top: 1px solid $border;
  background-color: rgba($muted, 0.5);
  font-weight: 500;
  tr:last-child {
    border-bottom: 0;
  }
}

.tableRow {
  border-bottom: 1px solid $border;
  transition: background-color 0.2s;

  &[data-state="selected"] {
    background-color: $muted;
  }

  &:hover {
    background-color: rgba($muted, 0.5);
  }
}

.tableHead {
  height: 3rem; 
  padding: 0 1rem; 
  text-align: left;
  vertical-align: middle;
  font-weight: 500; 
  color: $muted-foreground;

  &:has([role="checkbox"]) {
    padding-right: 0;
  }
}

.tableCell {
  padding: 1rem;
  vertical-align: middle;

  &:has([role="checkbox"]) {
    padding-right: 0;
  }
}

.tableCaption {
  margin-top: 1rem; 
  font-size: 0.875rem; 
  color: $muted-foreground;
}
</file>

<file path="frontend/src/ui/table/index.tsx">
import * as React from "react";
import cn from "classnames";
import styles from "./index.module.scss";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className={styles.tableWrapper}>
      <table ref={ref} className={cn(styles.table, className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <thead ref={ref} className={cn(styles.tableHeader, className)} {...props} />
  ),
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn(styles.tableBody, className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn(styles.tableFooter, className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr ref={ref} className={cn(styles.tableRow, className)} {...props} />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th ref={ref} className={cn(styles.tableHead, className)} {...props} />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn(styles.tableCell, className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn(styles.tableCaption, className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };
</file>

<file path="frontend/src/ui/tooltip/index.module.scss">
@use "../../styles/vars" as *;


.tooltipContent {
  z-index: 50;
  overflow: hidden;
  border-radius: $radius-md;
  border: 1px solid $border;
  background-color: $popover;
  padding: 0.375rem 0.75rem;
  font-size: 0.875rem;
  color: $popover-foreground;
  box-shadow: $shadow-medium;
  
  &[data-state="open"] {
    animation: fade-in 0.2s ease;
  }
  &[data-state="closed"] {
    animation: fade-out 0.2s ease;
  }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}
</file>

<file path="frontend/src/ui/tooltip/index.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import cn from "classnames"
import styles from "./index.module.scss";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(styles.tooltipContent, className)}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="frontend/src/utils/cookies.ts">
import Cookies from 'js-cookie';


export function setCookie(name: string, value: string, days: number) {

  Cookies.set(name, value, { expires: days, path: '/' });
}

export function getCookie(name: string): string | null {
  return Cookies.get(name) || null;
}

export function eraseCookie(name: string) {
  Cookies.remove(name, { path: '/' });
}
</file>

<file path="frontend/src/utils/zod.ts">
import { z } from 'zod';

const passwordSchema = z.string()
    .min(8, 'Пароль должен содержать минимум 8 символов')
    .max(100, 'Пароль не должен превышать 100 символов')
    .regex(/[A-Z]/, 'Пароль должен содержать хотя бы одну заглавную букву')
    .regex(/[a-z]/, 'Пароль должен содержать хотя бы одну строчную букву')
    .regex(/[0-9]/, 'Пароль должен содержать хотя бы одну цифру')
    .default("");


export const zUserSignIn = z.object({
    email: z.email()
        .min(5, 'Email должен содержать минимум 5 символов')
        .max(100, 'Email не должен превышать 100 символов')
        .default(""),

    password: passwordSchema
})


export const zUserSignUp = zUserSignIn.extend({
    firstName: z.string()
        .min(2, 'Имя должно содержать минимум 2 символа')
        .max(50, 'Имя не должно превышать 50 символов')
        .regex(/^[a-zA-Zа-яА-ЯёЁ\s\-]+$/, 'Имя может содержать только буквы, пробелы и дефисы')
        .default(""),

    lastName: z.string()
        .min(2, 'Фамилия должна содержать минимум 2 символа')
        .max(50, 'Фамилия не должна превышать 50 символов')
        .regex(/^[a-zA-Zа-яА-ЯёЁ\s\-]+$/, 'Фамилия может содержать только буквы, пробелы и дефисы')
        .default(""),

    phone: z.string()
        .min(10, 'Телефон должен содержать минимум 10 цифр')
        .max(15, 'Телефон не должен превышать 15 символов')
        .regex(/^\+?[0-9\s\-\(\)]+$/, 'Введите корректный номер телефона')
        .default(""),

});

export type RegisterFormData = z.infer<typeof zUserSignUp>;
export type SignInFormData = z.infer<typeof zUserSignIn>;
</file>

<file path="frontend/src/App.tsx">
import { TooltipProvider } from "./ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Toaster } from "./ui/sonner";
import Home from "./pages/home";
import Profile from "./pages/Profile";
import CashFlow from "./pages/CashFlow";
import Health from "./pages/Health";
import Receivables from "./pages/Receivables";
import Payments from "./pages/Payments";
import Settings from "./pages/Settings";
import OAuthSuccess from "./pages/Auth/OAuthSuccess";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Toaster 
        position="top-center"
        richColors
        closeButton={false}
        duration={1500}
        toastOptions={{
          style: {
            minWidth: '400px',
            fontSize: '16px',
            padding: '16px 20px',
          },
          className: 'custom-toast',
        }}
      />
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="/cash-flow" element={<CashFlow />} />
          <Route path="/health" element={<Health />} />
          <Route path="/receivables" element={<Receivables />} />
          <Route path="/payments" element={<Payments />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/auth/success" element={<OAuthSuccess />} />
          {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import "./styles/main.scss";
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="frontend/.dockerignore">
node_modules
dist
.git
.gitignore
.env
.env.local
.DS_Store
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.vscode
.idea
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Windows Zone Identifier files
*.Zone.Identifier

# Codebase dumps
backend.xml
frontend.txt
</file>

<file path="frontend/Dockerfile">
# Multi-stage build for frontend
FROM node:20-alpine as builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build the app
RUN npm run build

# Production stage with nginx
FROM nginx:alpine

# Copy built files from builder
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="frontend/Dockerfile.dev">
# Development Dockerfile for frontend
FROM node:20-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy source code
COPY . .

# Expose Vite dev server port
EXPOSE 5173

# Start development server
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    rules: {
      '@typescript-eslint/no-unused-vars': 'warn',
      'no-useless-escape': "off"
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend-2</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/nginx.conf">
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript;

    # SPA routing - all routes go to index.html
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API proxy to backend
    location /api/ {
        proxy_pass http://app:8000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Auth endpoints (direct proxy)
    location /auth/ {
        proxy_pass http://app:8000/auth/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Users endpoints (direct proxy)
    location /users/ {
        proxy_pass http://app:8000/users/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
</file>

<file path="frontend/openapi.json">
{"openapi":"3.1.0","info":{"title":"Virtual Bank API","version":"2.1"},"paths":{"/auth/bank-token":{"post":{"tags":["0 Аутентификация вызывающей системы","0 Аутентификация вызывающей системы"],"summary":"Create Bank Token","description":"## 🎯 Получение токена для работы с API банка\n\n**Этот endpoint - точка входа для всех участников хакатона!**\n\nТокен выдается банком, У КОТОРОГО вы запрашиваете данные.\nКаждый банк подписывает токен своим приватным ключом (RS256).\n\n### Где взять credentials?\n\nПолучите у организаторов хакатона:\n- `client_id` — код вашей команды (например: team200)\n- `client_secret` — ваш секретный ключ (API key)\n\n### Пример запроса:\n\n```bash\n# Получить токен для запросов к VBank\nPOST https://vbank.open.bankingapi.ru/auth/bank-token\n?client_id=team200\n&client_secret=5OAaa4DYzYKfnOU6zbR34ic5qMm7VSMB\n\n# Ответ:\n{\n  \"access_token\": \"eyJ...\",\n  \"token_type\": \"bearer\",\n  \"client_id\": \"team200\",\n  \"expires_in\": 86400\n}\n```\n\n### Использование токена:\n\n```bash\nGET https://vbank.open.bankingapi.ru/accounts\nHeaders:\n  Authorization: Bearer eyJ...\n```\n\n### Важно:\n\n- Токен валиден 24 часа\n- Для каждого банка нужен свой токен (VBank, ABank, SBank)\n- Токен подписан приватным ключом банка (RS256)\n- Публичный ключ: `/.well-known/jwks.json`\n\n### Межбанковые запросы:\n\nДля получения данных клиента из другого банка добавьте:\n```\nX-Requesting-Bank: your_client_id\n```\nИ создайте согласие: `POST /account-consents`","operationId":"create_bank_token_auth_bank_token_post","parameters":[{"name":"client_id","in":"query","required":true,"schema":{"type":"string","description":"ID команды от организаторов","title":"Client Id"},"description":"ID команды от организаторов","example":"team200"},{"name":"client_secret","in":"query","required":true,"schema":{"type":"string","description":"Secret команды от организаторов","title":"Client Secret"},"description":"Secret команды от организаторов","example":"5OAaa4DYzYKfnOU6zbR34ic5qMm7VSMB"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts":{"get":{"tags":["2 Счета и балансы"],"summary":"1. Получить список счетов","description":"## 💳 Получение списка счетов клиента\n\n### Два режима работы:\n\n#### 1️⃣ Запрос своих счетов (в том же банке)\n```bash\nGET /accounts\nHeaders:\n  Authorization: Bearer <client_token>\n```\n\n#### 2️⃣ Межбанковый запрос (с согласием)\n```bash\nGET /accounts?client_id=cli-ab-001\nHeaders:\n  Authorization: Bearer <bank_token>\n  X-Requesting-Bank: team200\n  X-Consent-Id: <consent_id>\n```\n\n### Ответ содержит:\n- `account_id` — уникальный идентификатор счета\n- `currency` — валюта (RUB, USD, EUR)\n- `account_type` — тип счета (Personal, Business)\n- `nickname` — название счета\n- `servicer` — информация о банке\n\n### ⚠️ Важно для межбанковых запросов:\n1. Сначала создайте согласие: `POST /account-consents/request`\n2. Клиент должен одобрить согласие в банке-владельце счетов\n3. Используйте полученный `consent_id` в заголовке `X-Consent-Id`\n4. Укажите свой банк в `X-Requesting-Bank`\n\n### Примечание:\n- Без согласия межбанковый запрос вернет 403 с подсказкой, как получить согласие\n- Согласие имеет срок действия (обычно 90 дней)","operationId":"get_accounts_accounts_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (например team200-1). Обязателен для межбанковых запросов","title":"Client Id"},"description":"ID клиента (например team200-1). Обязателен для межбанковых запросов","example":"team200-1"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["2 Счета и балансы"],"summary":"5. Создать счет","description":"Создание нового счета\n\nПоддерживаемые типы: checking, savings\n\n### 🔑 Аутентификация:\n- **client_token**: Клиент создает счет САМОСТОЯТЕЛЬНО - согласие НЕ требуется\n- **bank_token**: Другой банк создает счет ОТ ИМЕНИ клиента - ТРЕБУЕТСЯ согласие!\n\n### 🔐 Требования для межбанкового создания счета:\nПри использовании `bank_token` обязательно:\n1. **Query parameter:** `client_id` - ID клиента\n2. **Header:** `X-Requesting-Bank` - ваш bank_code\n3. **Header:** `X-Consent-Id` - ID активного согласия\n4. **Согласие должно иметь permission:** `ManageAccounts`\n\n### Получение согласия:\n```bash\nPOST /account-consents\n{\n  \"data\": {\n    \"permissions\": [\"ManageAccounts\"],\n    \"expirationDateTime\": \"2025-12-31T23:59:59Z\"\n  }\n}\n```\n\nКлиент должен одобрить согласие в своем банке.","operationId":"create_account_accounts_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID запрашивающего банка","title":"X-Requesting-Bank"},"description":"ID запрашивающего банка"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия","title":"X-Consent-Id"},"description":"ID согласия"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateAccountRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}":{"get":{"tags":["2 Счета и балансы"],"summary":"2. Получить детали счета","description":"Получение детальной информации о счете\n\n**Требует:** Client token (для своих счетов) или Bank token с согласием (межбанк)","operationId":"get_account_accounts__account_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/balances":{"get":{"tags":["2 Счета и балансы"],"summary":"3. Получить баланс счета","description":"Получение баланса счета\n\n**Требует:** Client token (для своих счетов) или Bank token с согласием (межбанк)","operationId":"get_balances_accounts__account_id__balances_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/transactions":{"get":{"tags":["2 Счета и балансы"],"summary":"4. Получить историю транзакций","description":"Получение списка транзакций по счету\n\n**Пагинация:**\n- `page` — номер страницы (по умолчанию: 1)\n- `limit` — количество транзакций на странице (по умолчанию: 50, макс: 500)\n\n**Примеры:**\n- `GET /accounts/acc-1/transactions` — первые 50 транзакций\n- `GET /accounts/acc-1/transactions?page=2&limit=100` — следующие 100 транзакций\n- `GET /accounts/acc-1/transactions?limit=200` — первые 200 транзакций","operationId":"get_transactions_accounts__account_id__transactions_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","description":"ID счета","title":"Account Id"},"description":"ID счета","example":"acc-1010"},{"name":"from_booking_date_time","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"From Booking Date Time"},"example":"2025-01-01T00:00:00Z"},{"name":"to_booking_date_time","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"To Booking Date Time"},"example":"2025-12-31T23:59:59Z"},{"name":"page","in":"query","required":false,"schema":{"type":"integer","default":1,"title":"Page"},"example":1},{"name":"limit","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"default":50,"title":"Limit"},"example":50},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","title":"X-Consent-Id"},"description":"ID согласия (получите через POST /account-consents/request). Обязателен для межбанковых запросов","example":"consent-69e75facabba"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для запроса данных из другого банка","example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/status":{"put":{"tags":["2 Счета и балансы"],"summary":"6. Изменить статус счета","description":"Изменение статуса счета (закрытие)\n\nДопустимые статусы: active, closed\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"update_account_status_accounts__account_id__status_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","title":"Account Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AccountStatusUpdate"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/accounts/{account_id}/close":{"put":{"tags":["2 Счета и балансы"],"summary":"7. Закрыть счет с остатком","description":"Закрытие счета с переводом остатка или дарением банку\n\nActions:\n- transfer: перевести остаток на другой счет\n- donate: подарить остаток банку (увеличить capital)\n\n### 🔑 Аутентификация:\n- **client_token**: Клиент закрывает счет САМОСТОЯТЕЛЬНО - согласие НЕ требуется\n- **bank_token**: Другой банк закрывает счет ОТ ИМЕНИ клиента - ТРЕБУЕТСЯ согласие!\n\n### 🔐 Требования для межбанкового закрытия счета:\nПри использовании `bank_token` обязательно:\n1. **Query parameter:** `client_id` - ID клиента\n2. **Header:** `X-Requesting-Bank` - ваш bank_code\n3. **Header:** `X-Consent-Id` - ID активного согласия\n4. **Согласие должно иметь permission:** `ManageAccounts`","operationId":"close_account_with_balance_accounts__account_id__close_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"account_id","in":"path","required":true,"schema":{"type":"string","title":"Account Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID запрашивающего банка","title":"X-Requesting-Bank"},"description":"ID запрашивающего банка"},{"name":"x-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID согласия","title":"X-Consent-Id"},"description":"ID согласия"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AccountCloseRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards":{"get":{"tags":["8 Карты"],"summary":"1. Получить список карт","description":"Получить список всех карт клиента\n\n**Возвращает:**\n- Список карт с маскированными номерами\n- Информацию о привязанных счетах\n- Лимиты и статусы\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ReadCards`\n- Заголовки: `X-Requesting-Bank`, `X-Consent-Id`","operationId":"get_cards_cards_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["8 Карты"],"summary":"3. Выпустить новую карту","description":"Выпустить новую карту и привязать к счету\n\n**Требования:**\n- Счет должен быть типа checking или savings\n- Счет должен принадлежать клиенту\n- К одному счету можно привязать несколько карт\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"create_card_cards_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateCardRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}":{"get":{"tags":["8 Карты"],"summary":"2. Получить детали карты","description":"Получить детальную информацию о карте\n\n**Параметры:**\n- `show_full_number=true` - показать полный номер (только для владельца)\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ReadCards`\n- Полный номер карты доступен только владельцу (локальный запрос)","operationId":"get_card_details_cards__card_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"show_full_number","in":"query","required":false,"schema":{"type":"boolean","description":"Показать полный номер карты","default":false,"title":"Show Full Number"},"description":"Показать полный номер карты"},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["8 Карты"],"summary":"6. Удалить карту","description":"Удалить карту (перевыпуск или закрытие)\n\n**Важно:** Счет остается активным, удаляется только карта\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"delete_card_cards__card_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}/status":{"put":{"tags":["8 Карты"],"summary":"4. Изменить статус карты","description":"Изменить статус карты (блокировка/разблокировка)\n\n**Статусы:**\n- `active` - активна\n- `blocked` - заблокирована\n- `expired` - истек срок действия\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"update_card_status_cards__card_id__status_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateCardStatusRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/cards/{card_id}/limits":{"put":{"tags":["8 Карты"],"summary":"5. Обновить лимиты карты","description":"Обновить дневной и месячный лимиты карты\n\n**Межбанковый доступ:**\n- Требуется согласие с permission `ManageCards`","operationId":"update_card_limits_cards__card_id__limits_put","security":[{"HTTPBearer":[]}],"parameters":[{"name":"card_id","in":"path","required":true,"schema":{"type":"string","title":"Card Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (для bank_token)","title":"Client Id"},"description":"ID клиента (для bank_token)"},{"name":"X-Requesting-Bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}},{"name":"X-Consent-Id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Consent-Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CardLimitsRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/account-consents/request":{"post":{"tags":["1 Согласия на доступ к счетам"],"summary":"1. Создать согласие","description":"Создание согласия на доступ к счетам клиента\n\nСогласия нужны для доступа к данным клиентов из других банков.\nПосле создания согласия вы сможете запрашивать счета, балансы и транзакции.\n\n### Пример использования:\n\n```bash\n# 1. Получить токен банка, где лежат данные клиента\nPOST https://vbank.open.bankingapi.ru/auth/bank-token\n?client_id=team200&client_secret=YOUR_SECRET\n→ {\"access_token\": \"eyJhbG...\"}\n\n# 2. Запросить согласие (авто-одобрение)\nPOST https://vbank.open.bankingapi.ru/account-consents/request\nHeaders:\n  Authorization: Bearer eyJhbG...\n  X-Requesting-Bank: team200\nBody:\n{\n  \"client_id\": \"team200-1\",\n  \"permissions\": [\"ReadAccountsDetail\", \"ReadBalances\"],\n  \"reason\": \"Агрегация счетов для HackAPI\",\n  \"requesting_bank\": \"team200\",\n  \"requesting_bank_name\": \"Team 200 App\"\n}\n\n→ {\"status\": \"approved\", \"consent_id\": \"consent-abc123\", \"auto_approved\": true}\n\n# 3. Запросить данные\nGET https://vbank.open.bankingapi.ru/accounts?client_id=team200-1\nHeaders:\n  Authorization: Bearer eyJhbG...\n  X-Requesting-Bank: team200\n  X-Consent-Id: consent-abc123\n\n→ 200 OK {\"accounts\": [...]}\n```\n\n### ⚠️ Частые ошибки:\n\n1. **X-Requesting-Bank: team200-1** ❌ НЕПРАВИЛЬНО!  \n   Должно быть **team200** (ID команды, без суффикса клиента)\n\n2. **Забыли X-Consent-Id** → получите 403 CONSENT_REQUIRED\n\n3. **Используете client_token вместо bank_token** → 401 Unauthorized\n\n### Что происходит внутри:\n1. Создаётся запрос согласия для клиента\n2. Если банк настроен на авто-одобрение (VBank, ABank):\n   - Согласие одобряется автоматически\n   - Можно сразу запрашивать данные\n3. Если банк требует ручное одобрение (SBank):\n   - Клиент увидит запрос в своём UI\n   - Должен подтвердить через кнопку \"Подписать\"\n   - После этого ваше приложение может запрашивать данные","operationId":"request_consent_account_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для создания согласия","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для создания согласия","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConsentRequestBody"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/account-consents/{consent_id}":{"get":{"tags":["1 Согласия на доступ к счетам"],"summary":"2. Получить согласие по ID","description":"Получение ресурса согласия\n\nВозвращает информацию о согласии и его текущий статус.","operationId":"get_account_access_consents_consent_id_account_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","description":"ID согласия","title":"Consent Id"},"description":"ID согласия","example":"consent-d8f0724a4775"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Fapi-Interaction-Id"},"example":"team200"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConsentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["1 Согласия на доступ к счетам"],"summary":"3. Отозвать согласие","description":"Удаление ресурса согласия (отзыв)\n\nИзменяет статус согласия на \"Revoked\" (отозвано).","operationId":"delete_account_access_consents_consent_id_account_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","description":"ID согласия для отзыва","title":"Consent Id"},"description":"ID согласия для отзыва","example":"consent-d8f0724a4775"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Fapi-Interaction-Id"},"example":"team200"}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payment-consents/request":{"post":{"tags":["3 Согласия на переводы"],"summary":"1. Создать запрос согласия на перевод","description":"## 💳 Создание запроса на согласие для платежа\n\n**OpenBanking Russia Payment Consents API**\n\n### Поддерживаемые типы:\n\n#### 1. Single Use (одноразовый)\n\n**С указанием получателя (платеж только на этот счет):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"single_use\",\n  \"amount\": 5000.00,\n  \"debtor_account\": \"40817810...\",\n  \"creditor_account\": \"40817820...\",\n  \"creditor_name\": \"Иван Иванов\",\n  \"reference\": \"Оплата услуг\"\n}\n```\n\n**БЕЗ указания получателя (платеж любому, но только один раз):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"single_use\",\n  \"amount\": 5000.00,\n  \"debtor_account\": \"40817810...\",\n  \"reference\": \"Оплата услуг\"\n}\n```\n\n#### 2. Multi Use (многоразовый)\n\n**С ограничением по получателям:**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"multi_use\",\n  \"debtor_account\": \"40817810...\",\n  \"max_uses\": 10,\n  \"max_amount_per_payment\": 5000.00,\n  \"max_total_amount\": 50000.00,\n  \"allowed_creditor_accounts\": [\"40817820...\", \"40817830...\"],\n  \"valid_until\": \"2025-12-31T23:59:59\"\n}\n```\n\n**БЕЗ ограничения по получателям (любые счета в рамках лимитов):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"multi_use\",\n  \"debtor_account\": \"40817810...\",\n  \"max_uses\": 10,\n  \"max_amount_per_payment\": 5000.00,\n  \"max_total_amount\": 50000.00,\n  \"valid_until\": \"2025-12-31T23:59:59\"\n}\n```\n\n#### 3. VRP (переменные платежи)\n\n**Без ограничений по получателям (типичный случай для подписок):**\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"consent_type\": \"vrp\",\n  \"debtor_account\": \"40817810...\",\n  \"vrp_max_individual_amount\": 1000.00,\n  \"vrp_daily_limit\": 3000.00,\n  \"vrp_monthly_limit\": 50000.00,\n  \"valid_until\": \"2026-01-01T00:00:00\"\n}\n```","operationId":"create_payment_consent_request_payment_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID вашей команды (от организаторов). Укажите для создания согласия на переводы","title":"X-Requesting-Bank"},"description":"ID вашей команды (от организаторов). Укажите для создания согласия на переводы","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentConsentRequestData"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Create Payment Consent Request Payment Consents Request Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payment-consents/{consent_id}":{"get":{"tags":["3 Согласия на переводы"],"summary":"2. Получить согласие по ID","description":"## 📋 Получение согласия на платеж\n\nВозвращает детали согласия со всеми лимитами и использованием","operationId":"get_payment_consent_payment_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Get Payment Consent Payment Consents  Consent Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["3 Согласия на переводы"],"summary":"3. Отозвать согласие","description":"## 🗑️ Отзыв согласия на платеж","operationId":"revoke_payment_consent_payment_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payments":{"post":{"tags":["4 Переводы"],"summary":"1. Создать платеж","description":"## 💸 Создание платежа (разовый перевод)\n\n### 🔑 Аутентификация:\n- **С bank_token**: Укажите параметр `client_id` (например: team200-1)\n- **С client_token**: Параметр `client_id` не нужен\n\n### Два типа платежей:\n\n#### 1️⃣ Внутрибанковский перевод (тот же банк)\n```json\n{\n  \"data\": {\n    \"initiation\": {\n      \"instructedAmount\": {\n        \"amount\": \"1000.00\",\n        \"currency\": \"RUB\"\n      },\n      \"debtorAccount\": {\n        \"schemeName\": \"RU.CBR.PAN\",\n        \"identification\": \"40817810099910004312\"\n      },\n      \"creditorAccount\": {\n        \"schemeName\": \"RU.CBR.PAN\",\n        \"identification\": \"40817810099910005423\"\n      },\n      \"comment\": \"Оплата за услуги\"\n    }\n  }\n}\n```\n\n💡 **Поле `comment`** - необязательное, но рекомендуется для удобства учета\n\n#### 2️⃣ Межбанковский перевод\nДобавьте в `creditorAccount`:\n```json\n{\n  \"creditorAccount\": {\n    \"identification\": \"40817810099910001234\",\n    \"bank_code\": \"abank\"  // Код банка получателя\n  }\n}\n```\n\n### Статусы платежа:\n- `pending` — ожидает обработки\n- `completed` — успешно выполнен\n- `failed` — ошибка (недостаточно средств, счет не найден)\n\n### Проверка статуса:\n```bash\nGET /payments/{payment_id}\n```\n\n### ⚠️ Важно:\n- **bank_token**: укажите `client_id` в параметрах запроса (обязательно)\n- Проверяйте баланс счета перед платежом: `GET /accounts/{account_id}/balances`\n- Счет списания (`debtorAccount`) должен принадлежать авторизованному клиенту\n- Для межбанковых переводов используйте правильный `bank_code`\n- Коды банков: `vbank`, `abank`, `sbank`\n\n### Sandbox особенности:\n- Межбанковые переводы выполняются мгновенно\n- Комиссия не взимается\n- Все валюты конвертируются по курсу 1:1 для упрощения","operationId":"create_payment_payments_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей транзакции для отслеживания","title":"X-Fapi-Interaction-Id"},"description":"(Опционально) ID вашей транзакции для отслеживания","example":"team200-pay-001"},{"name":"x-fapi-customer-ip-address","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) IP адрес клиента","title":"X-Fapi-Customer-Ip-Address"},"description":"(Опционально) IP адрес клиента","example":"192.168.1.100"},{"name":"x-payment-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID согласия на перевод","title":"X-Payment-Consent-Id"},"description":"(Опционально) ID согласия на перевод","example":"pcon-49ecbbe683b4"},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей команды для межбанковых переводов","title":"X-Requesting-Bank"},"description":"(Опционально) ID вашей команды для межбанковых переводов","example":"team200"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentRequest"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/payments/{payment_id}":{"get":{"tags":["4 Переводы"],"summary":"2. Получить статус платежа","description":"Получение статуса платежа\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"get_payment_payments__payment_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"payment_id","in":"path","required":true,"schema":{"type":"string","title":"Payment Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-fapi-interaction-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"(Опционально) ID вашей транзакции для отслеживания","title":"X-Fapi-Interaction-Id"},"description":"(Опционально) ID вашей транзакции для отслеживания","example":"team200-pay-001"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PaymentResponse"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/products":{"get":{"tags":["5 Каталог продуктов"],"summary":"1. Получить каталог продуктов","description":"## 🧩 Каталог банковских продуктов\n\n### Получение списка всех доступных продуктов банка\n\n#### Типы продуктов:\n- `deposit` — вклады/депозиты\n- `loan` — кредиты (потребительские, ипотека, авто)\n- `card` — банковские карты (дебетовые, кредитные)\n- `account` — расчетные счета\n\n#### Фильтрация:\n```bash\nGET /products?product_type=deposit\n```\n\n### Ответ содержит:\n- `productId` — уникальный ID продукта\n- `productType` — тип продукта\n- `productName` — название\n- `description` — описание\n- `interestRate` — процентная ставка (для депозитов/кредитов)\n- `minAmount` / `maxAmount` — лимиты по сумме\n- `termMonths` — срок (в месяцах)\n\n### 🚀 Продуктовая воронка:\n\n1. **Каталог** → `GET /products` (этот endpoint)\n2. **Лид** → `POST /customer-leads` (оставить заявку на консультацию)\n3. **Предложение** → `GET /product-offers` (получить персональное предложение)\n4. **Заявка** → `POST /product-application` (подать заявку на продукт)\n5. **Договор** → `POST /product-agreements` (открыть продукт)\n\n### Примеры продуктов в sandbox:\n- **Вклад \"Надежный\"**: 8.5% годовых, от 10,000₽\n- **Потребительский кредит**: 12.9% годовых, до 3,000,000₽\n- **Дебетовая карта \"Свобода\"**: с кэшбэком 2%\n\n### 🔐 Аутентификация:\n- **Client token**: клиент просматривает продукты своего банка\n- **Bank token**: другой банк просматривает продукты для межбанковских операций\n\n### ⚠️ Обратите внимание:\n- Каталог требует авторизацию (client или bank token)\n- Для подачи заявки требуется авторизация клиента\n- Условия могут отличаться для разных банков","operationId":"get_products_products_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"product_type","in":"query","required":false,"schema":{"type":"string","title":"Product Type"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/products/{product_id}":{"get":{"tags":["5 Каталог продуктов"],"summary":"2. Получить детали продукта","description":"## 📋 Детальная информация о продукте\n\nПолучение подробных условий конкретного банковского продукта.\n\n### Пример запроса:\n```bash\nGET /products/prod-vb-deposit-001\n```\n\n### Когда использовать:\n- После выбора продукта из каталога\n- Перед созданием лида или заявки\n- Для отображения деталей на странице продукта\n\n### Полезно для UI:\n- Показать полные условия\n- Вычислить предварительную сумму выплат по кредиту\n- Сравнить с другими продуктами","operationId":"get_product_products__product_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"product_id","in":"path","required":true,"schema":{"type":"string","title":"Product Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreements":{"get":{"tags":["7 Договоры с продуктами"],"summary":"1. Получить список договоров","description":"Получить список договоров клиента\n\nВозвращает все активные договоры с продуктами (депозиты, кредиты, карты)\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `read_product_agreements`","operationId":"get_agreements_product_agreements_get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"post":{"tags":["7 Договоры с продуктами"],"summary":"2. Открыть продукт","description":"Открыть договор с продуктом (депозит, кредит, карта)\n\n- Депозит: создается счет, деньги списываются с основного счета\n- Кредит: проверяется капитал банка, создается счет с кредитными средствами\n- Карта: создается счет с лимитом\n\n### 🎯 Скоринг для кредитов:\nМаксимальная **СУММАРНАЯ** сумма всех активных кредитов зависит от сегмента клиента:\n- **student** (студент): до 900,000₽ (30% от лимита)\n- **pensioner** (пенсионер): до 1,200,000₽ (40%)\n- **employee** (сотрудник): до 1,800,000₽ (60%)\n- **entrepreneur** (ИП): до 2,400,000₽ (80%)\n- **vip**: до 3,000,000₽ (100%)\n- **business** (бизнес): до 3,000,000₽ (100%)\n\n⚠️ Проверяется сумма ВСЕХ активных кредитов клиента!\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `open_product_agreements`\n- Сумма не должна превышать `max_amount` согласия\n- Тип продукта должен быть в списке `allowed_product_types`","operationId":"create_agreement_product_agreements_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProductAgreementRequest"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreements/{agreement_id}":{"get":{"tags":["7 Договоры с продуктами"],"summary":"3. Получить детали договора","description":"Получить детали договора\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `read_product_agreements`","operationId":"get_agreement_product_agreements__agreement_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"agreement_id","in":"path","required":true,"schema":{"type":"string","title":"Agreement Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["7 Договоры с продуктами"],"summary":"4. Закрыть договор","description":"Закрыть договор\n\n- Депозит: закрыть счет\n- Кредит: погасить задолженность из указанного счета\n- Карта: заблокировать\n\n### 🔑 Аутентификация:\n- **bank_token**: укажите `client_id` в query параметре\n- **client_token**: `client_id` определится автоматически\n\n### Для межбанковых запросов:\n- Требуется заголовок `x-product-agreement-consent-id`\n- Требуется заголовок `x-requesting-bank`\n- Согласие должно иметь разрешение `close_product_agreements`","operationId":"close_agreement_product_agreements__agreement_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"agreement_id","in":"path","required":true,"schema":{"type":"string","title":"Agreement Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"},{"name":"x-product-agreement-consent-id","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Product-Agreement-Consent-Id"}},{"name":"x-requesting-bank","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"X-Requesting-Bank"}}],"requestBody":{"content":{"application/json":{"schema":{"anyOf":[{"$ref":"#/components/schemas/CloseAgreementRequest"},{"type":"null"}],"title":"Request"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreement-consents/request":{"post":{"tags":["6 Согласия на управление договорами"],"summary":"1. Создать запрос согласия на управление договорами","description":"## 📋 Создание запроса на согласие для управления договорами\n\n**OpenBanking Russia Products API Extension**\n\n### 🔑 Аутентификация:\n- **bank_token** (type=\"team\"): укажите `client_id` в query параметре\n- **client_token** (type=\"client\"): `client_id` определится автоматически\n\n### Use Case:\nФинансовый агрегатор или маркетплейс хочет:\n- Показывать все продукты клиента из разных банков\n- Открывать депозиты/карты от имени клиента\n- Закрывать неактуальные договоры\n\n### Пример запроса:\n```json\n{\n  \"requesting_bank\": \"team200\",\n  \"client_id\": \"team200-1\",\n  \"read_product_agreements\": true,\n  \"open_product_agreements\": true,\n  \"close_product_agreements\": false,\n  \"allowed_product_types\": [\"deposit\", \"card\"],\n  \"max_amount\": 1000000.00,\n  \"valid_until\": \"2025-12-31T23:59:59\",\n  \"reason\": \"Финансовый агрегатор для управления продуктами\"\n}\n```\n\n### Разрешения:\n- `read_product_agreements`: просмотр списка договоров (депозиты, кредиты, карты)\n- `open_product_agreements`: открытие новых продуктов\n- `close_product_agreements`: закрытие существующих договоров\n\n### Ограничения:\n- `allowed_product_types`: только указанные типы продуктов\n- `max_amount`: макс сумма для открытия одного продукта","operationId":"create_product_agreement_consent_request_product_agreement_consents_request_post","security":[{"HTTPBearer":[]}],"parameters":[{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ProductAgreementConsentRequestData"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Create Product Agreement Consent Request Product Agreement Consents Request Post"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/product-agreement-consents/{consent_id}":{"get":{"tags":["6 Согласия на управление договорами"],"summary":"2. Получить согласие по ID","description":"## 📋 Получение согласия на управление договорами\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"get_product_agreement_consent_product_agreement_consents__consent_id__get","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","title":"Response Get Product Agreement Consent Product Agreement Consents  Consent Id  Get"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}},"delete":{"tags":["6 Согласия на управление договорами"],"summary":"3. Отозвать согласие","description":"## 🗑️ Отзыв согласия на управление договорами\n\n### 🔑 Аутентификация:\n- **client_token**: `client_id` определится автоматически\n- **bank_token**: укажите `client_id` в query параметре","operationId":"revoke_product_agreement_consent_product_agreement_consents__consent_id__delete","security":[{"HTTPBearer":[]}],"parameters":[{"name":"consent_id","in":"path","required":true,"schema":{"type":"string","title":"Consent Id"}},{"name":"client_id","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"ID клиента (обязательно для bank_token)","title":"Client Id"},"description":"ID клиента (обязательно для bank_token)","example":"team200-1"}],"responses":{"204":{"description":"Successful Response"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}},"/.well-known/jwks.json":{"get":{"tags":["Technical: Well-Known"],"summary":"Get Jwks","description":"JWKS endpoint - публичные ключи банка\n\nOpenID Connect Discovery\nRFC 7517 - JSON Web Key (JWK)\n\nИспользуется другими банками для проверки JWT подписей\nпри межбанковских запросах.","operationId":"get_jwks__well_known_jwks_json_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/":{"get":{"summary":"Root","description":"Root endpoint","operationId":"root__get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}},"/health":{"get":{"summary":"Health","description":"Health check endpoint","operationId":"health_health_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}}}}}},"components":{"schemas":{"AccountCloseRequest":{"properties":{"action":{"type":"string","title":"Action"},"destination_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Destination Account Id"}},"type":"object","required":["action"],"title":"AccountCloseRequest","description":"Запрос на закрытие счета с переводом остатка"},"AccountStatusUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"AccountStatusUpdate","description":"Обновление статуса счета"},"CardLimitsRequest":{"properties":{"daily_limit":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Daily Limit","description":"Дневной лимит"},"monthly_limit":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Monthly Limit","description":"Месячный лимит"}},"type":"object","title":"CardLimitsRequest","description":"Запрос на обновление лимитов карты"},"CloseAgreementRequest":{"properties":{"repayment_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Repayment Account Id"},"repayment_amount":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Repayment Amount"}},"type":"object","title":"CloseAgreementRequest","description":"Запрос на закрытие договора с погашением"},"ConsentData":{"properties":{"consentId":{"type":"string","title":"Consentid"},"status":{"type":"string","title":"Status"},"creationDateTime":{"type":"string","title":"Creationdatetime"},"statusUpdateDateTime":{"type":"string","title":"Statusupdatedatetime"},"permissions":{"items":{"type":"string"},"type":"array","title":"Permissions"},"expirationDateTime":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Expirationdatetime"}},"type":"object","required":["consentId","status","creationDateTime","statusUpdateDateTime","permissions"],"title":"ConsentData","description":"Данные согласия в ответе"},"ConsentRequestBody":{"properties":{"client_id":{"type":"string","title":"Client Id","description":"Person ID клиента","example":"team200-1"},"permissions":{"items":{"type":"string"},"type":"array","title":"Permissions","description":"Список разрешений","example":["ReadAccountsDetail","ReadBalances","ReadTransactionsDetail"]},"reason":{"type":"string","title":"Reason","description":"Причина запроса","default":"","example":"Агрегация счетов для мультибанк-приложения"},"requesting_bank":{"type":"string","title":"Requesting Bank","description":"ID вашей команды (БЕЗ суффикса!)","default":"test_bank","example":"team200"},"requesting_bank_name":{"type":"string","title":"Requesting Bank Name","description":"Название приложения","default":"Test Bank","example":"Team 200 App"}},"type":"object","required":["client_id","permissions"],"title":"ConsentRequestBody","description":"Body для запроса согласия"},"ConsentResponse":{"properties":{"data":{"$ref":"#/components/schemas/ConsentData"},"links":{"type":"object","title":"Links"},"meta":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Meta","default":{}}},"type":"object","required":["data","links"],"title":"ConsentResponse","description":"Ответ с согласием"},"CreateAccountRequest":{"properties":{"account_type":{"type":"string","title":"Account Type"},"initial_balance":{"type":"number","title":"Initial Balance","default":0}},"type":"object","required":["account_type"],"title":"CreateAccountRequest","description":"Запрос на создание нового счета"},"CreateCardRequest":{"properties":{"account_number":{"type":"string","title":"Account Number","description":"Номер счета для привязки карты"},"card_name":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Card Name","description":"Название карты","default":"Visa Classic"},"card_type":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Card Type","description":"Тип карты: debit или credit","default":"debit"}},"type":"object","required":["account_number"],"title":"CreateCardRequest","description":"Запрос на создание новой карты"},"HTTPValidationError":{"properties":{"detail":{"items":{"$ref":"#/components/schemas/ValidationError"},"type":"array","title":"Detail"}},"type":"object","title":"HTTPValidationError"},"PaymentConsentRequestData":{"properties":{"requesting_bank":{"type":"string","title":"Requesting Bank","description":"Код банка-инициатора"},"client_id":{"type":"string","title":"Client Id","description":"ID клиента"},"consent_type":{"$ref":"#/components/schemas/PaymentConsentType","description":"Тип согласия","default":"single_use"},"amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Amount","description":"Сумма платежа"},"currency":{"type":"string","title":"Currency","description":"Валюта","default":"RUB"},"debtor_account":{"type":"string","title":"Debtor Account","description":"Счет списания"},"creditor_account":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Creditor Account","description":"Счет получателя (для single_use)"},"creditor_name":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Creditor Name","description":"Имя получателя"},"reference":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reference","description":"Назначение платежа"},"max_uses":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Max Uses","description":"Макс количество использований"},"max_amount_per_payment":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Amount Per Payment","description":"Макс сумма одного платежа"},"max_total_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Total Amount","description":"Макс общая сумма"},"allowed_creditor_accounts":{"anyOf":[{"items":{"type":"string"},"type":"array"},{"type":"null"}],"title":"Allowed Creditor Accounts","description":"Разрешенные счета"},"vrp_max_individual_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Max Individual Amount","description":"VRP: макс сумма платежа"},"vrp_daily_limit":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Daily Limit","description":"VRP: дневной лимит"},"vrp_monthly_limit":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Vrp Monthly Limit","description":"VRP: месячный лимит"},"valid_from":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid From","description":"Действует с"},"valid_until":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid Until","description":"Действует до"},"reason":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reason","description":"Причина запроса"}},"type":"object","required":["requesting_bank","client_id","debtor_account"],"title":"PaymentConsentRequestData","description":"Запрос на создание согласия"},"PaymentConsentType":{"type":"string","enum":["single_use","multi_use","vrp"],"title":"PaymentConsentType","description":"Типы согласий на платежи"},"PaymentData":{"properties":{"paymentId":{"type":"string","title":"Paymentid"},"status":{"type":"string","title":"Status"},"creationDateTime":{"type":"string","title":"Creationdatetime"},"statusUpdateDateTime":{"type":"string","title":"Statusupdatedatetime"},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description"},"amount":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Amount"},"currency":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Currency"}},"type":"object","required":["paymentId","status","creationDateTime","statusUpdateDateTime"],"title":"PaymentData","description":"Данные платежа в ответе"},"PaymentRequest":{"properties":{"data":{"type":"object","title":"Data","description":"Содержит initiation"},"risk":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Risk","default":{}}},"type":"object","required":["data"],"title":"PaymentRequest","description":"Запрос создания платежа"},"PaymentResponse":{"properties":{"data":{"$ref":"#/components/schemas/PaymentData"},"links":{"type":"object","title":"Links"},"meta":{"anyOf":[{"type":"object"},{"type":"null"}],"title":"Meta","default":{}}},"type":"object","required":["data","links"],"title":"PaymentResponse","description":"Ответ с платежом"},"ProductAgreementConsentRequestData":{"properties":{"requesting_bank":{"type":"string","title":"Requesting Bank","description":"Код банка-инициатора"},"client_id":{"type":"string","title":"Client Id","description":"ID клиента"},"read_product_agreements":{"type":"boolean","title":"Read Product Agreements","description":"Читать список договоров","default":false},"open_product_agreements":{"type":"boolean","title":"Open Product Agreements","description":"Открывать новые договоры","default":false},"close_product_agreements":{"type":"boolean","title":"Close Product Agreements","description":"Закрывать договоры","default":false},"allowed_product_types":{"anyOf":[{"items":{"type":"string"},"type":"array"},{"type":"null"}],"title":"Allowed Product Types","description":"Разрешенные типы продуктов: deposit, card, credit"},"max_amount":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}],"title":"Max Amount","description":"Макс сумма открытия продукта"},"valid_until":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Valid Until","description":"Действует до"},"reason":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Reason","description":"Причина запроса"}},"type":"object","required":["requesting_bank","client_id"],"title":"ProductAgreementConsentRequestData","description":"Запрос на создание согласия для управления договорами"},"ProductAgreementRequest":{"properties":{"product_id":{"type":"string","title":"Product Id","description":"ID продукта из каталога","example":"prod-vbank-deposit-001"},"amount":{"type":"number","title":"Amount","description":"Сумма продукта (депозита, кредита, лимита карты)","example":50000.0},"term_months":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Term Months","description":"Срок в месяцах (для депозитов и кредитов)","example":12},"source_account_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Source Account Id","description":"Номер счета для списания средств (обязательно для депозитов и карт, не нужно для кредитов)","example":"40817810200010318134"}},"type":"object","required":["product_id","amount"],"title":"ProductAgreementRequest","description":"Запрос на открытие продукта"},"UpdateCardStatusRequest":{"properties":{"status":{"type":"string","title":"Status","description":"Новый статус: active, blocked, expired"}},"type":"object","required":["status"],"title":"UpdateCardStatusRequest","description":"Запрос на изменение статуса карты"},"ValidationError":{"properties":{"loc":{"items":{"anyOf":[{"type":"string"},{"type":"integer"}]},"type":"array","title":"Location"},"msg":{"type":"string","title":"Message"},"type":{"type":"string","title":"Error Type"}},"type":"object","required":["loc","msg","type"],"title":"ValidationError"}},"securitySchemes":{"HTTPBearer":{"type":"http","scheme":"bearer"}}},"tags":[{"name":"0 Аутентификация вызывающей системы","description":"Получите токен для работы с API"},{"name":"1 Согласия на доступ к счетам","description":"Создание и управление согласиями для доступа к данным клиентов"},{"name":"2 Счета и балансы","description":"Просмотр счетов, балансов и истории транзакций"},{"name":"3 Согласия на переводы","description":"Согласия для совершения платежей от имени клиента"},{"name":"4 Переводы","description":"Создание платежей и проверка их статуса"},{"name":"5 Каталог продуктов","description":"Депозиты, кредиты, карты — каталог банковских продуктов"},{"name":"6 Согласия на управление договорами","description":"Согласия на открытие/закрытие продуктов от имени клиента"},{"name":"7 Договоры с продуктами","description":"Открытие и закрытие депозитов, кредитов и карт"},{"name":"8 Карты","description":"Управление банковскими картами (привязка к счетам, блокировка, лимиты)"},{"name":"Technical: Well-Known","description":"JWKS — публичные ключи для проверки JWT"}]}
</file>

<file path="frontend/package.json">
{
  "name": "frontend-2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.6",
    "axios": "^1.13.2",
    "classnames": "^2.5.1",
    "formik": "^2.4.6",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.552.0",
    "next-themes": "^0.4.6",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.5",
    "recharts": "^3.3.0",
    "sass": "^1.93.3",
    "sonner": "^2.0.7",
    "zod": "^4.1.12",
    "zod-formik-adapter": "^2.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/classnames": "^2.3.0",
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}
</file>

<file path="frontend/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "paths": {
      "@/*": ["./src/*"]
    },
  "include": ["src"]
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0', // Needed for Docker
    port: 5173,
    watch: {
      usePolling: true, // Needed for Docker on some systems
    },
    proxy: {
      '/api': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      },
      '/auth': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
      },
      '/users': {
        target: process.env.VITE_API_URL || 'http://app:8000',
        changeOrigin: true,
      }
    }
  }
})
</file>

<file path="tests/__init__.py">
# Tests package
</file>

<file path="tests/conftest.py">
"""
Pytest configuration and fixtures for backend tests
"""
import pytest
import asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.pool import StaticPool

from main import app
from app.database import get_db
from app.models import Base, User
from app.security.password import hash_password


# Test database URL (in-memory SQLite for testing)
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

# Create test engine
test_engine = create_async_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
    echo=False,
)

TestSessionLocal = async_sessionmaker(
    test_engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
)


@pytest.fixture(scope="function")
async def db_session():
    """Create a test database session"""
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with TestSessionLocal() as session:
        yield session
        await session.rollback()
    
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest.fixture(scope="function")
async def client(db_session):
    """Create a test client with database override"""
    async def override_get_db():
        yield db_session
    
    app.dependency_overrides[get_db] = override_get_db
    
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
    
    app.dependency_overrides.clear()


@pytest.fixture
async def test_user(db_session):
    """Create a test user"""
    user = User(
        email="test@example.com",
        phone_number="+79991234567",
        first_name="Test",
        last_name="User",
        hashed_password=hash_password("TestPass123"),
        is_active=True,
        is_phone_verified=True,
        is_email_verified=False
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    return user


@pytest.fixture
def event_loop():
    """Create an instance of the default event loop for the test session"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()
</file>

<file path="tests/README.md">
# Backend Tests

This directory contains tests for the backend API.

## Setup

Install test dependencies:

```bash
pip install -r requirements.txt
```

## Running Tests

Run all tests:

```bash
pytest
```

Run with verbose output:

```bash
pytest -v
```

Run specific test file:

```bash
pytest tests/test_auth.py
```

Run specific test:

```bash
pytest tests/test_auth.py::TestRegistration::test_register_success
```

Run with coverage:

```bash
pytest --cov=app --cov-report=html
```

## Test Structure

- `conftest.py` - Pytest fixtures and configuration
- `test_auth.py` - Authentication endpoint tests (registration, login, token refresh)

## Test Database

Tests use an in-memory SQLite database, so no external database setup is required. Each test gets a fresh database session.

## Writing New Tests

1. Create a new test file: `test_<module>.py`
2. Import necessary fixtures from `conftest.py`
3. Use `@pytest.mark.asyncio` for async tests
4. Use the `client` fixture for API requests
5. Use the `db_session` fixture for database operations

Example:

```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_example(client: AsyncClient):
    response = await client.get("/health")
    assert response.status_code == 200
```
</file>

<file path="tests/test_auth.py">
"""
Tests for authentication endpoints
"""
import pytest
from httpx import AsyncClient


class TestRegistration:
    """Test user registration"""
    
    @pytest.mark.asyncio
    async def test_register_success(self, client: AsyncClient):
        """Test successful user registration"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "newuser@example.com",
                "phone_number": "+79991234568",
                "first_name": "New",
                "last_name": "User",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert data["email"] == "newuser@example.com"
        assert data["phone_number"] == "+79991234568"
        assert data["first_name"] == "New"
        assert data["last_name"] == "User"
        assert data["is_active"] is True
        assert "id" in data
    
    @pytest.mark.asyncio
    async def test_register_duplicate_email(self, client: AsyncClient, test_user):
        """Test registration with duplicate email"""
        response = await client.post(
            "/auth/register",
            json={
                "email": test_user.email,
                "phone_number": "+79991234569",
                "first_name": "Another",
                "last_name": "User",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 409
        assert "уже зарегистрирован" in response.json()["detail"].lower()
    
    @pytest.mark.asyncio
    async def test_register_duplicate_phone(self, client: AsyncClient, test_user):
        """Test registration with duplicate phone number"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "different@example.com",
                "phone_number": test_user.phone_number,
                "first_name": "Another",
                "last_name": "User",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 409
        assert "уже зарегистрирован" in response.json()["detail"].lower()
    
    @pytest.mark.asyncio
    async def test_register_invalid_email(self, client: AsyncClient):
        """Test registration with invalid email"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "invalid-email",
                "phone_number": "+79991234570",
                "first_name": "Test",
                "last_name": "User",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 422
    
    @pytest.mark.asyncio
    async def test_register_invalid_phone(self, client: AsyncClient):
        """Test registration with invalid phone number"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "test@example.com",
                "phone_number": "1234567890",  # Missing +7 prefix
                "first_name": "Test",
                "last_name": "User",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 422
    
    @pytest.mark.asyncio
    async def test_register_weak_password(self, client: AsyncClient):
        """Test registration with weak password"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "test@example.com",
                "phone_number": "+79991234571",
                "first_name": "Test",
                "last_name": "User",
                "password": "weak"  # Too short, no uppercase, no digit
            }
        )
        assert response.status_code == 422
    
    @pytest.mark.asyncio
    async def test_register_missing_fields(self, client: AsyncClient):
        """Test registration with missing required fields"""
        response = await client.post(
            "/auth/register",
            json={
                "email": "test@example.com",
                # Missing other required fields
            }
        )
        assert response.status_code == 422


class TestLogin:
    """Test user login"""
    
    @pytest.mark.asyncio
    async def test_login_success(self, client: AsyncClient, test_user):
        """Test successful login"""
        response = await client.post(
            "/auth/login",
            json={
                "email": test_user.email,
                "password": "TestPass123"
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert "refresh_token" in data
        assert data["token_type"] == "bearer"
        assert "expires_in" in data
    
    @pytest.mark.asyncio
    async def test_login_invalid_email(self, client: AsyncClient):
        """Test login with non-existent email"""
        response = await client.post(
            "/auth/login",
            json={
                "email": "nonexistent@example.com",
                "password": "TestPass123"
            }
        )
        assert response.status_code == 401
        assert "неверный" in response.json()["detail"].lower()
    
    @pytest.mark.asyncio
    async def test_login_invalid_password(self, client: AsyncClient, test_user):
        """Test login with wrong password"""
        response = await client.post(
            "/auth/login",
            json={
                "email": test_user.email,
                "password": "WrongPassword123"
            }
        )
        assert response.status_code == 401
        assert "неверный" in response.json()["detail"].lower()
    
    @pytest.mark.asyncio
    async def test_login_inactive_user(self, client: AsyncClient, db_session, test_user):
        """Test login with inactive user"""
        test_user.is_active = False
        await db_session.commit()
        
        response = await client.post(
            "/auth/login",
            json={
                "email": test_user.email,
                "password": "TestPass123"
            }
        )
        assert response.status_code == 403
        assert "неактивен" in response.json()["detail"].lower()


class TestRefreshToken:
    """Test token refresh"""
    
    @pytest.mark.asyncio
    async def test_refresh_token_success(self, client: AsyncClient, test_user):
        """Test successful token refresh"""
        # First login to get tokens
        login_response = await client.post(
            "/auth/login",
            json={
                "email": test_user.email,
                "password": "TestPass123"
            }
        )
        refresh_token = login_response.json()["refresh_token"]
        
        # Refresh the token
        response = await client.post(
            "/auth/refresh",
            json={
                "refresh_token": refresh_token
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert "refresh_token" in data
    
    @pytest.mark.asyncio
    async def test_refresh_token_invalid(self, client: AsyncClient):
        """Test refresh with invalid token"""
        response = await client.post(
            "/auth/refresh",
            json={
                "refresh_token": "invalid_token"
            }
        )
        assert response.status_code == 401


class TestGetCurrentUser:
    """Test getting current user info"""
    
    @pytest.mark.asyncio
    async def test_get_current_user_success(self, client: AsyncClient, test_user):
        """Test getting current user info with valid token"""
        # Login first
        login_response = await client.post(
            "/auth/login",
            json={
                "email": test_user.email,
                "password": "TestPass123"
            }
        )
        access_token = login_response.json()["access_token"]
        
        # Get user info
        response = await client.get(
            "/users/me",
            headers={"Authorization": f"Bearer {access_token}"}
        )
        assert response.status_code == 200
        data = response.json()
        assert data["email"] == test_user.email
        assert data["id"] == test_user.id
    
    @pytest.mark.asyncio
    async def test_get_current_user_no_token(self, client: AsyncClient):
        """Test getting user info without token"""
        response = await client.get("/users/me")
        assert response.status_code == 403
    
    @pytest.mark.asyncio
    async def test_get_current_user_invalid_token(self, client: AsyncClient):
        """Test getting user info with invalid token"""
        response = await client.get(
            "/users/me",
            headers={"Authorization": "Bearer invalid_token"}
        )
        assert response.status_code == 401
</file>

<file path="tests/test_health.py">
"""
Tests for health check and basic endpoints
"""
import pytest
from httpx import AsyncClient


@pytest.mark.asyncio
async def test_health_check(client: AsyncClient):
    """Test health check endpoint"""
    response = await client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ok"
</file>

<file path=".env.bak2">
DATABASE_URL=postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5434/fastapi_db
REDIS_URL=redis://localhost:6379/0

SECRET_KEY="aMeucfHi2Xxl3v0LYb1Tcduk-NuQOOjGVrTxqhDrT0A"
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# Virtual Bank
VBANK_API_URL=https://vbank.open.bankingapi.ru
VBANK_CLIENT_ID=team261
VBANK_CLIENT_SECRET=gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt

# Awesome Bank
ABANK_API_URL=https://abank.open.bankingapi.ru
ABANK_CLIENT_ID=team261
ABANK_CLIENT_SECRET=gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt

# Smart Bank
SBANK_API_URL=https://sbank.open.bankingapi.ru
SBANK_CLIENT_ID=team261
SBANK_CLIENT_SECRET=gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt

# SMS сервис
SMS_SERVICE_PROVIDER=sms_ru  # или другой провайдер
SMS_API_KEY=18608A37-567C-3C70-F128-03938B6AF52A
SMS_FROM_NAME="YourApp"

# OAuth
</file>

<file path="create_bank_users_table.sql">
-- SQL скрипт для создания таблицы bank_users
-- Выполните этот скрипт в вашей базе данных, если таблица еще не создана

CREATE TABLE IF NOT EXISTS bank_users (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    bank_code VARCHAR(50) NOT NULL,
    bank_user_id VARCHAR(255) NOT NULL,
    consent_id VARCHAR(255),
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_bank_users_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT unique_user_bank UNIQUE (user_id, bank_code)
);

-- Создаем индекс для быстрого поиска по user_id
CREATE INDEX IF NOT EXISTS ix_bank_users_user_id ON bank_users(user_id);

-- Комментарии к таблице
COMMENT ON TABLE bank_users IS 'Хранит ID пользователей в банках и их consent_id';
COMMENT ON COLUMN bank_users.user_id IS 'ID пользователя в нашем приложении';
COMMENT ON COLUMN bank_users.bank_code IS 'Код банка (vbank, abank, sbank)';
COMMENT ON COLUMN bank_users.bank_user_id IS 'ID пользователя в банке (вводит пользователь)';
COMMENT ON COLUMN bank_users.consent_id IS 'ID согласия (получается автоматически при запросе счетов)';
</file>

<file path="DATABASE_FIX.md">
# Database Connection Fix

## Issue

PostgreSQL was throwing the error: `FATAL: database "fastapi_user" does not exist`

## Root Cause

PostgreSQL defaults to connecting to a database with the same name as the username when no database is specified in the connection string. This can happen with:
- Manual `psql` commands without `-d` flag
- Healthcheck commands
- Some connection attempts

## Solution

1. **Created `fastapi_user` database** - For default connections that don't specify a database name
2. **Updated healthcheck** - Now explicitly specifies the database: `pg_isready -U fastapi_user -d fastapi_db`
3. **Main database remains `fastapi_db`** - This is what the application uses

## Current Database Setup

- `fastapi_db` - Main application database (used by the app)
- `fastapi_user` - Default database for connections without explicit database name
- Both databases are owned by `fastapi_user` user

## Verification

Check databases:
```bash
docker compose exec postgres psql -U fastapi_user -d fastapi_db -c "\l"
```

Test connection:
```bash
docker compose exec postgres psql -U fastapi_user -d fastapi_db -c "SELECT version();"
```

## If Issue Persists

Run the fix script:
```bash
./fix_database.sh
```

Or manually create the database:
```bash
docker compose exec postgres psql -U fastapi_user -d postgres -c "CREATE DATABASE fastapi_user OWNER fastapi_user;"
```
</file>

<file path="DOCKER_FIX_GUIDE.md">
# Docker Desktop I/O Error Fix Guide

## Problem

You're seeing this error:
```
Error response from daemon: error creating temporary lease: 
write /var/lib/desktop-containerd/daemon/io.containerd.metadata.v1.bolt/meta.db: 
input/output error
```

This is a Docker Desktop internal database corruption issue.

## Quick Fix (Recommended)

### Option 1: Restart Docker Desktop

1. **Quit Docker Desktop completely:**
   - Click the Docker icon in your menu bar (top right)
   - Select "Quit Docker Desktop"
   - Wait for it to fully quit

2. **Restart Docker Desktop:**
   - Open Docker Desktop application
   - Wait for it to fully start (whale icon stops animating)
   - This usually takes 30-60 seconds

3. **Verify it's working:**
   ```bash
   docker info
   ```

4. **Try starting the project again:**
   ```bash
   ./docker.sh start
   ```

### Option 2: Use the Fix Script

```bash
# Run the fix script
./fix_docker.sh

# After restarting Docker Desktop, verify:
./fix_docker.sh --verify
```

## Nuclear Option (If restart doesn't work)

**⚠️ WARNING: This will delete ALL Docker containers, images, and volumes!**

1. **Quit Docker Desktop completely**

2. **Remove Docker Desktop data:**
   ```bash
   rm -rf ~/Library/Containers/com.docker.docker/Data
   ```

3. **Restart Docker Desktop**

4. **Verify:**
   ```bash
   docker info
   ```

## Alternative: Run Without Docker

If Docker continues to have issues, you can run the project locally without Docker:

### Prerequisites
- PostgreSQL running locally (or use Docker just for DB)
- Redis running locally (or use Docker just for Redis)

### Steps

1. **Start only database services:**
   ```bash
   docker compose up -d postgres redis
   ```

2. **Set up Python environment:**
   ```bash
   source venv/bin/activate
   pip install -r requirements.txt
   ```

3. **Start the backend:**
   ```bash
   uvicorn main:app --host 0.0.0.0 --port 8000 --reload
   ```

4. **Start the frontend (in another terminal):**
   ```bash
   cd frontend
   npm install
   npm run dev
   ```

## Prevention

To avoid this issue in the future:

1. **Keep Docker Desktop updated**
2. **Don't force-quit Docker Desktop** - always quit gracefully
3. **Regular cleanup:**
   ```bash
   docker system prune -a --volumes
   ```
   (Only when you don't need existing containers/images)

## Still Having Issues?

1. **Check Docker Desktop logs:**
   - Docker Desktop → Troubleshoot → View logs

2. **Check system resources:**
   - Ensure you have enough disk space
   - Check Activity Monitor for Docker processes

3. **Reinstall Docker Desktop:**
   - Download latest from docker.com
   - Uninstall current version
   - Install fresh copy

## Verification

After fixing, verify everything works:

```bash
# Check Docker
docker info

# Check Docker Compose
docker compose config

# Start project
./docker.sh start

# Check status
./docker.sh status
```
</file>

<file path="DOCKER_STRUCTURE.md">
# Docker Structure

This document describes the restructured Docker setup for the VTB API Hack project.

## Structure

```
.
├── docker.sh                    # Main wrapper script (use this!)
├── docker/
│   ├── docker.sh               # Unified Docker management script
│   └── README.md               # Detailed Docker documentation
├── docker-compose.yml           # Development configuration
├── docker-compose.prod.yml      # Production configuration
├── Dockerfile                   # Backend Dockerfile
└── frontend/
    ├── Dockerfile               # Frontend production Dockerfile
    └── Dockerfile.dev           # Frontend development Dockerfile
```

## Quick Start

### Development

```bash
# Start development environment
./docker.sh start

# View logs
./docker.sh logs

# Stop services
./docker.sh stop
```

### Production

```bash
# Start production environment
./docker.sh start prod

# View logs
./docker.sh logs

# Stop services
./docker.sh stop
```

## Unified Commands

All Docker operations are now handled through a single script:

| Command | Description |
|---------|-------------|
| `./docker.sh start [dev\|prod]` | Start services (default: dev) |
| `./docker.sh stop` | Stop all running services |
| `./docker.sh restart [service]` | Restart all or specific service |
| `./docker.sh logs [service]` | View logs (all or specific service) |
| `./docker.sh rebuild [service]` | Rebuild services |
| `./docker.sh status` | Show service status |
| `./docker.sh clean` | Remove volumes (database data) |
| `./docker.sh help` | Show help message |

## Migration from Old Scripts

The following old scripts have been removed and replaced by `./docker.sh`:

- ❌ `docker-start-dev.sh` → ✅ `./docker.sh start`
- ❌ `docker-start-prod.sh` → ✅ `./docker.sh start prod`
- ❌ `docker-stop.sh` → ✅ `./docker.sh stop`
- ❌ `docker-logs.sh` → ✅ `./docker.sh logs`
- ❌ `docker-rebuild.sh` → ✅ `./docker.sh rebuild`

## Benefits

1. **Single entry point**: One script handles all Docker operations
2. **Better organization**: All Docker scripts in `docker/` directory
3. **Consistent interface**: Same commands for dev and prod
4. **Auto-detection**: Automatically detects which environment is running
5. **Better error handling**: Improved checks and user feedback
6. **Cleaner structure**: Removed redundant scripts

## Examples

```bash
# Start development
./docker.sh start

# Start production
./docker.sh start prod

# View all logs
./docker.sh logs

# View specific service logs
./docker.sh logs app
./docker.sh logs frontend

# Rebuild a service
./docker.sh rebuild frontend

# Restart a service
./docker.sh restart app

# Check status
./docker.sh status

# Clean everything (removes database)
./docker.sh clean
```

For more details, see [docker/README.md](docker/README.md).
</file>

<file path="docker-compose.prod.yml">
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-fastapi_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-fastapi_password}
      POSTGRES_DB: ${POSTGRES_DB:-fastapi_db}
    ports:
      - "5434:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-fastapi_user}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6381:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network
    restart: unless-stopped

  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-fastapi_user}:${POSTGRES_PASSWORD:-fastapi_password}@postgres:5432/${POSTGRES_DB:-fastapi_db}
      REDIS_URL: redis://redis:6379/0
    env_file:
      - .env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - app-network
    restart: unless-stopped

  # celery:
  #   build:
  #     context: .
  #     dockerfile: Dockerfile
  #   command: celery -A app.tasks.sync_tasks worker --loglevel=info
  #   environment:
  #     DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-fastapi_user}:${POSTGRES_PASSWORD:-fastapi_password}@postgres:5432/${POSTGRES_DB:-fastapi_db}
  #     REDIS_URL: redis://redis:6379/0
  #   env_file:
  #     - .env
  #   depends_on:
  #     postgres:
  #       condition: service_healthy
  #     redis:
  #       condition: service_healthy
  #   networks:
  #     - app-network
  #   restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      VITE_API_URL: ${VITE_API_URL:-http://localhost:8000}
    depends_on:
      - app
    networks:
      - app-network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge
</file>

<file path="docker.sh">
#!/bin/bash

# Wrapper script for unified Docker management
# This script calls the main docker.sh script in the docker/ directory

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
"$SCRIPT_DIR/docker/docker.sh" "$@"
</file>

<file path="fix_database.sh">
#!/bin/bash

# Script to fix database connection issues

echo "🔧 Fixing database connection issues..."

# Create the database with username name (for default connections)
echo "Creating fastapi_user database (for default connections)..."
docker compose exec -T postgres psql -U fastapi_user -d postgres <<EOF
CREATE DATABASE fastapi_user OWNER fastapi_user;
EOF

# Verify both databases exist
echo ""
echo "📊 Verifying databases..."
docker compose exec postgres psql -U fastapi_user -d fastapi_db -c "\l" | grep -E "fastapi|Name"

echo ""
echo "✅ Database fix completed!"
echo ""
echo "Both databases now exist:"
echo "  - fastapi_db (main application database)"
echo "  - fastapi_user (for default connections)"
</file>

<file path="PORTS.md">
# 🔌 Порты сервисов

Из-за конфликтов портов на вашей системе, порты были изменены:

## Текущие порты

- **PostgreSQL**: `5434` (внутри контейнера: `5432`)
- **Redis**: `6381` (внутри контейнера: `6379`)
- **FastAPI**: `8000` (не изменен)

## Обновление конфигурации

Файлы `.env` и `docker-compose.yml` уже обновлены с новыми портами.

### DATABASE_URL
```
postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5434/fastapi_db
```

### REDIS_URL
```
redis://localhost:6381/0
```

## Подключение к БД извне

Если нужно подключиться к PostgreSQL из другого приложения или клиента:

```bash
# psql
psql -h localhost -p 5434 -U fastapi_user -d fastapi_db

# или через docker
docker compose exec postgres psql -U fastapi_user -d fastapi_db
```

## Подключение к Redis извне

```bash
# redis-cli
redis-cli -h localhost -p 6381

# или через docker
docker compose exec redis redis-cli
```

## Возврат к стандартным портам

Если хотите использовать стандартные порты (5432 и 6379), нужно:

1. Остановить существующие сервисы, использующие эти порты
2. Вернуть порты в `docker-compose.yml` на стандартные
3. Обновить `DATABASE_URL` и `REDIS_URL` в `.env`
</file>

<file path="pytest.ini">
[pytest]
asyncio_mode = auto
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
markers =
    asyncio: marks tests as async (using pytest-asyncio)
</file>

<file path="run_tests.sh">
#!/bin/bash

# Script to run backend tests

echo "🧪 Running backend tests..."

# Check if we're in a virtual environment
if [ -z "$VIRTUAL_ENV" ]; then
    echo "⚠️  Warning: Not in a virtual environment"
    echo "   Consider activating your venv first: source venv/bin/activate"
fi

# Install test dependencies if needed
echo "📦 Checking dependencies..."
pip install -q pytest pytest-asyncio pytest-cov aiosqlite httpx

# Run tests
echo "🚀 Running tests..."
pytest tests/ -v --tb=short

# Optionally run with coverage
if [ "$1" == "--coverage" ] || [ "$1" == "-c" ]; then
    echo "📊 Running with coverage..."
    pytest tests/ --cov=app --cov-report=html --cov-report=term
    echo "📄 Coverage report generated in htmlcov/index.html"
fi

echo "✅ Tests completed!"
</file>

<file path="stop.sh">
#!/bin/bash

# Stop all Docker services
# This script stops all containers created by docker.sh

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}🛑 Stopping all Docker services...${NC}"
echo ""

# Check if Docker is running
if ! docker info > /dev/null 2>&1; then
    echo -e "${RED}❌ Error: Docker is not running.${NC}"
    exit 1
fi

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Check which compose file has running services
DEV_RUNNING=false
PROD_RUNNING=false

if docker compose ps 2>/dev/null | grep -q "Up"; then
    DEV_RUNNING=true
fi

if docker compose -f docker-compose.prod.yml ps 2>/dev/null | grep -q "Up"; then
    PROD_RUNNING=true
fi

# Stop development environment if running
if [ "$DEV_RUNNING" = true ]; then
    echo -e "${BLUE}Stopping development environment...${NC}"
    docker compose down
    echo -e "${GREEN}✅ Development environment stopped${NC}"
    echo ""
fi

# Stop production environment if running
if [ "$PROD_RUNNING" = true ]; then
    echo -e "${BLUE}Stopping production environment...${NC}"
    docker compose -f docker-compose.prod.yml down
    echo -e "${GREEN}✅ Production environment stopped${NC}"
    echo ""
fi

# If nothing was running
if [ "$DEV_RUNNING" = false ] && [ "$PROD_RUNNING" = false ]; then
    echo -e "${YELLOW}No running services found.${NC}"
    exit 0
fi

echo -e "${GREEN}✅ All Docker services stopped!${NC}"
echo ""
echo -e "${BLUE}💡 Useful commands:${NC}"
echo "   Start services:     ./docker.sh start"
echo "   Remove volumes:     ./docker.sh clean"
echo "   View status:        ./docker.sh status"
echo ""
</file>

<file path="TESTING.md">
# Backend Testing Guide

## Overview

This document describes how to run and write tests for the backend API.

## Quick Start

### Run All Tests

```bash
# Using the test script
./run_tests.sh

# Or directly with pytest
pytest tests/ -v
```

### Run Tests with Coverage

```bash
./run_tests.sh --coverage
# or
pytest tests/ --cov=app --cov-report=html
```

## Test Structure

```
tests/
├── __init__.py
├── conftest.py          # Pytest fixtures and configuration
├── test_auth.py         # Authentication tests
├── test_health.py        # Health check tests
└── README.md            # Detailed test documentation
```

## Running Tests

### Basic Commands

```bash
# Run all tests
pytest

# Run with verbose output
pytest -v

# Run specific test file
pytest tests/test_auth.py

# Run specific test
pytest tests/test_auth.py::TestRegistration::test_register_success

# Run with coverage report
pytest --cov=app --cov-report=html --cov-report=term
```

### Running Tests in Docker

```bash
# Run tests inside the app container
docker compose exec app pytest tests/ -v

# Or install dependencies and run locally
docker compose exec app pip install pytest pytest-asyncio pytest-cov aiosqlite httpx
docker compose exec app pytest tests/ -v
```

## Test Coverage

Current test coverage includes:

- ✅ User Registration
  - Successful registration
  - Duplicate email/phone validation
  - Invalid input validation
  - Password strength validation

- ✅ User Login
  - Successful login
  - Invalid credentials
  - Inactive user handling

- ✅ Token Management
  - Token refresh
  - Invalid token handling

- ✅ User Info
  - Get current user
  - Authentication required
  - Invalid token handling

## Writing New Tests

### Example Test

```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_my_endpoint(client: AsyncClient):
    """Test description"""
    response = await client.get("/my-endpoint")
    assert response.status_code == 200
    data = response.json()
    assert "expected_field" in data
```

### Available Fixtures

- `client`: AsyncClient instance for making API requests
- `db_session`: Database session (fresh for each test)
- `test_user`: Pre-created test user

### Test Database

Tests use an in-memory SQLite database, so:
- No external database setup required
- Each test gets a fresh database
- Tests run in isolation
- Fast execution

## Troubleshooting

### Database Connection Errors

If you see database connection errors:
1. Ensure PostgreSQL is running: `docker compose ps postgres`
2. Check DATABASE_URL in `.env` file
3. Verify database exists: `docker compose exec postgres psql -U fastapi_user -d fastapi_db -c "\l"`

### Import Errors

If you see import errors:
1. Ensure you're in the project root directory
2. Install dependencies: `pip install -r requirements.txt`
3. Check Python path: `export PYTHONPATH=$PWD`

### Validation Errors (422)

If registration/login returns 422:
- Check request format matches schema
- Phone must be: `+7XXXXXXXXXX` (11 digits after +7)
- Password must have: uppercase, lowercase, digit, min 8 chars
- Email must be valid format
- All required fields must be present

## Test Data

Test users are created automatically in fixtures. Default test user:
- Email: `test@example.com`
- Phone: `+79991234567`
- Password: `TestPass123`
- Active: `True`

## Continuous Integration

To add tests to CI/CD:

```yaml
# Example GitHub Actions
- name: Run tests
  run: |
    pip install -r requirements.txt
    pytest tests/ --cov=app --cov-report=xml
```

## Best Practices

1. **Isolation**: Each test should be independent
2. **Naming**: Use descriptive test names
3. **Assertions**: Be specific about what you're testing
4. **Fixtures**: Reuse fixtures for common setup
5. **Cleanup**: Database is automatically cleaned between tests

## Common Issues

### 422 Unprocessable Entity

This means validation failed. Check:
- Request body format
- Required fields
- Field types and formats
- Validation rules (phone format, password strength, etc.)

### 401 Unauthorized

Token is missing or invalid. Ensure:
- Token is included in Authorization header
- Token format: `Bearer <token>`
- Token hasn't expired

### 500 Internal Server Error

Server error. Check:
- Database connection
- Server logs: `docker compose logs app`
- Error details in response
</file>

<file path="app/security/oauth2.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.security.jwt_handler import decode_token

security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> int:
    token = credentials.credentials
    user_id = decode_token(token)
    
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )
    
    return user_id
</file>

<file path="app/services/bank_oauth_service.py">
import aiohttp
import secrets
from datetime import datetime, timedelta
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional, Dict
from app.config import get_settings
from app.models import OAuthSession, User
import logging


settings = get_settings()
logger = logging.getLogger(__name__)


class OAuth2BankService:
    """
    Универсальный сервис для работы с банковским API для трёх банков.
    Поддерживает: vbank, abank, sbank
    
    Usage:
        service = OAuth2BankService(bank_code="vbank")
        result = await service.get_bank_accounts_full_cycle(user_id="123")
    """
    
    def __init__(self, bank_code: str):
        """
        Инициализация сервиса для конкретного банка
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Raises:
            ValueError: Если bank_code неизвестен
        """
        # Получаем конфигурацию для выбранного банка
        self.bank_code = bank_code
        bank_config = settings.get_bank_config(bank_code)
        
        # Устанавливаем параметры из конфигурации
        self.bank_api_url = bank_config.api_url
        self.client_id = bank_config.client_id
        self.client_secret = bank_config.client_secret
        self.requesting_bank = bank_config.requesting_bank
        self.requesting_bank_name = bank_config.requesting_bank_name
        self.redirecting_url = bank_config.redirecting_url
        
        
        logger.info(f"[{self.bank_code}] Initialized OAuth2BankService with URL: {self.bank_api_url}")
    
    # ============ ШАГ 1: Получение токена банка ============
    async def get_bank_access_token(self) -> Optional[str]:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://{bank}.open.bankingapi.ru/auth/bank-token
        ?client_id=team261&client_secret=YOUR_SECRET
        
        Returns:
            str: access_token для использования в дальнейших запросах
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/auth/bank-token"
                params = {
                    "client_id": self.requesting_bank,
                    "client_secret": self.client_secret
                }
                
                logger.info(f"[{self.bank_code}] Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info(f"[{self.bank_code}] Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error getting bank token: {e}")
            return None
    
    # ============ ШАГ 2: Запрос согласия (авто-одобрение) ============
    async def request_account_consent(self, access_token: str, user_id: str) -> Optional[Dict]:
        """
        Запросить согласие на доступ к счетам пользователя
        
        POST https://{bank}.open.bankingapi.ru/account-consents/request
        
        Args:
            access_token: Токен банка (из шага 1)
            user_id: ID пользователя
        
        Returns:
            dict: {"status": "approved", "consent_id": "...", "auto_approved": true}
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": ["ReadAccountsDetail", "ReadBalances"],
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": self.requesting_bank,
                    "requesting_bank_name": self.requesting_bank_name
                }
                
                logger.info(f"[{self.bank_code}] Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        consent_id = data.get("consent_id")
                        logger.info(f"[{self.bank_code}] Consent received: {consent_id}")
                        return {
                            "status": data.get("status", "approved"),
                            "consent_id": consent_id,
                            "auto_approved": data.get("auto_approved", True)
                        }
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to request consent for user {user_id}: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error requesting consent: {e}")
            return None
    
    # ============ ШАГ 3: Получить данные счетов ============
    async def get_user_accounts(self, access_token: str, user_id: str, consent_id: str) -> Optional[Dict]:
        """
        Получить список счетов пользователя
        
        GET https://{bank}.open.bankingapi.ru/accounts?client_id={user_id}
        
        Args:
            access_token: Токен банка
            user_id: ID пользователя
            consent_id: ID согласия (из шага 2)
        
        Returns:
            dict: {"accounts": [...]} или {"data": {"account": [...]}}
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"[{self.bank_code}] Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        
                        # Поддержка разных форматов ответа
                        if 'data' in data and 'account' in data['data']:
                            accounts = data['data']['account']
                        elif 'accounts' in data:
                            accounts = data['accounts']
                        else:
                            accounts = []
                        
                        logger.info(f"[{self.bank_code}] Successfully fetched {len(accounts)} accounts")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error fetching accounts: {e}")
            return None
    
    # ============ КОМПЛЕКСНЫЙ МЕТОД: Полный цикл ============
    async def get_bank_accounts_full_cycle(self, user_id: str) -> Dict:
        """
        Выполнить полный цикл получения счетов пользователя:
        1. Получить access token банка
        2. Запросить согласие
        3. Получить данные счетов
        
        Args:
            user_id: ID пользователя
        
        Returns:
            dict: {
                "success": True/False,
                "bank_code": "vbank",
                "bills": [...],  # Список счетов
                "consent_id": "...",
                "auto_approved": True/False,
                "error": "..." (если есть)
            }
        """
        try:
            logger.info(f"[{self.bank_code}] ===== STARTING FULL CYCLE for user {user_id} =====")
            
            # ШАГ 1: Получить токен банка
            logger.info(f"[{self.bank_code}] STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token()
            
            if not access_token:
                logger.error(f"[{self.bank_code}] STEP 1 FAILED: No access token")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to obtain bank access token"
                }
            
            logger.info(f"[{self.bank_code}] STEP 1 SUCCESS: Access token obtained")
            
            # ШАГ 2: Запросить согласие
            logger.info(f"[{self.bank_code}] STEP 2: Requesting account consent...")
            consent_data = await self.request_account_consent(access_token, user_id)
            
            if not consent_data:
                logger.error(f"[{self.bank_code}] STEP 2 FAILED: No consent")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to request account consent"
                }
            
            consent_id = consent_data.get("consent_id")
            logger.info(f"[{self.bank_code}] STEP 2 SUCCESS: Consent ID = {consent_id}")
            
            # ШАГ 3: Получить счета
            logger.info(f"[{self.bank_code}] STEP 3: Fetching user accounts...")
            accounts_data = await self.get_user_accounts(access_token, user_id, consent_id)
            
            if not accounts_data:
                logger.error(f"[{self.bank_code}] STEP 3 FAILED: No accounts data")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to fetch accounts"
                }
            
            # Извлекаем счета в зависимости от формата ответа
            if 'data' in accounts_data and 'account' in accounts_data['data']:
                bills = accounts_data['data']['account']
            elif 'accounts' in accounts_data:
                bills = accounts_data['accounts']
            else:
                bills = []
            
            logger.info(f"[{self.bank_code}] STEP 3 SUCCESS: Fetched {len(bills)} accounts")
            logger.info(f"[{self.bank_code}] ===== FULL CYCLE COMPLETED SUCCESSFULLY =====")
            
            return {
                "success": True,
                "bank_code": self.bank_code,
                "bills": bills,
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True),
                "raw_data": accounts_data  # Полные данные для отладки
            }
        
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error in full cycle: {e}")
            return {
                "success": False,
                "bank_code": self.bank_code,
                "error": str(e)
            }


# ============ УТИЛИТАРНЫЕ ФУНКЦИИ ============

async def get_accounts_from_all_banks(user_id: str) -> Dict[str, Dict]:
    """
    Получить счета из всех трёх банков
    
    Args:
        user_id: ID пользователя
    
    Returns:
        dict: {
            "vbank": {"success": True, "bills": [...], ...},
            "abank": {"success": True, "bills": [...], ...},
            "sbank": {"success": False, "error": "..."}
        }
    """
    results = {}
    
    for bank_code in ["vbank", "abank", "sbank"]:
        logger.info(f"Processing bank: {bank_code}")
        try:
            service = OAuth2BankService(bank_code=bank_code)
            result = await service.get_bank_accounts_full_cycle(user_id)
            results[bank_code] = result
        except ValueError as e:
            # Банк не настроен в конфигурации
            logger.warning(f"Bank {bank_code} not configured: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": f"Bank not configured: {str(e)}"
            }
        except Exception as e:
            logger.error(f"Error processing bank {bank_code}: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": str(e)
            }
    
    return results


async def get_accounts_from_specific_banks(user_id: str, bank_codes: list) -> Dict[str, Dict]:
    """
    Получить счета из указанных банков
    
    Args:
        user_id: ID пользователя
        bank_codes: Список кодов банков, например ["vbank", "abank"]
    
    Returns:
        dict: {
            "vbank": {"success": True, "bills": [...]},
            "abank": {"success": True, "bills": [...]}
        }
    """
    results = {}
    
    for bank_code in bank_codes:
        logger.info(f"Processing bank: {bank_code}")
        try:
            service = OAuth2BankService(bank_code=bank_code)
            result = await service.get_bank_accounts_full_cycle(user_id)
            results[bank_code] = result
        except Exception as e:
            logger.error(f"Error processing bank {bank_code}: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": str(e)
            }
    
    return results
</file>

<file path="app/services/sms_service.py">
import aiohttp
import random
from datetime import datetime, timedelta
from app.config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import SMSVerification
from sqlalchemy import select

settings = get_settings()

class SMSService:
    async def send_sms(self, phone_number: str, message: str) -> bool:
        """Отправка SMS через API"""
        try:
            if settings.SMS_SERVICE_PROVIDER == "sms_ru":
                return await self._send_sms_ru(phone_number, message)
            return True
        except Exception as e:
            print(f"SMS error: {e}")
            return False
    
    async def _send_sms_ru(self, phone_number: str, message: str) -> bool:
        """SMS через sms.ru"""
        async with aiohttp.ClientSession() as session:
            data = {
                "api_id": settings.SMS_API_KEY,
                "to": phone_number.lstrip("+"),
                "msg": message,
                "json": 1
            }
            async with session.post("https://sms.ru/sms/send", data=data) as resp:
                result = await resp.json()
                return result.get("status") == "OK"
    
    async def generate_sms_code(self) -> str:
        """Генерация 6-значного кода"""
        return "".join([str(random.randint(0, 9)) for _ in range(6)])
    
    async def send_registration_code(self, phone_number: str, db: AsyncSession) -> bool:
        """Отправка кода регистрации"""
        # Проверяем, существует ли уже запись для этого номера
        result = await db.execute(
            select(SMSVerification).where(SMSVerification.phone_number == phone_number)
        )
        existing_verification = result.scalars().first()
        
        code = await self.generate_sms_code()
        current_time = datetime.utcnow()
        
        if existing_verification:
            # Если запись существует, обновляем ее
            existing_verification.code = code
            existing_verification.attempts = 0
            existing_verification.expires_at = current_time + timedelta(minutes=10)
            existing_verification.verified = False
            db.add(existing_verification)
        else:
            # Если записи нет, создаем новую
            sms_verification = SMSVerification(
                phone_number=phone_number,
                code=code,
                expires_at=current_time + timedelta(minutes=10)
            )
            db.add(sms_verification)
        
        await db.commit()
        
        message = f"Ваш код подтверждения: {code}. Действителен 10 минут."
        return await self.send_sms(phone_number, message)
    
    async def verify_sms_code(self, phone_number: str, code: str, db: AsyncSession) -> bool:
        """Проверка SMS кода"""
        result = await db.execute(
            select(SMSVerification).where(
                SMSVerification.phone_number == phone_number
            ).order_by(SMSVerification.created_at.desc())
        )
        verification = result.scalars().first()
        
        if not verification:
            return False
        
        if verification.expires_at < datetime.utcnow():
            return False
        
        if verification.attempts >= 3:
            return False
        
        if verification.code != code:
            verification.attempts += 1
            await db.commit()
            return False
        
        verification.verified = True
        await db.commit()
        return True

sms_service = SMSService()
</file>

<file path="app/models.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, Numeric, ForeignKey, JSON, Index
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    is_active = Column(Boolean, default=False)
    is_email_verified = Column(Boolean, default=False)
    is_phone_verified = Column(Boolean, default=False)
    
    sms_code = Column(String(6), nullable=True)
    sms_code_expires_at = Column(DateTime, nullable=True)
    sms_attempts = Column(Integer, default=0)
    
    oauth_provider = Column(String(50), nullable=True)
    oauth_id = Column(String(255), nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    token = Column(Text, unique=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_revoked = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class SMSVerification(Base):
    __tablename__ = "sms_verifications"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    code = Column(String(6), nullable=False)
    attempts = Column(Integer, default=0)
    expires_at = Column(DateTime, nullable=False)
    verified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class OAuthSession(Base):
    __tablename__ = "oauth_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    state = Column(String(255), unique=True, nullable=False)
    code_verifier = Column(String(255), nullable=False)
    provider = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)


class AccessTokenBlacklist(Base):
    __tablename__ = "access_token_blacklist"
    
    id = Column(Integer, primary_key=True, index=True)
    token = Column(String(1000), unique=True, nullable=False)
    user_id = Column(Integer, nullable=False, index=True)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class BankUser(Base):
    """Хранение bank_user_id для каждого пользователя и банка"""
    __tablename__ = "bank_users"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    bank_code = Column(String(50), nullable=False, index=True)  # vbank, abank, sbank
    bank_user_id = Column(String(255), nullable=False)  # ID пользователя в банке (например team261-1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (
        Index('ix_user_bank_code', 'user_id', 'bank_code', unique=True),
    )


# ==================== FINANCIAL DATA MODELS ====================

class BankConsent(Base):
    """Хранение согласий на доступ к банковским данным"""
    __tablename__ = "bank_consents"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    bank_code = Column(String(50), nullable=False, index=True)  # vbank, abank, sbank
    consent_id = Column(String(255), unique=True, nullable=False, index=True)
    status = Column(String(50), nullable=False, default="approved")  # approved, pending, revoked
    auto_approved = Column(Boolean, default=True)
    expires_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (Index('ix_user_bank_consent', 'user_id', 'bank_code'),)


class BankAccount(Base):
    """Хранение банковских счетов пользователя"""
    __tablename__ = "bank_accounts"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    bank_code = Column(String(50), nullable=False, index=True)
    account_id = Column(String(255), nullable=False)  # ID счета в банке
    consent_id = Column(String(255), ForeignKey("bank_consents.consent_id"), nullable=True)
    
    # Данные счета
    account_type = Column(String(100), nullable=True)
    currency = Column(String(10), nullable=True, default="RUB")
    account_name = Column(String(255), nullable=True)
    iban = Column(String(50), nullable=True)
    bic = Column(String(50), nullable=True)
    
    # Баланс
    current_balance = Column(Numeric(15, 2), nullable=True)
    available_balance = Column(Numeric(15, 2), nullable=True)
    balance_updated_at = Column(DateTime, nullable=True)
    
    # Метаданные
    is_active = Column(Boolean, default=True)
    last_synced_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (
        Index('ix_user_bank_account', 'user_id', 'bank_code', 'account_id'),
    )


class BankTransaction(Base):
    """Хранение банковских транзакций"""
    __tablename__ = "bank_transactions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    account_id = Column(Integer, ForeignKey("bank_accounts.id"), nullable=False, index=True)
    bank_code = Column(String(50), nullable=False, index=True)
    
    # Данные транзакции
    transaction_id = Column(String(255), nullable=True, index=True)
    amount = Column(Numeric(15, 2), nullable=False)
    currency = Column(String(10), nullable=True, default="RUB")
    transaction_type = Column(String(50), nullable=True)  # debit, credit
    booking_date = Column(DateTime, nullable=False, index=True)
    value_date = Column(DateTime, nullable=True)
    
    # Детали платежа
    remittance_information = Column(Text, nullable=True)  # Назначение платежа
    creditor_name = Column(String(255), nullable=True)
    creditor_account = Column(String(255), nullable=True)
    debtor_name = Column(String(255), nullable=True)
    debtor_account = Column(String(255), nullable=True)
    
    # Категоризация (для аналитики)
    category = Column(String(100), nullable=True, index=True)  # income, expense, transfer
    subcategory = Column(String(100), nullable=True)
    counterparty_id = Column(Integer, ForeignKey("counterparties.id"), nullable=True, index=True)
    
    # Метаданные
    is_processed = Column(Boolean, default=False)  # Обработана ли для аналитики
    created_at = Column(DateTime, default=datetime.utcnow)
    
    __table_args__ = (
        Index('ix_user_date_transaction', 'user_id', 'booking_date'),
        Index('ix_account_date_transaction', 'account_id', 'booking_date'),
    )


class Counterparty(Base):
    """Контрагенты (клиенты и поставщики)"""
    __tablename__ = "counterparties"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    
    # Основная информация
    name = Column(String(255), nullable=False)
    type = Column(String(50), nullable=False, index=True)  # customer, supplier, other
    inn = Column(String(20), nullable=True)  # ИНН
    kpp = Column(String(20), nullable=True)  # КПП
    
    # Контакты
    email = Column(String(255), nullable=True)
    phone = Column(String(20), nullable=True)
    
    # Банковские реквизиты
    account_number = Column(String(50), nullable=True)
    bank_name = Column(String(255), nullable=True)
    bic = Column(String(50), nullable=True)
    correspondent_account = Column(String(50), nullable=True)
    
    # Статистика
    total_received = Column(Numeric(15, 2), default=0)  # Всего получено от контрагента
    total_paid = Column(Numeric(15, 2), default=0)  # Всего выплачено контрагенту
    transaction_count = Column(Integer, default=0)
    
    # Метаданные
    notes = Column(Text, nullable=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (
        Index('ix_user_type_counterparty', 'user_id', 'type'),
    )


class AccountsReceivable(Base):
    """Дебиторская задолженность (счета к получению)"""
    __tablename__ = "accounts_receivable"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    counterparty_id = Column(Integer, ForeignKey("counterparties.id"), nullable=False, index=True)
    
    # Данные счета
    invoice_number = Column(String(100), nullable=False)
    invoice_date = Column(DateTime, nullable=False, index=True)
    due_date = Column(DateTime, nullable=False, index=True)
    amount = Column(Numeric(15, 2), nullable=False)
    currency = Column(String(10), nullable=True, default="RUB")
    
    # Статус
    status = Column(String(50), nullable=False, default="pending", index=True)  # pending, partial, paid, overdue, cancelled
    paid_amount = Column(Numeric(15, 2), default=0)
    
    # Описание
    description = Column(Text, nullable=True)
    
    # Автоматизация
    auto_reminder_enabled = Column(Boolean, default=True)
    last_reminder_sent = Column(DateTime, nullable=True)
    reminder_days_before = Column(Integer, default=3)  # За сколько дней напоминать
    
    # Связь с транзакцией оплаты
    payment_transaction_id = Column(Integer, ForeignKey("bank_transactions.id"), nullable=True)
    
    # Метаданные
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    paid_at = Column(DateTime, nullable=True)
    
    __table_args__ = (
        Index('ix_user_status_ar', 'user_id', 'status'),
        Index('ix_due_date_status', 'due_date', 'status'),
    )


class CashFlowPrediction(Base):
    """Прогнозы денежных потоков (ML predictions)"""
    __tablename__ = "cash_flow_predictions"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    
    # Период прогноза
    prediction_date = Column(DateTime, nullable=False, index=True)  # Дата, на которую прогноз
    prediction_created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Прогнозируемые значения
    predicted_inflow = Column(Numeric(15, 2), nullable=False)  # Прогнозируемый приток
    predicted_outflow = Column(Numeric(15, 2), nullable=False)  # Прогнозируемый отток
    predicted_balance = Column(Numeric(15, 2), nullable=False)  # Прогнозируемый баланс
    
    # Вероятность дефицита
    gap_probability = Column(Numeric(5, 2), nullable=True)  # Вероятность кассового разрыва (0-100)
    gap_amount = Column(Numeric(15, 2), nullable=True)  # Размер возможного разрыва
    
    # Модель и метрики
    model_version = Column(String(50), nullable=True)
    confidence_score = Column(Numeric(5, 2), nullable=True)  # Уверенность модели (0-100)
    
    # Фактические значения (для оценки точности)
    actual_inflow = Column(Numeric(15, 2), nullable=True)
    actual_outflow = Column(Numeric(15, 2), nullable=True)
    actual_balance = Column(Numeric(15, 2), nullable=True)
    
    __table_args__ = (
        Index('ix_user_prediction_date', 'user_id', 'prediction_date'),
    )


class FinancialHealthMetrics(Base):
    """Метрики финансового здоровья"""
    __tablename__ = "financial_health_metrics"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    
    # Период расчета
    period_start = Column(DateTime, nullable=False, index=True)
    period_end = Column(DateTime, nullable=False, index=True)
    calculated_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Доходы и расходы
    total_revenue = Column(Numeric(15, 2), default=0)
    total_expenses = Column(Numeric(15, 2), default=0)
    net_income = Column(Numeric(15, 2), default=0)
    
    # Балансы
    total_assets = Column(Numeric(15, 2), default=0)
    total_liabilities = Column(Numeric(15, 2), default=0)
    net_worth = Column(Numeric(15, 2), default=0)
    
    # Метрики ликвидности
    current_ratio = Column(Numeric(10, 2), nullable=True)  # Коэффициент текущей ликвидности
    quick_ratio = Column(Numeric(10, 2), nullable=True)  # Коэффициент быстрой ликвидности
    
    # Метрики дебиторской задолженности
    total_ar = Column(Numeric(15, 2), default=0)  # Общая дебиторская задолженность
    overdue_ar = Column(Numeric(15, 2), default=0)  # Просроченная ДЗ
    ar_turnover_days = Column(Numeric(10, 2), nullable=True)  # Оборачиваемость ДЗ в днях
    
    # Метрики денежного потока
    operating_cash_flow = Column(Numeric(15, 2), default=0)
    cash_flow_trend = Column(String(50), nullable=True)  # increasing, decreasing, stable
    
    # Общий health score (0-100)
    health_score = Column(Integer, nullable=True)  # 0-100
    health_status = Column(String(50), nullable=True)  # excellent, good, fair, poor, critical
    
    # Дополнительные метрики (JSON для гибкости)
    additional_metrics = Column(JSON, nullable=True)
    
    __table_args__ = (
        Index('ix_user_period_metrics', 'user_id', 'period_start', 'period_end'),
    )
</file>

<file path="app/schemas.py">
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
import re

class UserBase(BaseModel):
    email: EmailStr = Field(..., description="Email адрес")
    phone_number: str = Field(..., description="Номер телефона в формате +7XXXXXXXXXX")
    first_name: str = Field(..., min_length=2, max_length=100)
    last_name: str = Field(..., min_length=2, max_length=100)
    
    @field_validator("phone_number")
    @classmethod
    def validate_phone(cls, v):
        if not re.match(r'^\+7\d{10}$', v):
            raise ValueError("Номер телефона должен быть в формате +7XXXXXXXXXX")
        return v

class UserRegister(UserBase):
    password: str = Field(..., min_length=8, max_length=50)
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну заглавную букву")
        if not re.search(r'[a-z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну строчную букву")
        if not re.search(r'\d', v):
            raise ValueError("Пароль должен содержать хотя бы одну цифру")
        return v

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_email_verified: bool
    is_phone_verified: bool
    created_at: datetime
    
    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class UserInDB(UserResponse):
    hashed_password: str

class SMSVerificationRequest(BaseModel):
    phone_number: str
    
class SMSVerificationConfirm(BaseModel):
    phone_number: str
    code: str = Field(..., min_length=6, max_length=6)
</file>

<file path="app/users_router.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel
from typing import Dict
from app.models import User, BankUser
from app.schemas import UserResponse
from app.database import get_db
from app.security.oauth2 import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Получение информации о текущем пользователе"""
    try:
        result = await db.execute(select(User).where(User.id == user_id))
        user = result.scalars().first()
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        return UserResponse.from_orm(user)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving user information: {str(e)}"
        )

@router.put("/me", response_model=UserResponse)
async def update_user_profile(
    update_data: dict,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Обновление профиля пользователя"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    for key, value in update_data.items():
        if hasattr(user, key):
            setattr(user, key, value)
    
    await db.commit()
    await db.refresh(user)
    
    return UserResponse.from_orm(user)

@router.post("/logout")
async def logout(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Выход из системы"""
    return {"message": "Successfully logged out"}


# ==================== BANK USER ID MANAGEMENT ====================

class BankUserCreate(BaseModel):
    bank_code: str
    bank_user_id: str


class BankUserResponse(BaseModel):
    id: int
    user_id: int
    bank_code: str
    bank_user_id: str
    created_at: str
    updated_at: str
    
    class Config:
        from_attributes = True


@router.get("/me/bank-users")
async def get_user_bank_users(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Получить все bank_user_id для текущего пользователя"""
    try:
        result = await db.execute(
            select(BankUser).where(BankUser.user_id == user_id)
        )
        bank_users = result.scalars().all()
        
        # Формируем словарь {bank_code: bank_user_id}
        bank_users_dict: Dict[str, str] = {}
        for bank_user in bank_users:
            bank_users_dict[bank_user.bank_code] = bank_user.bank_user_id
        
        return {"bank_users": bank_users_dict}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving bank users: {str(e)}"
        )


@router.post("/me/bank-users", response_model=BankUserResponse)
async def save_bank_user(
    bank_user_data: BankUserCreate,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Сохранить или обновить bank_user_id для банка"""
    try:
        # Проверяем валидность bank_code
        valid_banks = ["vbank", "abank", "sbank"]
        if bank_user_data.bank_code not in valid_banks:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid bank_code. Must be one of: {', '.join(valid_banks)}"
            )
        
        # Проверяем существование записи
        result = await db.execute(
            select(BankUser).where(
                BankUser.user_id == user_id,
                BankUser.bank_code == bank_user_data.bank_code
            )
        )
        existing_bank_user = result.scalars().first()
        
        if existing_bank_user:
            # Обновляем существующую запись
            existing_bank_user.bank_user_id = bank_user_data.bank_user_id
            await db.commit()
            await db.refresh(existing_bank_user)
            return BankUserResponse(
                id=existing_bank_user.id,
                user_id=existing_bank_user.user_id,
                bank_code=existing_bank_user.bank_code,
                bank_user_id=existing_bank_user.bank_user_id,
                created_at=existing_bank_user.created_at.isoformat(),
                updated_at=existing_bank_user.updated_at.isoformat()
            )
        else:
            # Создаем новую запись
            new_bank_user = BankUser(
                user_id=user_id,
                bank_code=bank_user_data.bank_code,
                bank_user_id=bank_user_data.bank_user_id
            )
            db.add(new_bank_user)
            await db.commit()
            await db.refresh(new_bank_user)
            return BankUserResponse(
                id=new_bank_user.id,
                user_id=new_bank_user.user_id,
                bank_code=new_bank_user.bank_code,
                bank_user_id=new_bank_user.bank_user_id,
                created_at=new_bank_user.created_at.isoformat(),
                updated_at=new_bank_user.updated_at.isoformat()
            )
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error saving bank user: {str(e)}"
        )


@router.delete("/me/bank-users/{bank_code}")
async def delete_bank_user(
    bank_code: str,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Удалить bank_user_id для банка"""
    try:
        result = await db.execute(
            select(BankUser).where(
                BankUser.user_id == user_id,
                BankUser.bank_code == bank_code
            )
        )
        bank_user = result.scalars().first()
        
        if not bank_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Bank user not found for bank_code: {bank_code}"
            )
        
        await db.delete(bank_user)
        await db.commit()
        
        return {"message": f"Bank user for {bank_code} deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting bank user: {str(e)}"
        )
</file>

<file path="frontend/src/components/BankAccountList/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Building2 } from "lucide-react";
import { useEffect, useState } from "react";
import { getAllBankAccounts, getAccountBalances, extractBalanceFromResponse, getAccountId, type BankAccount } from "../../utils/api";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";

interface AccountDisplay {
  bank: string;
  balance: number;
  currency: string;
  lastSync: string;
  status: string;
  accountId: string;
}

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return "только что";
  if (diffMins < 60) return `${diffMins} мин назад`;
  if (diffHours < 24) return `${diffHours} час${diffHours > 1 ? "а" : ""} назад`;
  return `${diffDays} дн${diffDays > 1 ? "ей" : "ь"} назад`;
}

function getAccountBalance(account: BankAccount): number {
  if (!account.balances || account.balances.length === 0) return 0;
  
  // Ищем баланс типа "InterimAvailable" или "InterimBooked"
  const balance = account.balances.find(
    (b) => b.balanceType === "InterimAvailable" || b.balanceType === "InterimBooked"
  ) || account.balances[0];
  
  return parseFloat(balance.balanceAmount.amount) || 0;
}

export default function BankAccountsList() {
  const { isAuthenticated } = useAuth();
  const [accounts, setAccounts] = useState<AccountDisplay[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastSyncTime, setLastSyncTime] = useState<Date>(new Date());

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchAccounts = async () => {
      try {
        setIsLoading(true);
        setError(null);
        console.log("[BankAccountList] Fetching accounts...");
        const response = await getAllBankAccounts();
        const data = response.data;
        
        console.log("[BankAccountList] Accounts response:", data);

        if (!data.success) {
          throw new Error("Не удалось получить счета");
        }

        const accountsList: AccountDisplay[] = [];
        const balancePromises: Promise<void>[] = [];

        // Обрабатываем счета из всех банков
        Object.entries(data.banks || {}).forEach(([bankCode, bankData]) => {
          console.log(`[BankAccountList] Processing bank ${bankCode}:`, bankData);
          
          if (bankData.success && bankData.accounts) {
            console.log(`[BankAccountList] Bank ${bankCode} has ${bankData.accounts.length} accounts`);
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              if (!accountId) {
                console.warn(`[BankAccountList] Skipping account without account_id:`, account);
                return;
              }
              
              // Используем баланс из данных счета как начальное значение
              const initialBalance = getAccountBalance(account);
              const currency = account.currency || account.balances?.[0]?.balanceAmount?.currency || "RUB";
              
              const accountDisplay: AccountDisplay = {
                bank: bankNames[bankCode] || bankCode,
                balance: initialBalance,
                currency: currency === "RUB" ? "₽" : currency,
                lastSync: formatTimeAgo(lastSyncTime),
                status: "active",
                accountId: accountId,
              };
              
              accountsList.push(accountDisplay);
              
              // Запрашиваем актуальный баланс через API
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id
              )
                .then((response) => {
                  console.log(`[BankAccountList] Balance for account ${accountId}:`, response.data);
                  
                  // Извлекаем баланс из ответа
                  const newBalance = extractBalanceFromResponse(response);
                  console.log(`[BankAccountList] Extracted balance for ${accountId}:`, newBalance);
                  
                  // Обновляем баланс в списке (может быть отрицательным для овердрафта)
                  setAccounts((prev) =>
                    prev.map((acc) =>
                      acc.accountId === accountId
                        ? { ...acc, balance: newBalance }
                        : acc
                    )
                  );
                })
                .catch((err) => {
                  console.error(`[BankAccountList] Error fetching balance for account ${accountId}:`, err);
                  // Не показываем ошибку пользователю, просто используем начальный баланс
                });
              
              balancePromises.push(balancePromise);
            });
          } else {
            const errorMsg = bankData.error || "No accounts";
            console.warn(`[BankAccountList] Bank ${bankCode} failed or has no accounts:`, errorMsg);
            
            // Show helpful message if bank_user_id is missing
            if (errorMsg.includes("bank_user_id") || errorMsg.includes("Please set")) {
              setError(`Для банка ${bankNames[bankCode] || bankCode} необходимо установить ID пользователя в профиле. ${errorMsg}`);
            }
          }
        });

        console.log(`[BankAccountList] Total accounts found: ${accountsList.length}`);
        setAccounts(accountsList);
        setLastSyncTime(new Date());
        
        // Ждем завершения всех запросов балансов (в фоне, не блокируя UI)
        Promise.all(balancePromises).then(() => {
          console.log(`[BankAccountList] All balance requests completed`);
        });
      } catch (err: any) {
        console.error("[BankAccountList] Error fetching bank accounts:", err);
        console.error("[BankAccountList] Error details:", {
          message: err.message,
          response: err.response?.data,
          status: err.response?.status,
        });
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки счетов");
      } finally {
        setIsLoading(false);
      }
    };

    fetchAccounts();
  }, [isAuthenticated]);

  if (!isAuthenticated) {
    return (
      <Card className={styles.bankCard}>
        <CardHeader className={styles.bankCardHeader}>
          <div className={styles.headerGroup}>
            <div className={styles.headerIconBg}>
              <Building2 className={styles.headerIcon} />
            </div>
            <div>
              <CardTitle className={styles.bankCardTitle}>Банковские счета</CardTitle>
              <p className={styles.bankCardSubtitle}>
                Войдите, чтобы увидеть свои счета
              </p>
            </div>
          </div>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card className={styles.bankCard}>
      <CardHeader className={styles.bankCardHeader}>
        <div className={styles.headerGroup}>
          <div className={styles.headerIconBg}>
            <Building2 className={styles.headerIcon} />
          </div>
          <div>
            <CardTitle className={styles.bankCardTitle}>Банковские счета</CardTitle>
            <p className={styles.bankCardSubtitle}>
              Все подключенные счета в одном месте
            </p>
          </div>
        </div>
      </CardHeader>
      <CardContent className={styles.bankCardContent}>
        {isLoading ? (
          <div className={styles.loadingState}>
            <p>Загрузка счетов...</p>
          </div>
        ) : error ? (
          <div className={styles.errorState}>
            <p>{error}</p>
          </div>
        ) : accounts.length === 0 ? (
          <div className={styles.emptyState}>
            <p>Нет подключенных счетов</p>
          </div>
        ) : (
          <div className={styles.accountList}>
            {accounts.map((account, index) => (
              <div
                key={`${account.accountId}-${index}`}
                className={styles.accountItem}
              >
                <div className={styles.itemDetails}>
                  <div className={styles.itemIconBg}>
                    <Building2 className={styles.itemIcon} />
                  </div>
                  <div>
                    <p className={styles.itemBank}>{account.bank}</p>
                    <p className={styles.itemSync}>
                      актуален: {account.lastSync}
                    </p>
                  </div>
                </div>
                <div className={styles.itemBalance}>
                  <p className={styles.balanceAmount}>
                    {account.currency}
                    {account.balance.toLocaleString("ru-RU", {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2,
                    })}
                  </p>
                  <Badge className={styles.statusBadge}>активен</Badge>
                </div>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="frontend/src/components/ReceivablesTable/index.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Badge } from "../../ui/badge";
import { Button } from "../../ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "../../ui/table";
import { useEffect, useState } from "react";
import { getAllBankAccounts, getAccountTransactions, getAccountBalances, getAccountId, type BankAccount, type BankTransaction } from "../../utils/api";
import { useAuth } from "../../hooks/useAuth";
import styles from "./index.module.scss";
import { Phone } from "lucide-react";

interface Receivable {
  id: string;
  counterparty: string;
  amount: number;
  dueDate: string;
  status: "pending" | "overdue" | "received";
  transactionId?: string;
}

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

function formatDate(dateString?: string): string {
  if (!dateString) return "—";
  try {
    const date = new Date(dateString);
    const day = date.getDate().toString().padStart(2, "0");
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    return `${day}.${month}`;
  } catch {
    return "—";
  }
}

function isOverdue(dateString?: string): boolean {
  if (!dateString) return false;
  try {
    const date = new Date(dateString);
    const now = new Date();
    return date < now;
  } catch {
    return false;
  }
}

export default function ReceivablesTable() {
  const { isAuthenticated } = useAuth();
  const [receivables, setReceivables] = useState<Receivable[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchReceivables = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // Сначала получаем все счета
        console.log("[ReceivablesTable] Fetching accounts...");
        const accountsResponse = await getAllBankAccounts();
        const accountsData = accountsResponse.data;
        
        console.log("[ReceivablesTable] Accounts response:", accountsData);

        if (!accountsData.success) {
          throw new Error("Не удалось получить счета");
        }

        const receivablesList: Receivable[] = [];
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const fromDate = thirtyDaysAgo.toISOString().split("T")[0];
        const toDate = now.toISOString().split("T")[0];

        // Получаем транзакции и балансы из всех счетов
        const transactionPromises: Promise<void>[] = [];

        Object.entries(accountsData.banks || {}).forEach(([bankCode, bankData]) => {
          console.log(`[ReceivablesTable] Processing bank ${bankCode}:`, bankData);
          
          if (bankData.success && bankData.accounts && bankData.accounts.length > 0) {
            console.log(`[ReceivablesTable] Bank ${bankCode} has ${bankData.accounts.length} accounts`);
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              
              if (!accountId) {
                console.warn(`[ReceivablesTable] Skipping account without account_id:`, account);
                return;
              }
              
              console.log(`[ReceivablesTable] Fetching transactions for account ${accountId} from ${bankCode}`);
              
              // Получаем баланс счета (сервер автоматически использует сохраненный consent_id)
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id // опционально, сервер получит из БД если не указано
              )
                .then((response) => {
                  console.log(`[ReceivablesTable] Balance for account ${accountId}:`, response.data);
                  // Здесь можно обработать баланс, например, сохранить в состояние или отобразить
                })
                .catch((err) => {
                  console.error(`[ReceivablesTable] Error fetching balance for account ${accountId}:`, err);
                  console.error(`[ReceivablesTable] Error details:`, {
                    message: err.message,
                    response: err.response?.data,
                    status: err.response?.status,
                  });
                });
              
              transactionPromises.push(balancePromise);
              
              // Сервер автоматически использует сохраненный consent_id
              const promise = getAccountTransactions(
                accountId,
                bankCode,
                undefined, // consent_id не передаем - сервер использует сохраненный
                fromDate,
                toDate
              )
                .then((response) => {
                  const transactions = response.data.transactions || [];
                  console.log(`[ReceivablesTable] Received ${transactions.length} transactions for account ${accountId}`);
                  
                  // Фильтруем входящие транзакции (Credit)
                  // Берем только первые 5 с каждого банка
                  const creditTransactions = transactions
                    .filter((tx) => {
                      const indicator = tx.transaction_type || tx.creditDebitIndicator;
                      return indicator === "Credit";
                    })
                    .slice(0, 5); // Ограничиваем до 5 транзакций с каждого банка
                  
                  creditTransactions.forEach((tx) => {
                    // Извлекаем сумму из нового формата
                    const amount = tx.amount || 0;
                    
                    // Используем название банка вместо контрагента
                    const counterparty = bankNames[bankCode] || bankCode;
                    
                    // Извлекаем дату
                    const bookingDate = tx.booking_date || tx.bookingDateTime || tx.value_date || tx.valueDateTime;
                    const status = bookingDate && isOverdue(bookingDate) 
                      ? "overdue" 
                      : bookingDate 
                      ? "pending" 
                      : "received";

                    receivablesList.push({
                      id: tx.transaction_id || tx.transactionId || `${accountId}-${tx.transactionReference || Date.now()}`,
                      counterparty,
                      amount,
                      dueDate: formatDate(bookingDate),
                      status: status as "pending" | "overdue" | "received",
                      transactionId: tx.transaction_id || tx.transactionId,
                    });
                  });
                })
                .catch((err) => {
                  console.error(`[ReceivablesTable] Error fetching transactions for account ${accountId}:`, err);
                  console.error(`[ReceivablesTable] Error details:`, {
                    message: err.message,
                    response: err.response?.data,
                    status: err.response?.status,
                  });
                });
              
              transactionPromises.push(promise);
            });
          } else {
            console.warn(`[ReceivablesTable] Bank ${bankCode} has no accounts or failed:`, bankData.error || "No accounts");
          }
        });

        console.log(`[ReceivablesTable] Waiting for ${transactionPromises.length} transaction requests...`);
        await Promise.all(transactionPromises);
        console.log(`[ReceivablesTable] Found ${receivablesList.length} receivables`);

        // Сортируем по дате (новые сначала)
        receivablesList.sort((a, b) => {
          if (a.dueDate === "—" && b.dueDate === "—") return 0;
          if (a.dueDate === "—") return 1;
          if (b.dueDate === "—") return -1;
          return b.dueDate.localeCompare(a.dueDate);
        });

        setReceivables(receivablesList);
      } catch (err: any) {
        console.error("Error fetching receivables:", err);
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки данных");
      } finally {
        setIsLoading(false);
      }
    };

    fetchReceivables();
  }, [isAuthenticated]);

  const getStatusBadge = (status: string) => {
    if (status === "overdue") {
      return (
        <Badge className={styles.badgeOverdue}>
          Overdue
        </Badge>
      );
    }
    if (status === "received") {
      return (
        <Badge className={styles.badgePending} style={{ backgroundColor: "#10b981" }}>
          Received
        </Badge>
      );
    }
    return (
      <Badge className={styles.badgePending}>
        Pending
      </Badge>
    );
  };

  if (!isAuthenticated) {
    return (
      <Card className={styles.cardRoot}>
        <CardHeader className={styles.header}>
          <div className={styles.iconBox} aria-hidden>
            <svg className="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div className={styles.headerText}>
            <CardTitle className={styles.title}>Выплаты</CardTitle>
            <p className={styles.subtitle}>Войдите, чтобы увидеть входящие платежи</p>
          </div>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card className={styles.cardRoot}>
      <CardHeader className={styles.header}>
        <div className={styles.iconBox} aria-hidden>
          <svg className="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
        <div className={styles.headerText}>
          <CardTitle className={styles.title}>Выплаты</CardTitle>
          <p className={styles.subtitle}>Отслеживайте входящие платежи и управляйте ими</p>
        </div>
      </CardHeader>
      <CardContent className={styles.content}>
        {isLoading ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка данных...</p>
          </div>
        ) : error ? (
          <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
            <p>{error}</p>
          </div>
        ) : receivables.length === 0 ? (
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Нет входящих платежей за последние 30 дней</p>
          </div>
        ) : (
          <div className={styles.tableWrap}>
            <Table>
              <TableHeader>
                <TableRow className={styles.tableRow}>
                  <TableHead className={styles.counterparty}>Банк</TableHead>
                  <TableHead className={styles.amount}>Сумма</TableHead>
                  <TableHead className={styles.dueDate}>Дата</TableHead>
                  <TableHead>Статус</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {receivables.map((item) => (
                  <TableRow key={item.id} className={`${styles.tableRow} ${styles.tableRowHover}`}>
                    <TableCell className={styles.counterparty}>{item.counterparty}</TableCell>
                    <TableCell className={styles.amount}>
                      ₽{item.amount.toLocaleString("ru-RU", {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                      })}
                    </TableCell>
                    <TableCell className={styles.dueDate}>{item.dueDate}</TableCell>
                    <TableCell>{getStatusBadge(item.status)}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="frontend/src/pages/home/index.tsx">
import Layout from "../../components/Layout";
import StatCard from "../../components/StatCard";
import CashFlowChart from "../../components/CashFlowChart";
import BankAccountsList from "../../components/BankAccountList";
import ReceivablesTable from "../../components/ReceivablesTable";
import Landing from "../Landing";
import { Wallet, TrendingUp, TrendingDown, AlertCircle, CircleUser } from "lucide-react";
import styles from "./index.module.scss";
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { AuthModal } from "../Auth";
import { useAuth } from "../../hooks/useAuth";
import { getDashboardSummary, getAllBankAccounts, getAccountBalances, extractBalanceFromResponse, getAccountId, type DashboardSummary } from "../../utils/api";

export default function Index() {
  const [isAuthOpen, setIsAuthOpen] = useState(false);
  const navigate = useNavigate();
  const { isAuthenticated, isLoading } = useAuth();
  const [dashboardData, setDashboardData] = useState<DashboardSummary["summary"] | null>(null);
  const [isLoadingDashboard, setIsLoadingDashboard] = useState(false);
  const [totalBalance, setTotalBalance] = useState<number | null>(null);
  const [accountsCount, setAccountsCount] = useState<number>(0);

  useEffect(() => {
    if (!isAuthenticated) {
      return;
    }

    const fetchDashboardData = async () => {
      try {
        setIsLoadingDashboard(true);
        const response = await getDashboardSummary();
        if (response.data.success && response.data.summary) {
          setDashboardData(response.data.summary);
        }
      } catch (err: any) {
        console.error("Error fetching dashboard summary:", err);
        // Don't show error toast - dashboard can work without summary
      } finally {
        setIsLoadingDashboard(false);
      }
    };

    fetchDashboardData();
  }, [isAuthenticated]);

  useEffect(() => {
    if (!isAuthenticated) {
      return;
    }

    const fetchBalances = async () => {
      try {
        console.log("[Dashboard] Fetching accounts and balances...");
        const accountsResponse = await getAllBankAccounts();
        const accountsData = accountsResponse.data;
        
        if (!accountsData.success) {
          console.warn("[Dashboard] Failed to get accounts");
          return;
        }

        let count = 0;
        const balancePromises: Promise<number>[] = [];

        Object.entries(accountsData.banks || {}).forEach(([bankCode, bankData]) => {
          if (bankData.success && bankData.accounts && bankData.accounts.length > 0) {
            count += bankData.accounts.length;
            
            bankData.accounts.forEach((account) => {
              const accountId = getAccountId(account);
              if (!accountId) {
                console.warn(`[Dashboard] Skipping account without account_id:`, account);
                return;
              }
              
              const balancePromise = getAccountBalances(
                accountId,
                bankCode,
                bankData.consent_id
              )
                .then((response) => {
                  console.log(`[Dashboard] Balance for account ${accountId}:`, response.data);
                  
                  // Извлекаем баланс из ответа
                  const balance = extractBalanceFromResponse(response);
                  console.log(`[Dashboard] Extracted balance for ${accountId}:`, balance);
                  return balance;
                })
                .catch((err) => {
                  console.error(`[Dashboard] Error fetching balance for account ${accountId}:`, err);
                  return 0;
                });
              
              balancePromises.push(balancePromise);
            });
          }
        });

        setAccountsCount(count);
        
        // Ждем все запросы и суммируем балансы
        const balances = await Promise.all(balancePromises);
        const total = balances.reduce((sum, balance) => sum + balance, 0);
        setTotalBalance(total);
        console.log(`[Dashboard] Total balance calculated: ${total}`);
      } catch (err: any) {
        console.error("[Dashboard] Error fetching balances:", err);
      }
    };

    fetchBalances();
  }, [isAuthenticated]);

  const handleUserClick = () => {
    if (isAuthenticated) {
      navigate("/profile");
    } else {
      setIsAuthOpen(true);
    }
  };

  // Show landing page if not authenticated
  if (!isAuthenticated && !isLoading) {
    return <Landing />;
  }

  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <Layout>
        <div className={styles.dashboardContainer}>
          <div style={{ padding: "2rem", textAlign: "center" }}>
            <p>Загрузка...</p>
          </div>
        </div>
      </Layout>
    );
  }

  return (
    <Layout>
      <AuthModal 
        isOpen={isAuthOpen} 
        onClose={() => setIsAuthOpen(false)} 
      />

      <div className={styles.dashboardContainer}>
        
        <div className={styles.headerSection}>
          <div className={styles.headerRow}>
          <h1 className={styles.mainTitle}>Дашборд</h1>
          <button 
              className={styles.userButton}
              onClick={handleUserClick}
              aria-label="Профиль"
              title="Профиль"
            >
              <CircleUser size={24} />
          </button>
          </div>
          <p className={styles.subtitle}>
            Финансовый обзор и ключевые показатели
          </p>
        </div>

        <div className={styles.statsGrid}>
          <StatCard
            title="Общий баланс"
            value={totalBalance !== null ? `₽${totalBalance.toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : (dashboardData ? `₽${(dashboardData.total_balance || 0).toLocaleString()}` : "—")}
            subtitle={accountsCount > 0 ? `${accountsCount} счет${accountsCount === 1 ? "" : accountsCount < 5 ? "а" : "ов"}` : (dashboardData ? `${dashboardData.accounts_count || 0} счетов` : "Загрузка...")}
            icon={Wallet}
            variant="default"
          />
          <StatCard
            title="Доходы"
            value={dashboardData ? `₽${(dashboardData.total_revenue || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? "За последние 30 дней" : "Загрузка..."}
            icon={TrendingUp}
            variant="success"
          />
          <StatCard
            title="Дебиторская задолженность"
            value={dashboardData ? `₽${(dashboardData.total_ar || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? `Просрочено: ₽${(dashboardData.overdue_ar || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "Загрузка..."}
            icon={AlertCircle}
            variant="danger"
          />
          <StatCard
            title="Чистая прибыль"
            value={dashboardData ? `₽${(dashboardData.net_income || 0).toLocaleString("ru-RU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "—"}
            subtitle={dashboardData ? (dashboardData.net_income && dashboardData.net_income >= 0 ? "Положительная" : "Отрицательная") : "Загрузка..."}
            icon={TrendingDown}
            variant={dashboardData && dashboardData.net_income && dashboardData.net_income >= 0 ? "success" : "warning"}
          />
        </div>

        <div className={styles.chartsGrid}>
          <CashFlowChart />
          <BankAccountsList />
        </div>

        <ReceivablesTable />
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/pages/Payments/index.tsx">
import Layout from "../../components/Layout";
import { Card, CardContent, CardHeader, CardTitle } from "../../ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../../ui/table";
import { Calendar, ArrowUpCircle, ArrowDownCircle } from "lucide-react";
import { useEffect, useState } from "react";
import { useAuth } from "../../hooks/useAuth";
import { getAllBankAccounts, getAccountTransactions, getAccountId, type BankTransaction } from "../../utils/api";
import styles from "./index.module.scss";
import { toast } from "sonner";

const bankNames: { [key: string]: string } = {
  vbank: "Virtual Bank",
  abank: "Awesome Bank",
  sbank: "Smart Bank",
};

export default function Payments() {
  const { isAuthenticated } = useAuth();
  const [transactions, setTransactions] = useState<BankTransaction[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filter, setFilter] = useState<"all" | "income" | "expense">("all");

  useEffect(() => {
    if (!isAuthenticated) {
      setIsLoading(false);
      return;
    }

    const fetchTransactions = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const accountsRes = await getAllBankAccounts();
        if (!accountsRes.data.success) {
          throw new Error("Не удалось получить счета");
        }

        const allTransactions: BankTransaction[] = [];
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const fromDate = thirtyDaysAgo.toISOString().split("T")[0];
        const toDate = now.toISOString().split("T")[0];

        const bankNames: { [key: string]: string } = {
          vbank: "Virtual Bank",
          abank: "Awesome Bank",
          sbank: "Smart Bank",
        };

        const transactionPromises: Promise<void>[] = [];

        Object.entries(accountsRes.data.banks || {}).forEach(([bankCode, bankData]) => {
          if (bankData.success && bankData.accounts) {
            bankData.accounts.forEach((account) => {
              // Получаем account_id используя унифицированную функцию
              const accountId = getAccountId(account);
              
              if (!accountId) {
                console.warn(`[Payments] Skipping account without account_id:`, account);
                return;
              }
              
              const promise = getAccountTransactions(
                accountId,
                bankCode,
                undefined,
                fromDate,
                toDate
              )
                .then((response) => {
                  const txs = response.data.transactions || [];
                  // Добавляем название банка к каждой транзакции
                  const txsWithBank = txs.map((tx: BankTransaction) => ({
                    ...tx,
                    bankName: bankNames[bankCode] || bankCode,
                    bankCode: bankCode,
                  }));
                  allTransactions.push(...txsWithBank);
                })
                .catch((err) => {
                  console.error(`Error fetching transactions for account ${accountId}:`, err);
                });

              transactionPromises.push(promise);
            });
          }
        });

        await Promise.all(transactionPromises);

        // Sort by date (newest first)
        allTransactions.sort((a, b) => {
          const dateA = new Date(a.booking_date || a.bookingDateTime || a.value_date || a.valueDateTime || 0).getTime();
          const dateB = new Date(b.booking_date || b.bookingDateTime || b.value_date || b.valueDateTime || 0).getTime();
          return dateB - dateA;
        });

        setTransactions(allTransactions);
      } catch (err: any) {
        console.error("Error fetching payments:", err);
        setError(err.response?.data?.detail || err.message || "Ошибка загрузки данных");
        toast.error("Не удалось загрузить транзакции");
      } finally {
        setIsLoading(false);
      }
    };

    fetchTransactions();
  }, [isAuthenticated]);

  const filteredTransactions = transactions.filter((tx) => {
    if (filter === "all") return true;
    const indicator = tx.transaction_type || tx.creditDebitIndicator;
    if (filter === "income") return indicator === "Credit";
    if (filter === "expense") return indicator === "Debit";
    return true;
  });

  const formatDate = (dateString?: string) => {
    if (!dateString) return "—";
    return new Date(dateString).toLocaleDateString("ru-RU", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
  };

  const formatAmount = (amount: number | string | undefined) => {
    if (amount === undefined || amount === null) return "0.00";
    const numAmount = typeof amount === "string" ? parseFloat(amount) : amount;
    return numAmount.toLocaleString("ru-RU", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  };

  if (!isAuthenticated) {
    return (
      <Layout>
        <Card>
          <CardHeader>
            <CardTitle>Платежи</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Войдите, чтобы увидеть транзакции</p>
          </CardContent>
        </Card>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Платежи</h1>
          <p>История транзакций за последние 30 дней</p>
        </div>

        <Card>
          <CardHeader>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <CardTitle>Транзакции</CardTitle>
              <div className={styles.filters}>
                <button
                  className={filter === "all" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("all")}
                >
                  Все
                </button>
                <button
                  className={filter === "income" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("income")}
                >
                  Доходы
                </button>
                <button
                  className={filter === "expense" ? styles.filterActive : styles.filterButton}
                  onClick={() => setFilter("expense")}
                >
                  Расходы
                </button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Загрузка данных...</p>
              </div>
            ) : error ? (
              <div style={{ padding: "2rem", textAlign: "center", color: "#ef4444" }}>
                <p>{error}</p>
              </div>
            ) : filteredTransactions.length === 0 ? (
              <div style={{ padding: "2rem", textAlign: "center" }}>
                <p>Нет транзакций за выбранный период</p>
              </div>
            ) : (
              <div className={styles.tableWrap}>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Дата</TableHead>
                      <TableHead>Описание</TableHead>
                      <TableHead>Банк</TableHead>
                      <TableHead>Тип</TableHead>
                      <TableHead>Сумма</TableHead>
                      <TableHead>Статус</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredTransactions.map((tx: any) => {
                      const indicator = tx.transaction_type || tx.creditDebitIndicator;
                      const isCredit = indicator === "Credit";
                      const txAmount = tx.amount || 0;
                      const txDate = tx.booking_date || tx.bookingDateTime || tx.value_date || tx.valueDateTime;
                      const txDescription = 
                        tx.transactionInformation ||
                        (typeof tx.remittance_information === "string" ? tx.remittance_information :
                         (tx.remittanceInformation && typeof tx.remittanceInformation === "object" ? tx.remittanceInformation.unstructured :
                          typeof tx.remittanceInformation === "string" ? tx.remittanceInformation : null)) ||
                        "Без описания";
                      // Используем название банка вместо контрагента
                      const bankName = tx.bankName || (tx.bankCode ? (bankNames[tx.bankCode] || tx.bankCode) : "—");
                      const txId = tx.transaction_id || tx.transactionId || `${txDate}-${txAmount}`;
                      
                      return (
                        <TableRow key={txId}>
                          <TableCell>{formatDate(txDate)}</TableCell>
                          <TableCell className={styles.description}>
                            {txDescription}
                          </TableCell>
                          <TableCell>{bankName}</TableCell>
                          <TableCell>
                            {isCredit ? (
                              <div className={styles.typeIncome}>
                                <ArrowUpCircle size={16} />
                                <span>Доход</span>
                              </div>
                            ) : (
                              <div className={styles.typeExpense}>
                                <ArrowDownCircle size={16} />
                                <span>Расход</span>
                              </div>
                            )}
                          </TableCell>
                          <TableCell
                            className={isCredit ? styles.amountIncome : styles.amountExpense}
                          >
                            {isCredit ? "+" : "-"}₽{formatAmount(txAmount)}
                          </TableCell>
                          <TableCell>
                            <span className={styles.status}>{tx.status || "Booked"}</span>
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </Layout>
  );
}
</file>

<file path="frontend/src/utils/api.ts">
import axios from "axios";
import { getCookie, setCookie, eraseCookie } from "./cookies";


export interface RegisterData {
  email: string;
  phone_number: string;
  first_name: string;
  last_name: string;
  password: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}

export interface UserResponse {
  id: string;
  email: string;
  phone_number: string;
  first_name: string;
  last_name: string;
  is_active: boolean;
}


const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8000";

const api = axios.create({
  baseURL: API_URL,
});

// Логирование запросов
api.interceptors.request.use((config) => {
  const token = getCookie("access_token");
  if (token && !config.headers.Authorization) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  // Логируем запросы (только в development)
  if (import.meta.env.DEV) {
    console.log(`[API Request] ${config.method?.toUpperCase()} ${config.url}`, {
      params: config.params,
      data: config.data,
    });
  }
  
  return config;
});

// Логирование ответов
api.interceptors.response.use(
  (response) => {
    // Логируем успешные ответы (только в development)
    if (import.meta.env.DEV) {
      console.log(`[API Response] ${response.config.method?.toUpperCase()} ${response.config.url}`, {
        status: response.status,
        data: response.data,
      });
    }
    return response;
  },
  (error) => {
    // Логируем ошибки
    if (error.response) {
      console.error(`[API Error] ${error.config?.method?.toUpperCase()} ${error.config?.url}`, {
        status: error.response.status,
        data: error.response.data,
        headers: error.response.headers,
      });
    } else if (error.request) {
      console.error(`[API Error] No response received`, error.request);
    } else {
      console.error(`[API Error]`, error.message);
    }
    return Promise.reject(error);
  }
);

// для автоматического обновления токена (объединено с логированием выше)
api.interceptors.response.use(
  (response: any) => response,
  async (error: { config: any; response: { status: number; }; }) => {
    const originalRequest = error.config;
    
    // Логируем ошибки (уже делается выше, но добавляем для refresh token)
    if (error.response?.status === 401 && !originalRequest._retry) {
      console.log("[API] Token expired, attempting refresh...");
      originalRequest._retry = true;
      const refreshToken = getCookie("refresh_token");

      if (refreshToken) {
        try {
          const { data } = await axios.post<TokenResponse>(
            `${API_URL}/auth/refresh`,
            { refresh_token: refreshToken }
          );
          setCookie("access_token", data.access_token, 15 / (24 * 60)); // 15 минут
          setCookie("refresh_token", data.refresh_token, 7); // 7 дней
          axios.defaults.headers.common["Authorization"] = `Bearer ${data.access_token}`;
          originalRequest.headers.Authorization = `Bearer ${data.access_token}`;
          console.log("[API] Token refreshed successfully");
          return api(originalRequest);
        } catch (refreshError) {
          console.error("[API] Refresh token failed", refreshError);
          // Очищаем токены при неудачном обновлении
          eraseCookie("access_token");
          eraseCookie("refresh_token");
          delete axios.defaults.headers.common["Authorization"];
          // Не делаем редирект автоматически - пусть компоненты решают сами
          return Promise.reject(refreshError);
        }
      } else {
        // Нет refresh токена - очищаем access токен
        eraseCookie("access_token");
        delete axios.defaults.headers.common["Authorization"];
      }
    }
    return Promise.reject(error);
  }
);



export const register = (data: RegisterData) => {
  console.log("api: send register request: ", data)
  return api.post<UserResponse>("/auth/register", data);
};


export const verifySms = (phone_number: string, code: string) => {
  return api.post("/auth/verify-sms", { phone_number, code });
};

export const login = (email: string, password: string) => {
  return api.post<TokenResponse>("/auth/login", { email, password });
};

export const getMe = () => {
  return api.get<UserResponse>("/users/me");
};

export const startBankOAuth = () => {
  // Просто перенаправляем пользователя на эндпоинт нашего бэкенда
  window.location.href = `${API_URL}/auth/oauth/authorize`;
};

export const logout = () => {
  // Очистка токенов происходит на клиенте
  eraseCookie("access_token");
  eraseCookie("refresh_token");
  delete axios.defaults.headers.common["Authorization"];
  // Можно добавить вызов API для инвалидации токена на сервере, если нужно
};


export interface BankAccount {
  account_id?: string;
  id?: string;
  accountId?: string;
  account_type?: string;
  currency?: string;
  nickname?: string;
  account?: {
    schemeName?: string;
    identification?: string;
    name?: string;
    secondaryIdentification?: string;
    account_id?: string;
  };
  balances?: Array<{
    balanceAmount: {
      amount: string;
      currency: string;
    };
    balanceType: string;
    creditDebitIndicator: string;
  }>;
}

// Вспомогательная функция для получения account_id из разных форматов
export const getAccountId = (account: BankAccount): string | null => {
  return account.account_id || 
         account.id || 
         account.accountId || 
         account.account?.identification || 
         account.account?.account_id || 
         null;
}

export interface BankAccountsResponse {
  success: boolean;
  banks: {
    [bankCode: string]: {
      success: boolean;
      accounts: BankAccount[];
      consent_id?: string;
      count: number;
      error?: string;
    };
  };
  total_accounts: number;
}

export interface BankTransaction {
  transaction_id?: string;
  transactionId?: string;
  transactionReference?: string;
  account_id: string;
  amount?: number;
  currency?: string;
  transaction_type?: string;
  creditDebitIndicator?: string;
  status?: string;
  booking_date?: string;
  bookingDateTime?: string;
  value_date?: string;
  valueDateTime?: string;
  remittance_information?: string;
  transactionInformation?: string;
  remittanceInformation?: {
    unstructured?: string;
  } | string;
  creditor_name?: string;
  creditorName?: string;
  creditor_account?: string;
  creditorAccount?: {
    identification?: string;
  };
  debtor_name?: string;
  debtorName?: string;
  debtor_account?: string;
  debtorAccount?: {
    identification?: string;
  };
}

export interface BankTransactionsResponse {
  success: boolean;
  account_id: string;
  transactions: BankTransaction[];
  total_count: number;
}

export interface BankBalance {
  accountId?: string;
  amount?: {
    amount: string;
    currency: string;
  } | string;
  balanceAmount?: {
    amount: string;
    currency: string;
  };
  type?: string;
  balanceType?: string;
  creditDebitIndicator?: string;
  dateTime?: string;
}

export interface BankBalancesResponse {
  success: boolean;
  balances: BankBalance[] | {
    data?: {
      balance?: BankBalance[];
    };
    Data?: {
      Balance?: BankBalance[];
    };
    balance?: BankBalance[];
  };
}

// Получить все счета из всех банков
export const getAllBankAccounts = () => {
  return api.get<BankAccountsResponse>("/api/v1/banks/accounts/all");
};

// Получить счета из конкретного банка
export const getBankAccounts = (bankCode: string) => {
  return api.get<{ success: boolean; accounts: BankAccount[]; consent_id?: string; auto_approved?: boolean }>(
    `/api/v1/banks/accounts?bank_code=${bankCode}`
  );
};

// Получить балансы счета
export const getAccountBalances = (
  accountId: string,
  bankCode: string,
  consentId?: string
) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  
  // Используем согласие из куки, если не указано явно
  const effectiveConsentId = getCookie(`consent_${bankCode}`);
  if (effectiveConsentId) {
    params.append("consent_id", effectiveConsentId);
  }
  
  return api.get<BankBalancesResponse>(
    `/api/v1/banks/accounts/${accountId}/balances?${params.toString()}`
  );
};

// Утилита для извлечения баланса из ответа API
export const extractBalanceFromResponse = (response: { data: BankBalancesResponse }): number => {
  let balances = response.data.balances;
  
  // Поддерживаем разные форматы ответа
  if (balances && !Array.isArray(balances)) {
    // Формат: { data: { balance: [...] } }
    if ((balances as any).data?.balance) {
      balances = (balances as any).data.balance;
    }
    // Формат: { Data: { Balance: [...] } }
    else if ((balances as any).Data?.Balance) {
      balances = (balances as any).Data.Balance;
    }
    // Формат: массив напрямую
    else if (Array.isArray((balances as any).balance)) {
      balances = (balances as any).balance;
    }
  }
  
  if (Array.isArray(balances) && balances.length > 0) {
    // Ищем баланс типа "InterimAvailable" или "InterimBooked"
    // Поддерживаем оба формата: balanceType/type и balanceAmount/amount
    const balance = balances.find(
      (b: any) => 
        (b.type === "InterimAvailable" || b.balanceType === "InterimAvailable") ||
        (b.type === "InterimBooked" || b.balanceType === "InterimBooked")
    ) || balances[0];
    
    // Извлекаем сумму из разных форматов
    // Поддерживаем: amount.amount, balanceAmount.amount, amount (строка)
    let amountStr: string | undefined;
    
    if (balance?.amount) {
      if (typeof balance.amount === "object" && balance.amount.amount) {
        amountStr = balance.amount.amount;
      } else if (typeof balance.amount === "string") {
        amountStr = balance.amount;
      }
    }
    
    if (!amountStr && balance?.balanceAmount) {
      if (typeof balance.balanceAmount === "object" && balance.balanceAmount.amount) {
        amountStr = balance.balanceAmount.amount;
      } else if (typeof balance.balanceAmount === "string") {
        amountStr = balance.balanceAmount;
      }
    }
    
    if (amountStr) {
      const parsed = parseFloat(String(amountStr));
      if (!isNaN(parsed)) {
        return parsed;
      }
    }
  }
  
  return 0;
};

export const getAccountTransactions = (
  accountId: string,
  bankCode: string,
  consentId?: string,
  fromDate?: string,
  toDate?: string
) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  
  // Используем согласие из куки, если не указано явно
  const effectiveConsentId = getCookie(`consent_${bankCode}`);
  if (effectiveConsentId) {
    params.append("consent_id", effectiveConsentId);
  }
  
  if (fromDate) params.append("from_date", fromDate);
  if (toDate) params.append("to_date", toDate);
  
  return api.get<BankTransactionsResponse>(
    `/api/v1/banks/accounts/${accountId}/transactions?${params.toString()}`
  );
};



export interface BankUser {
  id: number;
  user_id: number;
  bank_code: string;
  bank_user_id: string;
  consent_id?: string;
  created_at: string;
  updated_at: string;
}

export interface BankUsersResponse {
  bank_users: Record<string, string>;
}

export interface BankUserCreate {
  bank_code: string;
  bank_user_id: string;
}

// Получить все bank_user_id пользователя
export const getUserBankUsers = () => {
  return api.get<BankUsersResponse>("/users/me/bank-users");
};

// Сохранить или обновить bank_user_id
export const saveBankUser = (bankUser: BankUserCreate) => {
  return api.post<BankUser>("/users/me/bank-users", bankUser);
};

// Удалить bank_user_id
export const deleteBankUser = (bankCode: string) => {
  return api.delete(`/users/me/bank-users/${bankCode}`);
};

// ==================== CONSENTS API ====================

export interface BankConsent {
  consent_id: string;
  bank_code: string;
  status: string;
  auto_approved: boolean;
  expires_at?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateConsentResponse {
  success: boolean;
  consent_id: string;
  status: string;
  auto_approved: boolean;
  permissions: string[];
  expires_at: string;
  message: string;
}

export interface ConsentsResponse {
  success: boolean;
  consents: BankConsent[];
}

// Создать согласие для банка
export const createAccountConsent = (bankCode: string, permissions?: string[]) => {
  const params = new URLSearchParams({
    bank_code: bankCode,
  });
  if (permissions && permissions.length > 0) {
    permissions.forEach(perm => params.append("permissions", perm));
  }
  
  return api.post<CreateConsentResponse>(
    `/api/v1/banks/account-consents?${params.toString()}`
  );
};

// Получить список согласий пользователя
export const getUserConsents = () => {
  return api.get<ConsentsResponse>("/api/v1/banks/consents");
};

// ==================== ANALYTICS API ====================

export interface HealthMetrics {
  success: boolean;
  metrics?: {
    total_revenue: number;
    total_expenses: number;
    net_income: number;
    total_assets: number;
    total_liabilities: number;
    net_worth: number;
    current_ratio?: number;
    quick_ratio?: number;
    total_ar: number;
    overdue_ar: number;
    ar_turnover_days?: number;
    operating_cash_flow: number;
    cash_flow_trend?: string;
    health_score?: number;
    health_status?: string;
  };
  error?: string;
}

export interface DashboardSummary {
  success: boolean;
  summary?: {
    total_balance: number;
    total_revenue: number;
    total_expenses: number;
    net_income: number;
    total_ar: number;
    overdue_ar: number;
    accounts_count: number;
  };
  error?: string;
}

export const getHealthMetrics = (periodStart?: string, periodEnd?: string) => {
  const params = new URLSearchParams();
  if (periodStart) params.append("period_start", periodStart);
  if (periodEnd) params.append("period_end", periodEnd);
  return api.get<HealthMetrics>(`/api/v1/analytics/health-metrics?${params.toString()}`);
};

export const getDashboardSummary = () => {
  return api.get<DashboardSummary>("/api/v1/analytics/dashboard");
};

// ==================== PREDICTIONS API ====================

export interface CashFlowPrediction {
  success: boolean;
  predictions?: Array<{
    prediction_date: string;
    predicted_inflow: number;
    predicted_outflow: number;
    predicted_balance: number;
    gap_probability?: number;
    gap_amount?: number;
    confidence_score?: number;
  }>;
  error?: string;
}

export interface CashFlowGap {
  success: boolean;
  gaps?: Array<{
    date: string;
    gap_amount: number;
    probability: number;
    severity: string;
  }>;
  error?: string;
}

export const getCashFlowPredictions = (weeksAhead: number = 4, predictionDate?: string) => {
  const params = new URLSearchParams({ weeks_ahead: weeksAhead.toString() });
  if (predictionDate) params.append("prediction_date", predictionDate);
  return api.get<CashFlowPrediction>(`/api/v1/predictions/cash-flow?${params.toString()}`);
};

export const getCashFlowGaps = (weeksAhead: number = 4) => {
  return api.get<CashFlowGap>(`/api/v1/predictions/cash-flow-gaps?weeks_ahead=${weeksAhead}`);
};

// ==================== ACCOUNTS RECEIVABLE API ====================

export interface Invoice {
  id: number;
  counterparty_id: number;
  counterparty_name: string;
  invoice_number: string;
  invoice_date: string;
  due_date: string;
  amount: number;
  paid_amount: number;
  currency: string;
  status: string;
  description?: string;
  days_overdue?: number;
}

export interface InvoicesResponse {
  success: boolean;
  invoices?: Invoice[];
  error?: string;
}

export interface ARSummary {
  success: boolean;
  summary?: {
    total_ar: number;
    overdue_ar: number;
    pending_count: number;
    overdue_count: number;
    paid_count: number;
  };
  error?: string;
}

export const getInvoices = (status?: string, counterpartyId?: number) => {
  const params = new URLSearchParams();
  if (status) params.append("status", status);
  if (counterpartyId) params.append("counterparty_id", counterpartyId.toString());
  return api.get<InvoicesResponse>(`/api/v1/ar/invoices?${params.toString()}`);
};

export const getOverdueInvoices = () => {
  return api.get<InvoicesResponse>("/api/v1/ar/overdue");
};

export const getARSummary = () => {
  return api.get<ARSummary>("/api/v1/ar/summary");
};

// ==================== OAUTH API ====================

export const initiateBankOAuth = (bankCode: string) => {
  // This will redirect to backend, which redirects to bank
  window.location.href = `${API_URL}/auth/oauth/authorize/${bankCode}`;
};
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#   Usually these files are written by a python script from a template
#   before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Application runtime files
app.log
app.pid
*.pid

# Codebase dumps (Repomix, etc.)
backend.xml
backend.txt
frontend.txt
*_dump.txt

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
# Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
# uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
# poetry.lock
# poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
# pdm.lock
# pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
# pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# Redis
*.rdb
*.aof
*.pid

# RabbitMQ
mnesia/
rabbitmq/
rabbitmq-data/

# ActiveMQ
activemq-data/

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#   JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#   be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#   and can be added to the global gitignore or merged into this file.  For a more nuclear
#   option (not recommended) you can uncomment the following to ignore the entire idea folder.
# .idea/

# Abstra
#   Abstra is an AI-powered process automation framework.
#   Ignore directories containing user credentials, local state, and settings.
#   Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#   Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#   that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#   and can be added to the global gitignore or merged into this file. However, if you prefer, 
#   you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Streamlit
.streamlit/secrets.toml

# Docker
docker-compose.override.yml

# Frontend (Node.js / React)
frontend/node_modules/
frontend/dist/
frontend/build/
frontend/.vite/
frontend/.env
frontend/.env.local
frontend/.env.production
frontend/.DS_Store
frontend/*.log

# OS
.DS_Store
Thumbs.db
</file>

<file path="Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Установка зависимостей
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Копирование requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование приложения
COPY . .

# Запуск приложения
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="env.example">
# ====================================================================
# FastAPI Authentication & Authorization System
# Пример конфигурационного файла
# ====================================================================

# -------- DATABASE --------
# PostgreSQL асинхронное подключение
# Формат: postgresql+asyncpg://user:password@host:port/database
DATABASE_URL=postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5434/fastapi_db

# Redis для кэширования и сессий
REDIS_URL=redis://localhost:6381/0

# -------- JWT SETTINGS --------
# Секретный ключ для подписи JWT токенов
# Минимум 32 символа, используйте: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-super-secret-key-minimum-32-characters-long-generate-it-securely

# Алгоритм подписи JWT
ALGORITHM=HS256

# Время жизни access токена в минутах
ACCESS_TOKEN_EXPIRE_MINUTES=15

# Время жизни refresh токена в днях
REFRESH_TOKEN_EXPIRE_DAYS=7

# -------- SMS SERVICE --------
# Выбор провайдера SMS
# Опции: sms_ru, twilio, aws_sns, sendpulse
SMS_SERVICE_PROVIDER=sms_ru

# API ключ для SMS сервиса
# Получите на https://sms.ru или у выбранного провайдера
SMS_API_KEY=your_sms_api_key_here

# Имя отправителя для SMS (максимум 11 символов)
SMS_FROM_NAME=YourApp

# Максимальное количество попыток ввода SMS кода
SMS_MAX_ATTEMPTS=3

# Время действия SMS кода в минутах
SMS_CODE_EXPIRY_MINUTES=10

# -------- OAUTH2 / OPENID CONNECT --------
# URL банковского API (согласно ФАПИ Банка России)
BANK_API_URL=https://vbank.open.bankingapi.ru

# Client ID от банка для OAuth2
BANK_CLIENT_ID=your_bank_client_id_here

# Client Secret от банка для OAuth2
BANK_CLIENT_SECRET=your_bank_client_secret_here

# Redirect URI для OAuth2 callback
# Должен совпадать с зарегистрированным в банке
BANK_REDIRECT_URI=http://localhost:8000/auth/oauth/callback

# Scope для доступа к банковским данным
# Опции: openid, profile, accounts, transactions, payments
BANK_SCOPES=openid profile accounts

# -------- BANK API CONFIGURATION --------
# Конфигурация для трёх банков: Virtual Bank, Awesome Bank, Smart Bank
# Эти значения используются для получения bank-token и работы с API

# Virtual Bank (vbank)
VBANK_API_URL=https://vbank.open.bankingapi.ru
VBANK_CLIENT_ID=team261-1
VBANK_CLIENT_SECRET=your_vbank_client_secret_here
VBANK_REQUESTING_BANK=team261
VBANK_REQUESTING_BANK_NAME=Team 261 Virtual Bank App
VBANK_REDIRECTING_URL=https://vbank.open.bankingapi.ru/client/

# Awesome Bank (abank)
ABANK_API_URL=https://abank.open.bankingapi.ru
ABANK_CLIENT_ID=team261-1
ABANK_CLIENT_SECRET=your_abank_client_secret_here
ABANK_REQUESTING_BANK=team261
ABANK_REQUESTING_BANK_NAME=Team 261 Awesome Bank App
ABANK_REDIRECTING_URL=https://abank.open.bankingapi.ru/client/

# Smart Bank (sbank)
SBANK_API_URL=https://sbank.open.bankingapi.ru
SBANK_CLIENT_ID=team261-1
SBANK_CLIENT_SECRET=your_sbank_client_secret_here
SBANK_REQUESTING_BANK=team261
SBANK_REQUESTING_BANK_NAME=Team 261 Smart Bank App
SBANK_REDIRECTING_URL=https://sbank.open.bankingapi.ru/client/

# -------- EMAIL SETTINGS --------
# SMTP сервер для отправки email
SMTP_SERVER=smtp.gmail.com

# Порт SMTP
SMTP_PORT=587

# Email адрес отправителя
SMTP_USER=your_email@gmail.com

# Пароль приложения Gmail (не основной пароль!)
# Используйте: https://myaccount.google.com/apppasswords
SMTP_PASSWORD=your_app_password_here

# Email для отправки писем с подтверждением
FROM_EMAIL=noreply@yourapp.com

# -------- APPLICATION SETTINGS --------
# Frontend URL для перенаправлений
FRONTEND_URL=http://localhost:3000

# Окружение приложения (development, staging, production)
ENVIRONMENT=development

# Режим отладки (включает более подробные логи)
DEBUG=True

# -------- SECURITY --------
# Требовать HTTPS в production
REQUIRE_HTTPS=False  # Установите True в production

# CORS разрешенные домены (comma-separated)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000

# -------- LOGGING --------
# Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Директория для логов
LOG_DIR=./logs

# -------- RATE LIMITING --------
# Включить rate limiting
RATE_LIMITING_ENABLED=True

# Максимум запросов в минуту для анонимных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Максимум запросов в минуту для авторизованных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE_AUTHENTICATED=100

# -------- MONITORING --------
# Включить Prometheus метрики
PROMETHEUS_ENABLED=False

# -------- OPTIONAL SETTINGS --------
# Максимальный размер запроса в MB
MAX_REQUEST_SIZE=10

# Таймаут для подключения к внешним сервисам (секунды)
EXTERNAL_SERVICE_TIMEOUT=30

# Количество рабочих процессов Uvicorn
WORKERS=4

# ====================================================================
# ИНСТРУКЦИИ ПО ПОЛУЧЕНИЮ ЗНАЧЕНИЙ
# ====================================================================

# 1. SECRET_KEY:
#    python -c "import secrets; print(secrets.token_urlsafe(32))"

# 2. SMS_API_KEY (sms.ru):
#    - Перейти на https://sms.ru
#    - Зарегистрироваться
#    - Получить API ID в личном кабинете
#    - Добавить номер в доверенные

# 3. BANK_CLIENT_ID и BANK_CLIENT_SECRET:
#    - Обратиться к банку (Сбербанк, ВТБ, и т.д.)
#    - Получить учетные данные OAuth2
#    - Согласовать redirect_uri

# 4. SMTP_PASSWORD (Gmail):
#    - Перейти на https://myaccount.google.com/apppasswords
#    - Выбрать приложение "Mail" и устройство "Windows/Mac/Linux"
#    - Скопировать сгенерированный пароль

# 5. BANK_REDIRECT_URI:
#    - В development: http://localhost:8000/auth/oauth/callback
#    - В production: https://yourdomain.com/auth/oauth/callback

# ====================================================================
# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
# ====================================================================

# Для разработки используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/fastapi_dev
# DEBUG=True
# ENVIRONMENT=development

# Для staging используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@staging-db:5432/fastapi_staging
# DEBUG=False
# ENVIRONMENT=staging
# REQUIRE_HTTPS=True

# Для production используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@prod-db:5432/fastapi_prod
# DEBUG=False
# ENVIRONMENT=production
# REQUIRE_HTTPS=True
# RATE_LIMITING_ENABLED=True
# PROMETHEUS_ENABLED=True

# ====================================================================
# БЕЗОПАСНОСТЬ
# ====================================================================

# ⚠️ НИКОГДА не коммитьте этот файл в git, если в нем реальные значения!
# Используйте: git update-index --assume-unchanged .env

# ✅ Рекомендуемые настройки для .gitignore:
# .env
# .env.local
# .env.*.local
# .env.production

# ✅ Для разработки скопируйте этот файл:
# cp .env.example .env

# ✅ Для production используйте переменные окружения системы:
# export SECRET_KEY=your-secret-key
# export DATABASE_URL=postgresql+asyncpg://...

# ====================================================================
</file>

<file path="README.md">
# Multi-Banking MVP for Solo Entrepreneurs

MVP приложения для агрегации банковских счетов индивидуальных предпринимателей (ИП) с финансовой аналитикой, ML-прогнозированием денежных потоков и автоматизацией управления дебиторской задолженностью.

## 🎯 Основные возможности

- **Агрегация банковских счетов** - подключение счетов из нескольких банков через Open Banking API
- **Финансовая аналитика** - расчет метрик финансового здоровья бизнеса
- **ML-прогнозирование** - предсказание кассовых разрывов на несколько недель вперед
- **Управление дебиторской задолженностью** - автоматизация учета и напоминаний по счетам к получению
- **Управление контрагентами** - база клиентов и поставщиков с автоматическим сопоставлением транзакций

## 🏗️ Архитектура

### Технологический стек

- **Backend**: FastAPI (Python 3.9+)
- **Database**: PostgreSQL (async SQLAlchemy)
- **Cache/Task Queue**: Redis + Celery
- **ML**: NumPy для статистических прогнозов
- **Banking APIs**: Open Banking API (vbank, abank, sbank)

### Структура проекта

```
dovdx/
├── app/
│   ├── models.py              # SQLAlchemy модели данных
│   ├── database.py            # Настройка БД
│   ├── config.py              # Конфигурация приложения
│   ├── auth_router.py          # Аутентификация
│   ├── users_router.py         # Управление пользователями
│   ├── bank_api_router.py      # Интеграция с банками
│   ├── analytics_router.py      # Финансовая аналитика
│   ├── predictions_router.py   # ML-прогнозы
│   ├── ar_router.py            # Дебиторская задолженность
│   ├── counterparty_router.py  # Контрагенты
│   ├── sync_router.py           # Синхронизация данных
│   ├── services/
│   │   ├── data_aggregation_service.py    # Агрегация данных из банков
│   │   ├── financial_analytics_service.py # Расчет метрик
│   │   ├── ml_prediction_service.py       # ML-прогнозы
│   │   ├── ar_management_service.py       # Управление ДЗ
│   │   ├── counterparty_service.py        # Управление контрагентами
│   │   └── universal_bank_service.py      # Универсальный банковский сервис
│   ├── security/               # JWT, OAuth2, пароли
│   ├── tasks/                  # Celery задачи
│   └── utils/                  # Утилиты
├── main.py                     # Точка входа приложения
├── requirements.txt            # Зависимости
├── docker-compose.yml          # Docker Compose конфигурация
└── README.md                   # Документация
```

## 📊 Модели данных

### Основные сущности

1. **BankAccount** - Банковские счета пользователя
2. **BankTransaction** - Транзакции по счетам
3. **BankConsent** - Согласия на доступ к банковским данным
4. **Counterparty** - Контрагенты (клиенты и поставщики)
5. **AccountsReceivable** - Дебиторская задолженность (счета к получению)
6. **CashFlowPrediction** - Прогнозы денежных потоков
7. **FinancialHealthMetrics** - Метрики финансового здоровья

## 🚀 Быстрый старт

### Требования

- Python 3.9+
- PostgreSQL 15+
- Redis 7+
- Docker & Docker Compose (опционально)
- Node.js 20+ (для фронтенда)

### Установка

1. Клонируйте репозиторий
2. Создайте виртуальное окружение:
```bash
python -m venv venv
source venv/bin/activate  # Linux/Mac
# или
venv\Scripts\activate  # Windows
```

3. Установите зависимости:
```bash
pip install -r requirements.txt
```

4. Настройте переменные окружения (создайте `.env` на основе `env.example`):
```bash
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/dbname
REDIS_URL=redis://localhost:6379/0
SECRET_KEY=your-secret-key
```

5. Запустите БД и Redis через Docker Compose:
```bash
docker-compose up -d postgres redis
```

6. Запустите приложение:

**Вариант 1: Использование Docker (рекомендуется)**
```bash
# Запустить все сервисы через Docker
./docker.sh start

# Остановить все сервисы
./stop.sh
```

**Вариант 2: Ручной запуск**
```bash
# Запустить PostgreSQL и Redis
docker-compose up -d postgres redis

# Запустить FastAPI приложение
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

**Вариант 3: Полный запуск через Docker Compose (Backend + Database + Redis)**
```bash
docker-compose up
```

**Вариант 4: Запуск Backend и Frontend в Docker (Рекомендуется)**
```bash
# Для разработки (с hot-reload)
./docker.sh start

# Для продакшена
./docker.sh start prod

# Остановка всех сервисов
./stop.sh
```

Приложение будет доступно по адресу:
- Backend API: http://localhost:8000
- API документация: http://localhost:8000/docs
- Frontend (dev): http://localhost:5173
- Frontend (prod): http://localhost:3000

### Docker Deployment

Проект настроен для запуска в Docker контейнерах. Подробная документация по Docker deployment доступна в [DOCKER_STRUCTURE.md](DOCKER_STRUCTURE.md).

**Быстрый старт с Docker:**

1. Убедитесь, что Docker и Docker Compose установлены
2. Создайте `.env` файл из `env.example`
3. Запустите development окружение:
```bash
./docker.sh start
```

**Управление Docker контейнерами:**

```bash
# Запуск сервисов
./docker.sh start          # Development
./docker.sh start prod     # Production

# Остановка всех сервисов
./stop.sh

# Просмотр логов
./docker.sh logs [service_name]

# Пересборка сервисов
./docker.sh rebuild [service_name]

# Статус сервисов
./docker.sh status

# Удаление volumes (база данных)
./docker.sh clean
```

**Архитектура контейнеров:**
- `frontend` - React приложение (Vite dev server в development, Nginx в production)
- `app` - FastAPI backend
- `celery` - Background task worker
- `postgres` - База данных
- `redis` - Cache и message broker

### Запуск фоновых задач (Celery)

Для периодической синхронизации данных и обновления метрик:

```bash
# Запустить Celery worker и beat scheduler
./start_celery.sh

# Остановить Celery workers
./stop_celery.sh
```

Или вручную:

```bash
# Terminal 1: Celery worker
celery -A app.tasks.sync_tasks.celery_app worker --loglevel=info

# Terminal 2: Celery beat (периодические задачи)
celery -A app.tasks.sync_tasks.celery_app beat --loglevel=info
```

### Остановка сервисов

**Остановка контейнеров (без удаления):**
```bash
./stop.sh
```

**Полная остановка и удаление контейнеров:**
```bash
./stop_all.sh
```

**Остановка Celery:**
```bash
./stop_celery.sh
```

**Остановка приложения:**
Нажмите `Ctrl+C` в терминале где запущен `uvicorn`

## 📡 API Endpoints

### Аутентификация
- `POST /api/v1/auth/register` - Регистрация пользователя
- `POST /api/v1/auth/login` - Вход в систему
- `POST /api/v1/auth/refresh` - Обновление токена

### Банковские данные
- `GET /api/v1/banks/accounts` - Получить счета из банка
- `GET /api/v1/banks/accounts/all` - Получить счета из всех банков
- `GET /api/v1/banks/accounts/{account_id}/transactions` - Транзакции по счету

### Синхронизация данных
- `POST /api/v1/sync/accounts` - Синхронизировать счета
- `POST /api/v1/sync/transactions` - Синхронизировать транзакции
- `POST /api/v1/sync/all` - Полная синхронизация

### Финансовая аналитика
- `GET /api/v1/analytics/health-metrics` - Метрики финансового здоровья
- `GET /api/v1/analytics/dashboard` - Сводка для дашборда

### ML-прогнозы
- `GET /api/v1/predictions/cash-flow` - Прогноз денежных потоков
- `GET /api/v1/predictions/cash-flow-gaps` - Прогноз кассовых разрывов

### Дебиторская задолженность
- `POST /api/v1/ar/invoices` - Создать счет к получению
- `GET /api/v1/ar/invoices` - Список счетов
- `POST /api/v1/ar/invoices/{id}/mark-paid` - Отметить счет как оплаченный
- `GET /api/v1/ar/overdue` - Просроченные счета
- `GET /api/v1/ar/summary` - Сводка по ДЗ
- `POST /api/v1/ar/auto-match` - Автоматическое сопоставление платежей

### Контрагенты
- `POST /api/v1/counterparties` - Создать контрагента
- `GET /api/v1/counterparties` - Список контрагентов
- `GET /api/v1/counterparties/{id}` - Детали контрагента
- `PUT /api/v1/counterparties/{id}` - Обновить контрагента
- `POST /api/v1/counterparties/from-transaction/{tx_id}` - Создать из транзакции

## 🔧 Конфигурация банков

Приложение поддерживает подключение к трем банкам через Open Banking API:
- **vbank** - Virtual Bank
- **abank** - Awesome Bank
- **sbank** - Smart Bank

Настройки банков находятся в `app/config.py` и могут быть переопределены через переменные окружения.

## 🤖 ML-прогнозирование

Сервис прогнозирования использует статистические модели для предсказания денежных потоков:
- **Moving Average** для базового прогноза
- **Trend Analysis** для учета трендов
- **Expected Inflows** из дебиторской задолженности
- **Gap Probability** для оценки риска кассовых разрывов

Прогнозы генерируются на 1-12 недель вперед с указанием вероятности и размера потенциальных разрывов.

## 📈 Финансовые метрики

Система рассчитывает следующие метрики:
- **Доходы и расходы** за период
- **Коэффициенты ликвидности** (current ratio, quick ratio)
- **Оборачиваемость дебиторской задолженности**
- **Тренд денежного потока** (increasing/decreasing/stable)
- **Health Score** (0-100) - общий показатель финансового здоровья

## 🔄 Автоматизация

### Периодические задачи (Celery)

- **Синхронизация данных** - каждый час
- **Обновление метрик** - каждый час
- **Проверка просроченных счетов** - раз в день

Для запуска Celery worker:
```bash
celery -A app.tasks.sync_tasks.celery_app worker --loglevel=info
```

Для запуска Celery beat (периодические задачи):
```bash
celery -A app.tasks.sync_tasks.celery_app beat --loglevel=info
```

## 🧪 Тестирование

API документация доступна по адресу: http://localhost:8000/docs

Примеры запросов можно найти в Swagger UI.

## 📝 Лицензия

Проект создан для VTB API Hackathon.

## 🤝 Вклад

Проект находится в стадии MVP. Предложения по улучшению приветствуются!
</file>

<file path="app/security/password.py">
from passlib.context import CryptContext
from passlib.exc import InvalidHashError

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except (InvalidHashError, ValueError):
        return False
</file>

<file path="app/services/oauth_service.py">
import secrets
import aiohttp
from datetime import datetime, timedelta
from urllib.parse import urlencode
from jose import jwt
from sqlalchemy.ext.asyncio import AsyncSession
from app.config import get_settings
from app.models import OAuthSession
from sqlalchemy import select

settings = get_settings()

class OAuth2Service:
    
    async def generate_oauth_state(self, provider: str, db: AsyncSession) -> dict:
        """Генерация состояния для OAuth flow"""
        state = secrets.token_urlsafe(32)
        code_verifier = secrets.token_urlsafe(32)
        
        oauth_session = OAuthSession(
            state=state,
            code_verifier=code_verifier,
            provider=provider,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(oauth_session)
        await db.commit()
        
        return {
            "state": state,
            "code_verifier": code_verifier
        }
    
    def generate_authorization_url(self, state: str, bank_config) -> str:
        """Генерация URL для перенаправления на банковский API"""
        
        params = {
            "response_type": "code",
            "client_id": bank_config.client_id,
            "redirect_uri": bank_config.redirecting_url,
            "scope": "openid profile accounts",
            "state": state,
            "nonce": secrets.token_urlsafe(16),
            "code_challenge_method": "S256",
        }
        
        return f"{bank_config.api_url}/oauth/authorize?{urlencode(params)}"
    
    async def exchange_code_for_token(self, code: str, code_verifier: str) -> dict:
        """Обмен кода на токен"""
        async with aiohttp.ClientSession() as session:
            data = {
                "grant_type": "authorization_code",
                "code": code,
                "client_id": settings.BANK_CLIENT_ID,
                "client_secret": settings.BANK_CLIENT_SECRET,
                "redirect_uri": settings.BANK_REDIRECT_URI,
                "code_verifier": code_verifier
            }
            
            async with session.post(
                f"{settings.BANK_API_URL}/oauth/token",
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def get_user_info(self, access_token: str) -> dict:
        """Получение информации о пользователе"""
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {access_token}"}
            async with session.get(
                f"{settings.BANK_API_URL}/oauth/userinfo",
                headers=headers
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def validate_oauth_state(self, state: str, db: AsyncSession) -> dict:
        """Валидация состояния OAuth"""
        result = await db.execute(
            select(OAuthSession).where(
                OAuthSession.state == state,
                OAuthSession.expires_at > datetime.utcnow()
            )
        )
        session = result.scalars().first()
        
        if not session:
            return None
        
        return {
            "state": session.state,
            "code_verifier": session.code_verifier,
            "provider": session.provider
        }

oauth_service = OAuth2Service()
</file>

<file path="app/services/universal_bank_service.py">
import aiohttp
import secrets
import logging
from datetime import datetime, timedelta
from typing import Optional, Dict, List, Any
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.config import get_settings, BankConfig
from app.models import OAuthSession, User, BankUser

settings = get_settings()
logger = logging.getLogger(__name__)


class UniversalBankAPIService:
    """
    Универсальный сервис для работы с Open Banking API трёх банков:
    - Virtual Bank (vbank.open.bankingapi.ru)
    - Awesome Bank (abank.open.bankingapi.ru)
    - Smart Bank (sbank.open.bankingapi.ru)
    
    Все методы принимают bank_code как параметр для выбора банка
    """
    
    def __init__(self):
        self.settings = get_settings()
    
    def _get_bank_config(self, bank_code: str) -> BankConfig:
        """Получить конфигурацию банка по коду"""
        return self.settings.get_bank_config(bank_code)
    
    # ==================== АУТЕНТИФИКАЦИЯ ====================
    
    async def get_bank_access_token(self, bank_code: str) -> Optional[str]:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://{bank}.open.bankingapi.ru/auth/bank-token
        ?client_id={client_id}&client_secret={client_secret}
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Returns:
            str: access_token или None при ошибке
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/auth/bank-token"
                params = {
                    "client_id": bank.client_id,
                    "client_secret": bank.client_secret
                }
                
                logger.info(f"[{bank_code}] Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info(f"[{bank_code}] Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting bank token: {e}")
            return None
    
    # ==================== СОГЛАСИЯ (CONSENTS) ====================
    
    async def request_account_consent(
        self, 
        bank_code: str,
        access_token: str, 
        user_id: str,
        permissions: Optional[List[str]] = None
    ) -> Optional[Dict]:
        """
        Запросить согласие на доступ к счетам пользователя
        
        POST https://{bank}.open.bankingapi.ru/account-consents/request
        
        Args:
            bank_code: Код банка
            access_token: Токен банка
            user_id: ID пользователя
            permissions: Список разрешений (по умолчанию ReadAccountsDetail, ReadBalances)
        
        Returns:
            dict: {"status": "approved", "consent_id": "...", "auto_approved": true}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            if permissions is None:
                permissions = ["ReadAccountsDetail", "ReadBalances", "ReadTransactionsDetail"]
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": permissions,
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": bank.requesting_bank,
                    "requesting_bank_name": bank.requesting_bank_name
                }
                
                logger.info(f"[{bank_code}] Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Consent received: status={data.get('status')}, consent_id={data.get('consent_id')}, request_id={data.get('request_id')}")
                        
                        # Обрабатываем разные форматы ответа
                        # Может быть: {"status": "approved", "consent_id": "..."}
                        # Или: {"data": {"status": "pending", "request_id": "..."}}
                        if isinstance(data, dict) and "data" in data:
                            consent_data = data["data"]
                            return {
                                "status": consent_data.get("status", "approved"),
                                "consent_id": consent_data.get("consent_id") or consent_data.get("request_id"),
                                "request_id": consent_data.get("request_id"),
                                "auto_approved": consent_data.get("auto_approved", True)
                            }
                        else:
                            return {
                                "status": data.get("status", "approved"),
                                "consent_id": data.get("consent_id") or data.get("request_id"),
                                "request_id": data.get("request_id"),
                                "auto_approved": data.get("auto_approved", True)
                            }
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to request consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error requesting consent: {e}")
            return None
    
    async def get_consent_details(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить детали согласия
        
        GET https://{bank}.open.bankingapi.ru/account-consents/{consent_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/{consent_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Getting consent details: {consent_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Consent details retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting consent details: {e}")
            return None
    
    async def delete_consent(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str
    ) -> bool:
        """
        Удалить согласие
        
        DELETE https://{bank}.open.bankingapi.ru/account-consents/{consent_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/{consent_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Deleting consent: {consent_id}")
                async with session.delete(url, headers=headers) as resp:
                    if resp.status in [200, 204]:
                        logger.info(f"[{bank_code}] Consent deleted successfully")
                        return True
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to delete consent: {resp.status} - {error_text}")
                        return False
        except Exception as e:
            logger.error(f"[{bank_code}] Error deleting consent: {e}")
            return False
    
    # ==================== СЧЕТА (ACCOUNTS) ====================
    
    async def get_accounts(
        self,
        bank_code: str,
        access_token: str,
        user_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить список счетов пользователя
        
        GET https://{bank}.open.bankingapi.ru/accounts?client_id={client_id}
        
        Args:
            bank_code: Код банка
            access_token: Токен банка
            user_id: ID пользователя
            consent_id: ID согласия
        
        Returns:
            dict: {"accounts": [...]}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"[{bank_code}] Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        
                        # Обрабатываем разные форматы ответа
                        accounts = []
                        if isinstance(data, dict):
                            # Стандартный формат: {"accounts": [...]}
                            if "accounts" in data:
                                accounts = data.get("accounts", [])
                            # Альтернативный формат: {"data": {"account": [...]}}
                            elif "data" in data and isinstance(data["data"], dict):
                                if "account" in data["data"]:
                                    accounts = data["data"]["account"] if isinstance(data["data"]["account"], list) else [data["data"]["account"]]
                                elif "accounts" in data["data"]:
                                    accounts = data["data"]["accounts"]
                            # Если accounts на верхнем уровне
                            elif "account" in data:
                                accounts = data["account"] if isinstance(data["account"], list) else [data["account"]]
                        elif isinstance(data, list):
                            # Если ответ - это список счетов напрямую
                            accounts = data
                        
                        # Фильтруем None значения и валидируем структуру
                        cleaned_accounts = []
                        for acc in accounts:
                            if acc is None:
                                continue
                            if not isinstance(acc, dict):
                                logger.warning(f"[{bank_code}] Skipping non-dict account: {type(acc)}")
                                continue
                            
                            # Извлекаем account_id из разных возможных мест
                            account_id = (
                                acc.get("account_id") or 
                                acc.get("id") or 
                                acc.get("accountId") or
                                (acc.get("account", {}) if isinstance(acc.get("account"), dict) else {}).get("identification") or
                                (acc.get("account", {}) if isinstance(acc.get("account"), dict) else {}).get("account_id")
                            )
                            
                            if not account_id:
                                logger.warning(f"[{bank_code}] Skipping account without account_id: {acc}")
                                continue
                            
                            # Удаляем None ключи и None значения из словаря
                            cleaned_acc = {}
                            for k, v in acc.items():
                                if k is not None:  # Пропускаем None ключи
                                    # Рекурсивно очищаем вложенные словари
                                    if isinstance(v, dict):
                                        cleaned_v = {nk: nv for nk, nv in v.items() if nk is not None and nv is not None}
                                        if cleaned_v:  # Только если есть валидные данные
                                            cleaned_acc[k] = cleaned_v
                                    elif isinstance(v, list):
                                        # Очищаем список от None значений
                                        cleaned_v = [item for item in v if item is not None]
                                        if cleaned_v:
                                            cleaned_acc[k] = cleaned_v
                                    elif v is not None:  # Пропускаем None значения
                                        cleaned_acc[k] = v
                            
                            # Убеждаемся, что account_id есть в cleaned_acc
                            if "account_id" not in cleaned_acc or not cleaned_acc.get("account_id"):
                                cleaned_acc["account_id"] = str(account_id)
                            
                            if cleaned_acc:  # Только если есть валидные данные
                                cleaned_accounts.append(cleaned_acc)
                        
                        logger.info(f"[{bank_code}] Successfully fetched {len(cleaned_accounts)} accounts (filtered from {len(accounts)})")
                        return {"accounts": cleaned_accounts}
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error fetching accounts: {e}", exc_info=True)
            return None
    
    async def get_account_details(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить детали конкретного счета
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                }
                
                # Добавляем X-Consent-Id только если он не None
                if consent_id:
                    headers["X-Consent-Id"] = consent_id
                
                logger.info(f"[{bank_code}] Getting account details: {account_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Account details retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get account details: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting account details: {e}")
            return None
    
    # ==================== БАЛАНСЫ (BALANCES) ====================
    
    async def get_account_balances(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить балансы счета
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}/balances
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}/balances"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                }
                
                # Добавляем X-Consent-Id только если он не None
                if consent_id:
                    headers["X-Consent-Id"] = consent_id
                
                logger.info(f"[{bank_code}] Getting balances for account: {account_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Balances retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get balances: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting balances: {e}")
            return None
    
    # ==================== ТРАНЗАКЦИИ (TRANSACTIONS) ====================
    
    async def get_account_transactions(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str,
        from_booking_date_time: Optional[str] = None,
        to_booking_date_time: Optional[str] = None,
        page: Optional[int] = None,
        limit: Optional[int] = None
    ) -> Optional[Dict]:
        """
        Получить транзакции по счету
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}/transactions
        
        Согласно OpenAPI спецификации:
        - from_booking_date_time: Дата начала в формате ISO 8601 (например: "2025-01-01T00:00:00Z")
        - to_booking_date_time: Дата конца в формате ISO 8601 (например: "2025-12-31T23:59:59Z")
        - page: Номер страницы (по умолчанию: 1)
        - limit: Количество транзакций на странице (по умолчанию: 50, макс: 500)
        
        Args:
            from_booking_date_time: Дата начала в формате ISO 8601 или YYYY-MM-DD (будет преобразована)
            to_booking_date_time: Дата конца в формате ISO 8601 или YYYY-MM-DD (будет преобразована)
            page: Номер страницы
            limit: Количество транзакций на странице (макс: 500)
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}/transactions"
                
                params = {}
                
                # Преобразуем даты в формат ISO 8601 если нужно
                if from_booking_date_time:
                    # Если дата в формате YYYY-MM-DD, добавляем время
                    if len(from_booking_date_time) == 10:
                        from_booking_date_time = f"{from_booking_date_time}T00:00:00Z"
                    params["from_booking_date_time"] = from_booking_date_time
                
                if to_booking_date_time:
                    # Если дата в формате YYYY-MM-DD, добавляем время
                    if len(to_booking_date_time) == 10:
                        to_booking_date_time = f"{to_booking_date_time}T23:59:59Z"
                    params["to_booking_date_time"] = to_booking_date_time
                
                if page is not None:
                    params["page"] = page
                
                if limit is not None:
                    # Ограничиваем максимум 500 согласно OpenAPI
                    limit = min(limit, 500)
                    params["limit"] = limit
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                }
                
                # Добавляем X-Consent-Id только если он не None
                if consent_id:
                    headers["X-Consent-Id"] = consent_id
                
                logger.info(f"[{bank_code}] Getting transactions for account: {account_id}, params: {params}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Transactions retrieved")
                        
                        # Обрабатываем разные форматы ответа (как с балансами)
                        # Может быть: {"transactions": [...]} или {"data": {"transaction": [...]}}
                        if isinstance(data, dict):
                            # Стандартный формат: {"transactions": [...]}
                            if "transactions" in data:
                                return data
                            # Альтернативный формат: {"data": {"transaction": [...]}}
                            elif "data" in data and isinstance(data["data"], dict):
                                if "transaction" in data["data"]:
                                    transactions = data["data"]["transaction"]
                                    if not isinstance(transactions, list):
                                        transactions = [transactions]
                                    return {"transactions": transactions}
                                elif "transactions" in data["data"]:
                                    return {"transactions": data["data"]["transactions"]}
                            # Если transactions на верхнем уровне
                            elif "transaction" in data:
                                transactions = data["transaction"]
                                if not isinstance(transactions, list):
                                    transactions = [transactions]
                                return {"transactions": transactions}
                        
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get transactions: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting transactions: {e}")
            return None
    
    # ==================== ПЛАТЕЖИ (PAYMENTS) ====================
    
    async def create_payment_consent(
        self,
        bank_code: str,
        access_token: str,
        user_id: str,
        payment_data: Dict
    ) -> Optional[Dict]:
        """
        Создать согласие на платеж
        
        POST https://{bank}.open.bankingapi.ru/payment-consents
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payment-consents"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{bank.requesting_bank}-{user_id}",
                    **payment_data
                }
                
                logger.info(f"[{bank_code}] Creating payment consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment consent created: {data.get('consentId')}")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to create payment consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error creating payment consent: {e}")
            return None
    
    async def initiate_payment(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str,
        payment_data: Dict
    ) -> Optional[Dict]:
        """
        Инициировать платеж
        
        POST https://{bank}.open.bankingapi.ru/payments
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payments"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Content-Type": "application/json"
                }
                
                logger.info(f"[{bank_code}] Initiating payment with consent {consent_id}")
                async with session.post(url, json=payment_data, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment initiated: {data.get('paymentId')}")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to initiate payment: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error initiating payment: {e}")
            return None
    
    async def get_payment_status(
        self,
        bank_code: str,
        access_token: str,
        payment_id: str
    ) -> Optional[Dict]:
        """
        Получить статус платежа
        
        GET https://{bank}.open.bankingapi.ru/payments/{payment_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payments/{payment_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Getting payment status: {payment_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment status retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get payment status: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting payment status: {e}")
            return None
    
    # ==================== КОМПЛЕКСНЫЕ МЕТОДЫ ====================
    
    async def get_bank_user_id(
        self,
        db: AsyncSession,
        user_id: int,
        bank_code: str
    ) -> Optional[str]:
        """
        Получить bank_user_id для пользователя и банка из базы данных
        
        Args:
            db: Database session
            user_id: Internal user ID
            bank_code: Bank code (vbank, abank, sbank)
        
        Returns:
            bank_user_id или None если не найден
        """
        try:
            result = await db.execute(
                select(BankUser).where(
                    BankUser.user_id == user_id,
                    BankUser.bank_code == bank_code
                )
            )
            bank_user = result.scalars().first()
            if bank_user:
                logger.info(f"[{bank_code}] Found bank_user_id: {bank_user.bank_user_id} for user {user_id}")
                return bank_user.bank_user_id
            else:
                logger.warning(f"[{bank_code}] No bank_user_id found for user {user_id}")
                return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting bank_user_id: {e}")
            return None
    
    async def get_all_accounts_full_cycle(
        self,
        bank_code: str,
        user_id: str,
        db: Optional[AsyncSession] = None,
        internal_user_id: Optional[int] = None
    ) -> Dict:
        """
        Выполнить полный цикл получения счетов для одного банка:
        1. Получить access token банка
        2. Получить bank_user_id из базы данных
        3. Запросить согласие
        4. Получить счета
        
        Args:
            bank_code: Bank code
            user_id: Bank user ID (если не указан, будет получен из БД)
            db: Database session (опционально, нужен для получения bank_user_id)
            internal_user_id: Internal user ID (нужен для получения bank_user_id из БД)
        
        Returns:
            dict: {"success": True/False, "accounts": [...], "consent_id": "...", "error": "..."}
        """
        try:
            logger.info(f"[{bank_code}] STARTING FULL CYCLE for user {user_id}")
            
            # Получаем bank_user_id из БД - ОБЯЗАТЕЛЬНО требуется!
            bank_user_id = None
            if db and internal_user_id:
                db_bank_user_id = await self.get_bank_user_id(db, internal_user_id, bank_code)
                if db_bank_user_id:
                    bank_user_id = db_bank_user_id
                    logger.info(f"[{bank_code}] Using bank_user_id from DB: {bank_user_id}")
                else:
                    logger.error(f"[{bank_code}] No bank_user_id found in DB for user {internal_user_id}")
                    return {
                        "success": False,
                        "error": f"No bank_user_id found for {bank_code}. Please set bank_user_id in your profile first."
                    }
            else:
                # Если нет db или internal_user_id, проверяем, что user_id выглядит как полный client_id
                # (должен содержать дефис или быть в формате teamXXX-X)
                if not ("-" in str(user_id) or user_id.startswith("team")):
                    logger.error(f"[{bank_code}] Invalid user_id format: {user_id}. Expected full client_id (e.g., team261-1)")
                    return {
                        "success": False,
                        "error": f"Invalid user_id format. Please set bank_user_id in your profile for {bank_code}."
                    }
                bank_user_id = user_id
                logger.info(f"[{bank_code}] Using provided bank_user_id: {bank_user_id}")
            
            if not bank_user_id:
                return {
                    "success": False,
                    "error": f"bank_user_id is required for {bank_code}. Please set it in your profile."
                }
            
            # ШАГ 1: Получить токен банка
            logger.info(f"[{bank_code}] STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token(bank_code)
            
            if not access_token:
                return {
                    "success": False,
                    "error": f"Failed to obtain bank access token from {bank_code}"
                }
            
            # ШАГ 2: Запросить согласие
            logger.info(f"[{bank_code}] STEP 2: Requesting account consent for bank_user_id {bank_user_id}...")
            consent_data = await self.request_account_consent(bank_code, access_token, bank_user_id)
            
            if not consent_data:
                return {
                    "success": False,
                    "error": f"Failed to request account consent from {bank_code}"
                }
            
            consent_id = consent_data.get("consent_id")
            
            # ШАГ 3: Получить счета
            logger.info(f"[{bank_code}] STEP 3: Fetching user accounts for bank_user_id {bank_user_id}...")
            accounts_data = await self.get_accounts(bank_code, access_token, bank_user_id, consent_id)
            
            if not accounts_data:
                return {
                    "success": False,
                    "error": f"Failed to fetch accounts from {bank_code}"
                }
            
            logger.info(f"[{bank_code}] FULL CYCLE COMPLETED SUCCESSFULLY")
            return {
                "success": True,
                "bank_code": bank_code,
                "accounts": accounts_data.get("accounts", []),
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True)
            }
        
        except Exception as e:
            logger.error(f"[{bank_code}] Error in full cycle: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_accounts_from_all_banks(
        self,
        user_id: str,
        bank_codes: Optional[List[str]] = None,
        db: Optional[AsyncSession] = None,
        internal_user_id: Optional[int] = None
    ) -> Dict[str, Dict]:
        """
        Получить счета из всех банков (или выбранных)
        
        Args:
            user_id: ID пользователя (fallback если нет в БД)
            bank_codes: Список кодов банков (если None - все банки)
            db: Database session (опционально)
            internal_user_id: Internal user ID (для получения bank_user_id из БД)
        
        Returns:
            dict: {
              "vbank": {"success": True, "accounts": [...]},
              "abank": {"success": True, "accounts": [...]},
              "sbank": {"success": False, "error": "..."}
            }
        """
        if bank_codes is None:
            bank_codes = ["vbank", "abank", "sbank"]
        
        results = {}
        
        for bank_code in bank_codes:
            logger.info(f"Processing bank: {bank_code}")
            result = await self.get_all_accounts_full_cycle(
                bank_code=bank_code,
                user_id=user_id,
                db=db,
                internal_user_id=internal_user_id
            )
            results[bank_code] = result
        
        return results


# Глобальный экземпляр сервиса
universal_bank_service = UniversalBankAPIService()
</file>

<file path="app/bank_api_router.py">
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, List
from datetime import datetime
import logging

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.universal_bank_service import universal_bank_service
from app.bank_schemas import (
    GetBankAccountsResponse,
    BankAccountSchema,
    BankTransactionSchema,
    BankBalanceSchema,
    GetBankTransactionsResponse,
    GetBankBalanceHistoryResponse
)

router = APIRouter(prefix="/api/v1/banks", tags=["Open Banking API"])
logger = logging.getLogger(__name__)

# ==================== ПОЛУЧЕНИЕ СЧЕТОВ ====================

@router.get("/accounts", response_model=GetBankAccountsResponse)
async def get_user_accounts(
    bank_code: str = Query(..., description="Код банка: vbank, abank, sbank"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить список счетов пользователя из конкретного банка
    
    **Параметры:**
    - **bank_code**: Код банка ('vbank', 'abank', 'sbank')
    
    **Возвращает:**
    - Список счетов с балансами
    
    **Примечание:**
    - Использует bank_user_id из профиля пользователя, если он установлен
    - Если bank_user_id не установлен, вернет ошибку с инструкцией
    """
    try:
        logger.info(f"User {user_id} requesting accounts from {bank_code}")
        
        result = await universal_bank_service.get_all_accounts_full_cycle(
            bank_code=bank_code,
            user_id=str(user_id),  # Fallback если нет в БД
            db=db,
            internal_user_id=user_id
        )
        
        if not result.get("success"):
            error_msg = result.get("error", "Failed to fetch accounts")
            # Проверяем, не связана ли ошибка с отсутствием bank_user_id
            if "No bank_user_id" in error_msg or "bank_user_id" in error_msg.lower():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"{error_msg}. Please set bank_user_id in your profile first."
                )
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=error_msg
            )
        
        # Фильтруем и валидируем счета перед сериализацией
        valid_accounts = []
        accounts_list = result.get("accounts", [])
        
        for acc in accounts_list:
            # Пропускаем счета без account_id или с None в качестве ключей
            if not isinstance(acc, dict):
                logger.warning(f"[{bank_code}] Skipping invalid account format: {type(acc)}")
                continue
            
            # Проверяем наличие account_id из разных возможных мест
            account_id = (
                acc.get("account_id") or 
                acc.get("id") or 
                acc.get("accountId") or
                (acc.get("account", {}) if isinstance(acc.get("account"), dict) else {}).get("identification") or
                (acc.get("account", {}) if isinstance(acc.get("account"), dict) else {}).get("account_id")
            )
            
            if not account_id:
                logger.warning(f"[{bank_code}] Skipping account without account_id: {acc}")
                continue
            
            # Удаляем None ключи и None значения из словаря (рекурсивно)
            cleaned_acc = {}
            for k, v in acc.items():
                if k is not None:  # Пропускаем None ключи
                    # Рекурсивно очищаем вложенные словари
                    if isinstance(v, dict):
                        cleaned_v = {nk: nv for nk, nv in v.items() if nk is not None and nv is not None}
                        if cleaned_v:  # Только если есть валидные данные
                            cleaned_acc[k] = cleaned_v
                    elif isinstance(v, list):
                        # Очищаем список от None значений
                        cleaned_v = [item for item in v if item is not None]
                        if cleaned_v:
                            cleaned_acc[k] = cleaned_v
                    elif v is not None:  # Пропускаем None значения
                        cleaned_acc[k] = v
            
            # Убеждаемся, что account_id есть в cleaned_acc и это строка
            if "account_id" not in cleaned_acc or not cleaned_acc.get("account_id"):
                cleaned_acc["account_id"] = str(account_id)
            
            try:
                valid_accounts.append(BankAccountSchema(**cleaned_acc))
            except Exception as e:
                logger.warning(f"[{bank_code}] Skipping account due to validation error: {e}, account: {cleaned_acc}")
                continue
        
        return GetBankAccountsResponse(
            success=True,
            accounts=valid_accounts,
            consent_id=result.get("consent_id"),
            auto_approved=result.get("auto_approved")
        )
    
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error getting accounts: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.get("/accounts/all")
async def get_accounts_from_all_banks(
    user_id: int = Depends(get_current_user),
    banks: Optional[List[str]] = Query(None, description="Список банков (vbank,abank,sbank)"),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить счета из всех банков или выбранных
    
    **Параметры:**
    - **banks**: Список кодов банков (если не указано - все банки)
    
    **Возвращает:**
    - Счета из каждого банка с флагами успешности
    
    **Примечание:**
    - Использует bank_user_id из профиля пользователя для каждого банка
    """
    try:
        logger.info(f"User {user_id} requesting accounts from multiple banks")
        
        results = await universal_bank_service.get_accounts_from_all_banks(
            user_id=str(user_id),  # Fallback если нет в БД
            bank_codes=banks,
            db=db,
            internal_user_id=user_id
        )
        
        # Форматируем ответ
        response = {
            "success": True,
            "banks": {}
        }
        
        total_accounts = 0
        for bank_code, bank_result in results.items():
            if bank_result.get("success"):
                accounts = bank_result.get("accounts", [])
                total_accounts += len(accounts)
                response["banks"][bank_code] = {
                    "success": True,
                    "accounts": accounts,
                    "consent_id": bank_result.get("consent_id"),
                    "count": len(accounts)
                }
            else:
                error_msg = bank_result.get("error", "Unknown error")
                response["banks"][bank_code] = {
                    "success": False,
                    "error": error_msg,
                    "count": 0
                }
        
        response["total_accounts"] = total_accounts
        return response
    
    except Exception as e:
        logger.error(f"Error getting accounts from all banks: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.get("/accounts/{account_id}")
async def get_account_details(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить детальную информацию о конкретном счете
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия
    """
    try:
        # Получаем токен банка
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        # Получаем детали счета
        account_data = await universal_bank_service.get_account_details(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id
        )
        
        if not account_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Account not found"
            )
        
        return {
            "success": True,
            "account": account_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting account details: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== БАЛАНСЫ ====================

@router.get("/accounts/{account_id}/balances")
async def get_account_balances(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: Optional[str] = Query(None, description="ID согласия (если не указано, будет получен из БД)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить балансы счета
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия (опционально, если не указано - будет получен из БД)
    """
    try:
        # Если consent_id не указан, получаем его из БД
        if not consent_id:
            from app.models import BankConsent
            from sqlalchemy import select, and_
            stmt = select(BankConsent).where(
                and_(
                    BankConsent.user_id == user_id,
                    BankConsent.bank_code == bank_code,
                    BankConsent.status == "approved"
                )
            ).order_by(BankConsent.created_at.desc())
            result = await db.execute(stmt)
            consent = result.scalar_one_or_none()
            
            if not consent:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"No active consent found for {bank_code}. Please sync accounts first."
                )
            consent_id = consent.consent_id
            logger.info(f"Using consent_id from DB: {consent_id} for bank {bank_code}")
        
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        balances_data = await universal_bank_service.get_account_balances(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id
        )
        
        if not balances_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Balances not found"
            )
        
        return {
            "success": True,
            "balances": balances_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting balances: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== ТРАНЗАКЦИИ ====================

@router.get("/accounts/{account_id}/transactions", response_model=GetBankTransactionsResponse)
async def get_account_transactions(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: Optional[str] = Query(None, description="ID согласия (если не указано, будет получен из БД)"),
    from_booking_date_time: Optional[str] = Query(None, alias="from_date", description="Дата начала в формате ISO 8601 (например: 2025-01-01T00:00:00Z) или YYYY-MM-DD"),
    to_booking_date_time: Optional[str] = Query(None, alias="to_date", description="Дата конца в формате ISO 8601 (например: 2025-12-31T23:59:59Z) или YYYY-MM-DD"),
    page: Optional[int] = Query(None, ge=1, description="Номер страницы (по умолчанию: 1)"),
    limit: Optional[int] = Query(None, ge=1, le=500, description="Количество транзакций на странице (по умолчанию: 50, макс: 500)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить транзакции по счету
    
    Согласно OpenAPI спецификации и логике bank-in-a-box:
    - Поддерживает пагинацию (page, limit)
    - Фильтрация по датам (from_booking_date_time, to_booking_date_time)
    - Требует согласие с разрешением ReadTransactionsDetail
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия (опционально, если не указано - будет получен из БД)
    - **from_booking_date_time** (или **from_date**): Дата начала в формате ISO 8601 или YYYY-MM-DD
    - **to_booking_date_time** (или **to_date**): Дата конца в формате ISO 8601 или YYYY-MM-DD
    - **page**: Номер страницы (по умолчанию: 1)
    - **limit**: Количество транзакций на странице (по умолчанию: 50, макс: 500)
    
    **Требования:**
    - Согласие должно быть активным (status="approved")
    - Согласие должно содержать разрешение ReadTransactionsDetail
    - Согласие не должно быть истекшим
    """
    try:
        from app.models import BankConsent
        from sqlalchemy import select, and_
        from datetime import datetime
        
        # Валидация параметров пагинации (согласно логике bank-in-a-box)
        if page is None or page < 1:
            page = 1
        if limit is None or limit < 1:
            limit = 50
        if limit > 500:
            limit = 500
        
        # Если consent_id не указан, получаем его из БД
        if not consent_id:
            stmt = select(BankConsent).where(
                and_(
                    BankConsent.user_id == user_id,
                    BankConsent.bank_code == bank_code,
                    BankConsent.status == "approved"
                )
            ).order_by(BankConsent.created_at.desc())
            result = await db.execute(stmt)
            consent = result.scalar_one_or_none()
            
            if not consent:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "error": "CONSENT_REQUIRED",
                        "message": f"Требуется согласие клиента для доступа к транзакциям. Получите согласие через POST /account-consents с permissions=['ReadTransactionsDetail']"
                    }
                )
            
            # Проверяем, что согласие не истекло
            if consent.expires_at and consent.expires_at < datetime.utcnow():
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "error": "CONSENT_EXPIRED",
                        "message": "Согласие истекло. Получите новое согласие через POST /account-consents с permissions=['ReadTransactionsDetail']"
                    }
                )
            
            consent_id = consent.consent_id
            logger.info(f"Using consent_id from DB: {consent_id} for bank {bank_code}")
        else:
            # Если consent_id указан, проверяем его существование и валидность
            stmt = select(BankConsent).where(
                and_(
                    BankConsent.consent_id == consent_id,
                    BankConsent.user_id == user_id,
                    BankConsent.bank_code == bank_code,
                    BankConsent.status == "approved"
                )
            )
            result = await db.execute(stmt)
            consent = result.scalar_one_or_none()
            
            if not consent:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "error": "CONSENT_NOT_FOUND",
                        "message": f"Согласие {consent_id} не найдено или не активно"
                    }
                )
            
            # Проверяем, что согласие не истекло
            if consent.expires_at and consent.expires_at < datetime.utcnow():
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "error": "CONSENT_EXPIRED",
                        "message": "Согласие истекло. Получите новое согласие через POST /account-consents с permissions=['ReadTransactionsDetail']"
                    }
                )
        
        # Примечание: Проверка разрешения ReadTransactionsDetail происходит на стороне банка
        # при запросе транзакций. Если согласие не содержит это разрешение, банк вернет ошибку.
        # В bank-in-a-box это проверяется через ConsentService.check_consent с permissions=["ReadTransactionsDetail"]
        # В нашем случае, мы полагаемся на проверку со стороны банка, так как permissions
        # не хранятся в нашей БД, но должны быть включены при создании согласия.
        
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        transactions_data = await universal_bank_service.get_account_transactions(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id,
            from_booking_date_time=from_booking_date_time,
            to_booking_date_time=to_booking_date_time,
            page=page,
            limit=limit
        )
        
        if not transactions_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Transactions not found"
            )
        
        transactions = transactions_data.get("transactions", [])
        
        # Преобразуем транзакции в формат схемы
        formatted_transactions = []
        for tx in transactions:
            # Преобразуем accountId -> account_id
            tx_account_id = tx.get("accountId") or tx.get("account_id") or account_id
            
            # Преобразуем amount из объекта в число
            tx_amount = None
            tx_currency = None
            if "amount" in tx:
                if isinstance(tx["amount"], dict):
                    # Формат: {"amount": {"amount": "1570.56", "currency": "RUB"}}
                    tx_amount = float(tx["amount"].get("amount", 0)) if tx["amount"].get("amount") else None
                    tx_currency = tx["amount"].get("currency")
                elif isinstance(tx["amount"], str):
                    # Формат: "1570.56"
                    tx_amount = float(tx["amount"]) if tx["amount"] else None
                else:
                    tx_amount = float(tx["amount"]) if tx["amount"] else None
            
            # Если currency не в amount, берем из верхнего уровня
            if not tx_currency:
                tx_currency = tx.get("currency")
            
            # Преобразуем даты
            booking_date = None
            value_date = None
            if tx.get("bookingDateTime"):
                try:
                    booking_date = datetime.fromisoformat(tx["bookingDateTime"].replace("Z", "+00:00"))
                except:
                    pass
            if tx.get("valueDateTime"):
                try:
                    value_date = datetime.fromisoformat(tx["valueDateTime"].replace("Z", "+00:00"))
                except:
                    pass
            
            # Формируем транзакцию в формате схемы
            formatted_tx = {
                "transaction_id": tx.get("transactionId") or tx.get("transaction_id"),
                "account_id": tx_account_id,
                "amount": tx_amount,
                "currency": tx_currency,
                "transaction_type": tx.get("creditDebitIndicator") or tx.get("transaction_type"),
                "booking_date": booking_date,
                "value_date": value_date,
                "remittance_information": (
                    tx.get("transactionInformation") or 
                    tx.get("remittanceInformation", {}).get("unstructured") if isinstance(tx.get("remittanceInformation"), dict) else tx.get("remittanceInformation") or
                    tx.get("remittance_information")
                ),
                "creditor_name": tx.get("creditorName") or tx.get("creditor_name"),
                "creditor_account": tx.get("creditorAccount", {}).get("identification") if isinstance(tx.get("creditorAccount"), dict) else tx.get("creditor_account"),
                "debtor_name": tx.get("debtorName") or tx.get("debtor_name"),
                "debtor_account": tx.get("debtorAccount", {}).get("identification") if isinstance(tx.get("debtorAccount"), dict) else tx.get("debtor_account"),
            }
            
            formatted_transactions.append(BankTransactionSchema(**formatted_tx))
        
        return GetBankTransactionsResponse(
            success=True,
            account_id=account_id,
            transactions=formatted_transactions,
            total_count=len(formatted_transactions)
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting transactions: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== СОГЛАСИЯ ====================

@router.post("/account-consents")
async def create_account_consent(
    bank_code: str = Query(..., description="Код банка"),
    permissions: Optional[List[str]] = Query(None, description="Список разрешений (по умолчанию: ReadAccountsDetail, ReadBalances, ReadTransactionsDetail)"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Создать согласие на доступ к счетам пользователя
    
    Создает согласие и сохраняет его в БД для последующего использования.
    Для каждого банка создается отдельное согласие.
    
    **Параметры:**
    - **bank_code**: Код банка (vbank, abank, sbank)
    - **permissions**: Список разрешений (опционально)
    
    **Разрешения:**
    - ReadAccountsDetail - доступ к деталям счетов
    - ReadBalances - доступ к балансам
    - ReadTransactionsDetail - доступ к транзакциям (обязательно для получения транзакций)
    """
    try:
        from app.models import BankConsent, BankUser
        from sqlalchemy import select, and_
        from datetime import datetime, timedelta
        
        # Получаем bank_user_id для пользователя
        stmt = select(BankUser).where(
            and_(
                BankUser.user_id == user_id,
                BankUser.bank_code == bank_code
            )
        )
        result = await db.execute(stmt)
        bank_user = result.scalar_one_or_none()
        
        if not bank_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Bank user ID not found for {bank_code}. Please set it in profile first."
            )
        
        bank_user_id = bank_user.bank_user_id
        
        # Используем дефолтные разрешения, если не указаны
        if permissions is None:
            permissions = ["ReadAccountsDetail", "ReadBalances", "ReadTransactionsDetail"]
        
        # Убеждаемся, что ReadTransactionsDetail всегда включен для работы с транзакциями
        if "ReadTransactionsDetail" not in permissions:
            permissions.append("ReadTransactionsDetail")
        
        # Получаем токен банка
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        # Создаем согласие через API банка
        consent_data = await universal_bank_service.request_account_consent(
            bank_code=bank_code,
            access_token=access_token,
            user_id=bank_user_id,
            permissions=permissions
        )
        
        if not consent_data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to create consent"
            )
        
        consent_id = consent_data.get("consent_id")
        consent_status = consent_data.get("status", "approved")
        auto_approved = consent_data.get("auto_approved", True)
        request_id = consent_data.get("request_id")  # Для pending согласий может быть request_id
        
        # Если согласие в статусе pending и нет consent_id, используем request_id
        if consent_status == "pending" and not consent_id and request_id:
            consent_id = request_id
            logger.info(f"[{bank_code}] Using request_id as consent_id for pending consent: {request_id}")
        
        # Проверяем, что consent_id не None перед сохранением
        if not consent_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={
                    "error": "CONSENT_ID_MISSING",
                    "message": f"Согласие создано, но consent_id отсутствует. Статус: {consent_status}. Возможно, требуется ручное одобрение в банке {bank_code}."
                }
            )
        
        # Вычисляем дату истечения (по умолчанию 365 дней)
        expires_at = datetime.utcnow() + timedelta(days=365)
        
        # Проверяем, есть ли уже согласие для этого пользователя и банка
        # Ищем как approved, так и pending согласия
        existing_stmt = select(BankConsent).where(
            and_(
                BankConsent.user_id == user_id,
                BankConsent.bank_code == bank_code
            )
        ).order_by(BankConsent.created_at.desc())
        existing_result = await db.execute(existing_stmt)
        existing_consent = existing_result.scalar_one_or_none()
        
        if existing_consent:
            # Обновляем существующее согласие
            existing_consent.consent_id = consent_id
            existing_consent.status = consent_status
            existing_consent.auto_approved = auto_approved
            existing_consent.expires_at = expires_at
            existing_consent.updated_at = datetime.utcnow()
            await db.commit()
            await db.refresh(existing_consent)
            logger.info(f"Updated consent {consent_id} for user {user_id} and bank {bank_code}, status: {consent_status}")
        else:
            # Создаем новое согласие
            new_consent = BankConsent(
                user_id=user_id,
                bank_code=bank_code,
                consent_id=consent_id,
                status=consent_status,
                auto_approved=auto_approved,
                expires_at=expires_at
            )
            db.add(new_consent)
            await db.commit()
            await db.refresh(new_consent)
            logger.info(f"Created new consent {consent_id} for user {user_id} and bank {bank_code}, status: {consent_status}")
        
        # Формируем сообщение в зависимости от статуса
        if consent_status == "pending":
            message = f"Согласие создано и ожидает одобрения в банке {bank_code}. После одобрения оно будет автоматически активировано."
        else:
            message = "Consent created and saved successfully"
        
        return {
            "success": True,
            "consent_id": consent_id,
            "status": consent_status,
            "auto_approved": auto_approved,
            "permissions": permissions,
            "expires_at": expires_at.isoformat(),
            "message": message
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/consents")
async def get_user_consents(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить список всех согласий пользователя
    
    Возвращает все согласия пользователя для всех банков.
    """
    try:
        from app.models import BankConsent
        from sqlalchemy import select, and_
        
        stmt = select(BankConsent).where(
            BankConsent.user_id == user_id
        ).order_by(BankConsent.created_at.desc())
        
        result = await db.execute(stmt)
        consents = result.scalars().all()
        
        return {
            "success": True,
            "consents": [
                {
                    "consent_id": consent.consent_id,
                    "bank_code": consent.bank_code,
                    "status": consent.status,
                    "auto_approved": consent.auto_approved,
                    "expires_at": consent.expires_at.isoformat() if consent.expires_at else None,
                    "created_at": consent.created_at.isoformat(),
                    "updated_at": consent.updated_at.isoformat()
                }
                for consent in consents
            ]
        }
    
    except Exception as e:
        logger.error(f"Error getting user consents: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/consents/{consent_id}")
async def get_consent_details(
    consent_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить детали согласия
    
    **Параметры:**
    - **consent_id**: ID согласия
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        consent_data = await universal_bank_service.get_consent_details(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id
        )
        
        if not consent_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Consent not found"
            )
        
        return {
            "success": True,
            "consent": consent_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.delete("/consents/{consent_id}")
async def delete_consent(
    consent_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Удалить согласие
    
    **Параметры:**
    - **consent_id**: ID согласия
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        success = await universal_bank_service.delete_consent(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id
        )
        
        if not success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to delete consent"
            )
        
        return {
            "success": True,
            "message": "Consent deleted successfully"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== ПЛАТЕЖИ ====================

@router.post("/payments/consents")
async def create_payment_consent(
    bank_code: str = Query(..., description="Код банка"),
    payment_data: dict = None,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Создать согласие на платеж
    
    **Параметры:**
    - **bank_code**: Код банка
    - **payment_data**: Данные платежа
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        consent_data = await universal_bank_service.create_payment_consent(
            bank_code=bank_code,
            access_token=access_token,
            user_id=str(user_id),
            payment_data=payment_data
        )
        
        if not consent_data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to create payment consent"
            )
        
        return {
            "success": True,
            "consent": consent_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating payment consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/payments")
async def initiate_payment(
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия на платеж"),
    payment_data: dict = None,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Инициировать платеж
    
    **Параметры:**
    - **bank_code**: Код банка
    - **consent_id**: ID согласия на платеж
    - **payment_data**: Данные платежа
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        payment_result = await universal_bank_service.initiate_payment(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id,
            payment_data=payment_data
        )
        
        if not payment_result:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to initiate payment"
            )
        
        return {
            "success": True,
            "payment": payment_result
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error initiating payment: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/payments/{payment_id}")
async def get_payment_status(
    payment_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить статус платежа
    
    **Параметры:**
    - **payment_id**: ID платежа
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        payment_status = await universal_bank_service.get_payment_status(
            bank_code=bank_code,
            access_token=access_token,
            payment_id=payment_id
        )
        
        if not payment_status:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Payment not found"
            )
        
        return {
            "success": True,
            "payment": payment_status
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting payment status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== УТИЛИТЫ ====================

@router.get("/banks/list")
async def list_available_banks():
    """
    Получить список доступных банков
    """
    return {
        "banks": [
            {
                "code": "vbank",
                "name": "Virtual Bank",
                "url": "https://vbank.open.bankingapi.ru"
            },
            {
                "code": "abank",
                "name": "Awesome Bank",
                "url": "https://abank.open.bankingapi.ru"
            },
            {
                "code": "sbank",
                "name": "Smart Bank",
                "url": "https://sbank.open.bankingapi.ru"
            }
        ]
    }


@router.get("/health")
async def health_check():
    """Проверка работоспособности API"""
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat()
    }
</file>

<file path="docker-compose.yml">
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: fastapi_user
      POSTGRES_PASSWORD: fastapi_password
      POSTGRES_DB: fastapi_db
    ports:
      - "5434:5432"  # Изменен внешний порт на 5434, чтобы избежать конфликта
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U fastapi_user -d fastapi_db"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6381:6379"  # Изменен внешний порт на 6381, чтобы избежать конфликта
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  app:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://fastapi_user:fastapi_password@postgres:5432/fastapi_db
      REDIS_URL: redis://redis:6379/0
    env_file:
      - .env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app
    networks:
      - app-network

  celery:
    build:
      context: .
      dockerfile: Dockerfile
    command: celery -A app.tasks.sync_tasks worker --loglevel=info
    environment:
      DATABASE_URL: postgresql+asyncpg://fastapi_user:fastapi_password@postgres:5432/fastapi_db
      REDIS_URL: redis://redis:6379/0
    env_file:
      - .env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - .:/app
    networks:
      - app-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    ports:
      - "5173:5173"
    environment:
      VITE_API_URL: ${VITE_API_URL:-http://localhost:8000}
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - app
    networks:
      - app-network

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge
</file>

<file path="vtb_api_hack.session.sql">
-- TRUNCATE TABLE users;
-- SELECT * FROM users;
-- TRUNCATE TABLE sms_verifications;
</file>

<file path="main.py">
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from contextlib import asynccontextmanager
from app.auth_router import router as auth_router
from app.users_router import router as users_router
from app.bank_api_router import router as bank_api_router
from app.analytics_router import router as analytics_router
from app.predictions_router import router as predictions_router
from app.ar_router import router as ar_router
from app.counterparty_router import router as counterparty_router
from app.sync_router import router as sync_router
from app.database import engine
from app.models import Base
from app.config import get_settings
import logging

settings = get_settings()
import uvicorn

logger = logging.getLogger(__name__)



@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    try:
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        print("✅ Database tables created successfully")
    except Exception as e:
        print(f"⚠️  Warning: Database initialization error: {e}")
        # Continue anyway - tables might already exist
    yield
    # Shutdown
    await engine.dispose()

app = FastAPI(
    title="Multi-Banking MVP API",
    description="MVP for multi-banking application for Solo Entrepreneurs with financial analytics, ML predictions, and AR management",
    version="1.0.0",
    lifespan=lifespan
)

# Better validation error handling
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle validation errors with better error messages"""
    errors = []
    for error in exc.errors():
        field = " -> ".join(str(loc) for loc in error["loc"])
        errors.append({
            "field": field,
            "message": error["msg"],
            "type": error["type"]
        })
    
    logger.warning(f"Validation error on {request.url.path}: {errors}")
    
    return JSONResponse(
        status_code=422,
        content={
            "detail": "Validation error",
            "errors": errors
        }
    )

# CORS - allow frontend origins
allowed_origins = [
    "http://localhost:5173",      # Vite dev server (local)
    "http://127.0.0.1:5173",      # Vite dev server (local)
    "http://localhost:3000",      # Frontend production (local)
    "http://127.0.0.1:3000",      # Frontend production (local)
    "http://frontend:5173",       # Frontend container (dev)
    "http://frontend:80",         # Frontend container (prod)
]

# Add custom origins from environment if specified
if hasattr(settings, 'CORS_ORIGINS') and settings.CORS_ORIGINS:
    custom_origins = settings.CORS_ORIGINS.split(',')
    allowed_origins.extend([origin.strip() for origin in custom_origins])

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(auth_router)
app.include_router(users_router)
app.include_router(bank_api_router)
app.include_router(analytics_router)
app.include_router(predictions_router)
app.include_router(ar_router)
app.include_router(counterparty_router)
app.include_router(sync_router)

@app.get("/health")
async def health_check():
    return {"status": "ok"}
</file>

<file path="requirements.txt">
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
greenlet==3.0.1
alembic==1.12.1
psycopg2-binary==2.9.9
python-dotenv==1.0.0
pydantic==2.5.0
pydantic-settings==2.1.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
httpx==0.25.2
aioredis==2.0.1
celery==5.3.4
redis==5.0.1
requests==2.31.0
email-validator==2.1.0
bcrypt==4.0.1
asyncpg==0.30.0
aiohttp==3.13.2
numpy==1.24.3
# Testing dependencies
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
aiosqlite==0.19.0
</file>

<file path="app/auth_router.py">
import secrets
from fastapi import APIRouter, HTTPException, status, Depends, Query
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.schemas import UserRegister, UserResponse, SMSVerificationRequest, SMSVerificationConfirm
from app.auth_schemas import TokenResponse, TokenRequest, RefreshTokenRequest
from app.models import User
from app.database import get_db
from app.services.sms_service import sms_service
from app.services.oauth_service import oauth_service
from app.services.bank_oauth_service import OAuth2BankService
from app.security.password import hash_password, verify_password
from app.security.jwt_handler import create_access_token, create_refresh_token, decode_token
from app.config import get_settings
from app.services.universal_bank_service import universal_bank_service
from datetime import datetime, timedelta
import logging

router = APIRouter(prefix="/auth", tags=["auth"])
settings = get_settings()
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register(user_data: UserRegister, db: AsyncSession = Depends(get_db)):
    """Регистрация пользователя (без SMS верификации - пользователь активируется сразу)"""
    try:
        # Проверка существования пользователя
        result = await db.execute(
            select(User).where((User.email == user_data.email) | (User.phone_number == user_data.phone_number))
        )
        if result.scalars().first():
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Email или номер телефона уже зарегистрирован"
            )
        
        # Создание пользователя с автоматической активацией (без SMS верификации)
        user = User(
            email=user_data.email,
            phone_number=user_data.phone_number,
            first_name=user_data.first_name,
            last_name=user_data.last_name,
            hashed_password=hash_password(user_data.password),
            is_active=True,  # Автоматически активируем пользователя
            is_phone_verified=True,  # Пропускаем SMS верификацию
            is_email_verified=False  # Email верификация не требуется на данном этапе
        )
        db.add(user)
        await db.commit()
        await db.refresh(user)
        
        logger.info(f"User registered successfully: {user.id}, email: {user.email}")
        
        return UserResponse.from_orm(user)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error during registration: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка регистрации: {str(e)}"
        )

@router.post("/verify-sms")
async def verify_sms(data: SMSVerificationConfirm, db: AsyncSession = Depends(get_db)):
    """Проверка SMS кода"""
    
    # Проверка кода
    verified = await sms_service.verify_sms_code(data.phone_number, data.code, db)
    if not verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Неверный или истекший код"
        )
    
    # Обновление пользователя
    result = await db.execute(select(User).where(User.phone_number == data.phone_number))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_phone_verified = True
    user.is_active = True
    await db.commit()
    
    return {"message": "Номер телефона успешно подтвержден"}

@router.post("/login", response_model=TokenResponse)
async def login(credentials: TokenRequest, db: AsyncSession = Depends(get_db)):
    """Вход в систему"""
    
    result = await db.execute(select(User).where(User.email == credentials.email))
    user = result.scalars().first()
    
    if not user:
        logger.warning(f"Login attempt with non-existent email: {credentials.email}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    logger.info(f"User found: {user.id}, is_active: {user.is_active}, hashed_password length: {len(user.hashed_password) if user.hashed_password else 0}")
    
    if not verify_password(credentials.password, user.hashed_password):
        logger.warning(f"Invalid password for user: {user.id}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    if not user.is_active:
        logger.warning(f"Inactive user attempted login: {user.id}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Генерация токенов
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token(user.id)
    
    # Обновление последнего входа
    user.last_login = datetime.utcnow()
    await db.commit()
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh(request: RefreshTokenRequest, db: AsyncSession = Depends(get_db)):
    """Обновление access токена"""
    
    user_id = decode_token(request.refresh_token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )
    
    access_token = create_access_token({"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=request.refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.get("/oauth/authorize/{bank_code}")
async def oauth_authorize(bank_code: str, db: AsyncSession = Depends(get_db)):
    """
    Инициирование OAuth flow для входа через банк
    
    Процесс:
    1. Генерируем OAuth state для безопасности
    2. Перенаправляем пользователя на страницу авторизации банка
    3. После авторизации банк перенаправит на /auth/oauth/callback
    """
    
    try:
        logger.info(f"Starting OAuth authorize flow for bank: {bank_code}")
        
        # Валидация кода банка
        try:
            bank_config = settings.get_bank_config(bank_code)
        except ValueError as e:
            logger.error(f"Invalid bank code: {bank_code}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid bank code: {bank_code}"
            )
        
        # Генерируем OAuth state для безопасности
        oauth_state_data = await oauth_service.generate_oauth_state(f"bank_{bank_code}", db)
        state = oauth_state_data["state"]
        
        logger.info(f"Generated OAuth state: {state} for bank: {bank_code}")
        
        # Генерируем URL для перенаправления на банк
        auth_url = oauth_service.generate_authorization_url(state, bank_config)
        
        logger.info(f"Redirecting to bank authorization URL: {auth_url}")
        return RedirectResponse(url=auth_url)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in oauth_authorize: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth authorization failed: {str(e)}"
        )

@router.get("/oauth/callback")
async def oauth_callback(code: str, state: str, db: AsyncSession = Depends(get_db)):
    """
    Callback от банка после авторизации пользователя
    На этом этапе мы уже имеем:
    - Данные счетов пользователя
    - Согласие на доступ
    - Информацию о пользователе
    """
    try:
        logger.info(f"OAuth callback received with state: {state}")
        
        # Валидация состояния
        oauth_session = await oauth_service.validate_oauth_state(state, db)
        if not oauth_session:
            logger.error(f"Invalid OAuth state: {state}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state"
            )
        
        # Обмен кода на токен у банка
        logger.info("Exchanging authorization code for token...")
        token_response = await oauth_service.exchange_code_for_token(
            code, 
            oauth_session["code_verifier"]
        )
        
        if not token_response:
            logger.error("Failed to exchange code for token")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to exchange code for token"
            )
        
        # Получение информации о пользователе от банка
        logger.info("Retrieving user info from bank...")
        user_info = await oauth_service.get_user_info(token_response.get("access_token"))
        
        if not user_info:
            logger.error("Failed to get user info")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to get user info"
            )
        
        # Поиск или создание пользователя
        oauth_id = user_info.get("sub")
        logger.info(f"Looking up user with oauth_id: {oauth_id}")
        
        result = await db.execute(
            select(User).where((User.oauth_id == oauth_id) | (User.email == user_info.get("email")))
        )
        user = result.scalars().first()
        
        if not user:
            logger.info(f"Creating new user from OAuth info")
            user = User(
                email=user_info.get("email"),
                phone_number=user_info.get("phone_number", ""),
                first_name=user_info.get("given_name", ""),
                last_name=user_info.get("family_name", ""),
                oauth_provider="bank",
                oauth_id=oauth_id,
                is_active=True,
                is_phone_verified=True,
                is_email_verified=True,
                hashed_password=hash_password(secrets.token_urlsafe(32))
            )
            db.add(user)
            await db.commit()
            await db.refresh(user)
            logger.info(f"New user created: {user.id}")
        else:
            logger.info(f"Existing user found: {user.id}")
        
        # Генерация токенов
        logger.info("Generating access and refresh tokens...")
        access_token = create_access_token({"sub": str(user.id)})
        refresh_token = create_refresh_token(user.id)
        
        logger.info(f"OAuth callback completed successfully for user {user.id}")
        
        # Перенаправление на фронтенд с токенами
        redirect_url = f"{settings.FRONTEND_URL}/auth/success?access_token={access_token}&refresh_token={refresh_token}"
        return RedirectResponse(url=redirect_url)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in oauth_callback: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth callback failed: {str(e)}"
        )

@router.get("/oauth/bank-bills")
async def get_oauth_bank_accounts(
    bank_code: str = Query(..., description="Код банка: vbank, abank, sbank"),
    db: AsyncSession = Depends(get_db)
):
    """
    Эндпоинт для получения банковских счетов пользователя через OAuth
    Использует полный цикл получения данных от банка
    """
    try:
        logger.info(f"Getting bank accounts through full OAuth cycle for bank: {bank_code}")
        
        # Создаем экземпляр сервиса для конкретного банка
        oauth_bank_service = OAuth2BankService(bank_code=bank_code)
        
        # Можно передать реальный user_id вместо session_id
        session_id = secrets.token_urlsafe(16)
        
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=bank_data.get("error")
            )
        
        return {
            "success": True,
            "accounts": bank_data.get("bills", []),
            "consent_id": bank_data.get("consent_id"),
            "auto_approved": bank_data.get("auto_approved", True)
        }
        
    except Exception as e:
        logger.error(f"Error getting bank accounts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get bank accounts: {str(e)}"
        )
</file>

<file path="app/config.py">
from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Dict

class BankConfig(BaseSettings):
    api_url: str
    client_id: str
    client_secret: str
    requesting_bank: str
    requesting_bank_name: str
    redirecting_url: str


class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db"
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # JWT
    SECRET_KEY: str = "aMeucfHi2Xxl3v0LYb1Tcduk-NuQOOjGVrTxqhDrT0A"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # SMS
    SMS_SERVICE_PROVIDER: str = "sms_ru"
    SMS_API_KEY: str = "18608A37-567C-3C70-F128-03938B6AF52A"
    SMS_FROM_NAME: str = "YourApp"
    
    # Frontend
    FRONTEND_URL: str = "http://localhost:5173"
    CORS_ORIGINS: str = ""  # Comma-separated list of additional CORS origins
    
    # ==================== КОНФИГУРАЦИЯ ДЛЯ ТРЁХ БАНКОВ ====================
    
    # Virtual Bank (vbank)
    VBANK_API_URL: str = "https://vbank.open.bankingapi.ru"
    VBANK_CLIENT_ID: str = "team261-1"
    VBANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    VBANK_REQUESTING_BANK: str = "team261"
    VBANK_REQUESTING_BANK_NAME: str = "Team 261 Virtual Bank App"
    VBANK_REDIRECTING_URL: str = "https://vbank.open.bankingapi.ru/client/"
    
    # Awesome Bank (abank)
    ABANK_API_URL: str = "https://abank.open.bankingapi.ru"
    ABANK_CLIENT_ID: str = "team261-1"
    ABANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    ABANK_REQUESTING_BANK: str = "team261"
    ABANK_REQUESTING_BANK_NAME: str = "Team 261 Awesome Bank App"
    ABANK_REDIRECTING_URL: str = "https://abank.open.bankingapi.ru/client/"
    
    # Smart Bank (sbank)
    SBANK_API_URL: str = "https://sbank.open.bankingapi.ru"
    SBANK_CLIENT_ID: str = "team261-1"
    SBANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    SBANK_REQUESTING_BANK: str = "team261"
    SBANK_REQUESTING_BANK_NAME: str = "Team 261 Smart Bank App"
    SBANK_REDIRECTING_URL: str = "https://sbank.open.bankingapi.ru/client/"
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    def get_bank_config(self, bank_code: str) -> BankConfig:
        """
        Получить конфигурацию для конкретного банка
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Returns:
            BankConfig с параметрами банка
        
        Raises:
            ValueError: Если банк не найден
        """
        bank_configs = {
            "vbank": BankConfig(
                api_url=self.VBANK_API_URL,
                client_id=self.VBANK_CLIENT_ID,
                client_secret=self.VBANK_CLIENT_SECRET,
                requesting_bank=self.VBANK_REQUESTING_BANK,
                requesting_bank_name=self.VBANK_REQUESTING_BANK_NAME,
                redirecting_url=self.VBANK_REDIRECTING_URL
            ),
            "abank": BankConfig(
                api_url=self.ABANK_API_URL,
                client_id=self.ABANK_CLIENT_ID,
                client_secret=self.ABANK_CLIENT_SECRET,
                requesting_bank=self.ABANK_REQUESTING_BANK,
                requesting_bank_name=self.ABANK_REQUESTING_BANK_NAME,
                redirecting_url=self.ABANK_REDIRECTING_URL
            ),
            "sbank": BankConfig(
                api_url=self.SBANK_API_URL,
                client_id=self.SBANK_CLIENT_ID,
                client_secret=self.SBANK_CLIENT_SECRET,
                requesting_bank=self.SBANK_REQUESTING_BANK,
                requesting_bank_name=self.SBANK_REQUESTING_BANK_NAME,
                redirecting_url=self.SBANK_REDIRECTING_URL
            )
        }
        
        if bank_code not in bank_configs:
            raise ValueError(f"Unknown bank code: {bank_code}. Available: {list(bank_configs.keys())}")
        
        return bank_configs[bank_code]
    
    def get_all_banks(self) -> Dict[str, BankConfig]:
        """Получить конфигурации всех банков"""
        return {
            "vbank": self.get_bank_config("vbank"),
            "abank": self.get_bank_config("abank"),
            "sbank": self.get_bank_config("sbank")
        }

@lru_cache()
def get_settings():
    return Settings()
</file>

</files>
