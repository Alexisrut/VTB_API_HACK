This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  security/
    __init__.py
    jwt_handler.py
    oauth2.py
    password.py
  services/
    bank_oauth_service.py
    oauth_service.py
    sms_service.py
  utils/
    __init__.py
    exceptions.py
    validators.py
  __init__.py
  auth_router.py
  auth_schemas.py
  config.py
  database.py
  models.py
  schemas.py
  users_router.py
.gitignore
docker-compose.yml
Dockerfile
env.example
main.py
README.md
requirements.txt
vtb_api_hack.session.sql
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="vtb_api_hack.session.sql">
TRUNCATE TABLE users;
SELECT * FROM users;
</file>

<file path="app/security/__init__.py">

</file>

<file path="app/security/jwt_handler.py">
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.config import get_settings

settings = get_settings()

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(user_id: int) -> str:
    data = {
        "sub": str(user_id),
        "type": "refresh"
    }
    expires_delta = timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    return create_access_token(data, expires_delta)

def verify_token(token: str) -> Optional[Dict[str, Any]]:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None

def decode_token(token: str) -> Optional[int]:
    payload = verify_token(token)
    if payload:
        user_id = payload.get("sub")
        if user_id:
            return int(user_id)
    return None
</file>

<file path="app/services/bank_oauth_service.py">
import aiohttp
import secrets
from datetime import datetime, timedelta
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.config import get_settings
from app.models import OAuthSession, User
import logging

settings = get_settings()
logger = logging.getLogger(__name__)

class OAuth2BankService:
    def __init__(self):
        self.bank_api_url = settings.BANK_API_URL
        self.client_id = settings.BANK_CLIENT_ID
        self.client_secret = settings.BANK_CLIENT_SECRET
        self.requesting_bank = "team261"  # Или из конфига
        self.requesting_bank_name = "team261 App"
    
    # ============ ШАГ 1: Получение токена банка ============
    async def get_bank_access_token(self) -> str:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://vbank.open.bankingapi.ru/auth/bank-token
        ?client_id=team200&client_secret=YOUR_SECRET
        
        Returns:
            str: access_token для использования в дальнейших запросах
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/auth/bank-token"
                params = {
                    "client_id": self.requesting_bank,
                    "client_secret": self.client_secret
                }
                
                logger.info(f"Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info("Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error getting bank token: {e}")
            return None
    
    # ============ ШАГ 2: Запрос согласия (авто-одобрение) ============
    async def request_account_consent(self, access_token: str, user_id: str) -> dict:
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": ["ReadAccountsDetail", "ReadBalances"],
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": self.requesting_bank,
                    "requesting_bank_name": self.requesting_bank_name
                }
                
                logger.info(f"Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"Consent received: {data.get('consent_id')}")
                        return {
                            "status": data.get("status", "approved"),
                            "consent_id": data.get("consent_id"),
                            "auto_approved": data.get("auto_approved", True)
                        }
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to request consent {user_id}: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error requesting consent: {e}")
            return None
    
    # ============ ШАГ 3: Получить данные счетов ============
    async def get_user_accounts(self, access_token: str, user_id: str, consent_id: str) -> dict:
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"Successfully fetched {len(data.get('accounts', []))} accounts")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error fetching accounts: {e}")
            return None

    async def get_bank_accounts_full_cycle(self, user_id: str) -> dict:
        try:
            # ШАГ 1: Получить токен банка
            logger.info("STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token()
            
            if not access_token:
                return {
                    "success": False,
                    "error": "Failed to obtain bank access token"
                }
            
            # ШАГ 2: Запросить согласие
            logger.info("STEP 2: Requesting account consent...")
            consent_data = await self.request_account_consent(access_token, self.client_id)
            
            if not consent_data:
                return {
                    "success": False,
                    "error": "Failed to request account consent"
                }
            
            consent_id = consent_data.get("consent_id")

            logger.info("STEP 3: Fetching user accounts...")
            accounts_data = await self.get_user_accounts(access_token, self.client_id, consent_id)
            
            if not accounts_data:
                return {
                    "success": False,
                    "error": "Failed to fetch accounts"
                }
            print(accounts_data)
            return {
                "success": True,
                "bills": accounts_data['data']['account'],
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True)
            }
        
        except Exception as e:
            logger.error(f"Error in full cycle: {e}")
            return {
                "success": False,
                "error": str(e)
            }
oauth_bank_service = OAuth2BankService()
</file>

<file path="app/services/oauth_service.py">
import secrets
import aiohttp
from datetime import datetime, timedelta
from urllib.parse import urlencode
from jose import jwt
from sqlalchemy.ext.asyncio import AsyncSession
from app.config import get_settings
from app.models import OAuthSession
from sqlalchemy import select

settings = get_settings()

class OAuth2Service:
    
    async def generate_oauth_state(self, provider: str, db: AsyncSession) -> dict:
        """Генерация состояния для OAuth flow"""
        state = secrets.token_urlsafe(32)
        code_verifier = secrets.token_urlsafe(32)
        
        oauth_session = OAuthSession(
            state=state,
            code_verifier=code_verifier,
            provider=provider,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(oauth_session)
        await db.commit()
        
        return {
            "state": state,
            "code_verifier": code_verifier
        }
    
    def generate_authorization_url(self, state: str) -> str:
        """Генерация URL для перенаправления на банковский API"""
        
        params = {
            "response_type": "code",
            "client_id": settings.BANK_CLIENT_ID,
            "redirect_uri": settings.BANK_REDIRECT_URI,
            "scope": "openid profile accounts",
            "state": state,
            "nonce": secrets.token_urlsafe(16),
            "code_challenge_method": "S256",
        }
        
        return f"{settings.BANK_API_URL}/oauth/authorize?{urlencode(params)}"
    
    async def exchange_code_for_token(self, code: str, code_verifier: str) -> dict:
        """Обмен кода на токен"""
        async with aiohttp.ClientSession() as session:
            data = {
                "grant_type": "authorization_code",
                "code": code,
                "client_id": settings.BANK_CLIENT_ID,
                "client_secret": settings.BANK_CLIENT_SECRET,
                "redirect_uri": settings.BANK_REDIRECT_URI,
                "code_verifier": code_verifier
            }
            
            async with session.post(
                f"{settings.BANK_API_URL}/oauth/token",
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def get_user_info(self, access_token: str) -> dict:
        """Получение информации о пользователе"""
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {access_token}"}
            async with session.get(
                f"{settings.BANK_API_URL}/oauth/userinfo",
                headers=headers
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def validate_oauth_state(self, state: str, db: AsyncSession) -> dict:
        """Валидация состояния OAuth"""
        result = await db.execute(
            select(OAuthSession).where(
                OAuthSession.state == state,
                OAuthSession.expires_at > datetime.utcnow()
            )
        )
        session = result.scalars().first()
        
        if not session:
            return None
        
        return {
            "state": session.state,
            "code_verifier": session.code_verifier,
            "provider": session.provider
        }

oauth_service = OAuth2Service()
</file>

<file path="app/services/sms_service.py">
import aiohttp
import random
from datetime import datetime, timedelta
from app.config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import SMSVerification
from sqlalchemy import select

settings = get_settings()

class SMSService:
    async def send_sms(self, phone_number: str, message: str) -> bool:
        """Отправка SMS через API"""
        try:
            if settings.SMS_SERVICE_PROVIDER == "sms_ru":
                return await self._send_sms_ru(phone_number, message)
            return True
        except Exception as e:
            print(f"SMS error: {e}")
            return False
    
    async def _send_sms_ru(self, phone_number: str, message: str) -> bool:
        """SMS через sms.ru"""
        async with aiohttp.ClientSession() as session:
            data = {
                "api_id": settings.SMS_API_KEY,
                "to": phone_number.lstrip("+"),
                "msg": message,
                "json": 1
            }
            async with session.post("https://sms.ru/sms/send", data=data) as resp:
                result = await resp.json()
                return result.get("status") == "OK"
    
    async def generate_sms_code(self) -> str:
        """Генерация 6-значного кода"""
        return "".join([str(random.randint(0, 9)) for _ in range(6)])
    
    async def send_registration_code(self, phone_number: str, db: AsyncSession) -> bool:
        """Отправка кода регистрации"""
        code = await self.generate_sms_code()
        
        # Сохранить в БД
        sms_verification = SMSVerification(
            phone_number=phone_number,
            code=code,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(sms_verification)
        await db.commit()
        
        message = f"Ваш код подтверждения: {code}. Действителен 10 минут."
        return await self.send_sms(phone_number, message)
    
    async def verify_sms_code(self, phone_number: str, code: str, db: AsyncSession) -> bool:
        """Проверка SMS кода"""
        result = await db.execute(
            select(SMSVerification).where(
                SMSVerification.phone_number == phone_number
            ).order_by(SMSVerification.created_at.desc())
        )
        verification = result.scalars().first()
        
        if not verification:
            return False
        
        if verification.expires_at < datetime.utcnow():
            return False
        
        if verification.attempts >= 3:
            return False
        
        if verification.code != code:
            verification.attempts += 1
            await db.commit()
            return False
        
        verification.verified = True
        await db.commit()
        return True

sms_service = SMSService()
</file>

<file path="app/utils/__init__.py">

</file>

<file path="app/utils/exceptions.py">
from fastapi import HTTPException, status

class UserAlreadyExists(HTTPException):
    def __init__(self, detail: str = "User already exists"):
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
        )

class InvalidCredentials(HTTPException):
    def __init__(self, detail: str = "Invalid email or password"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )

class UserNotActive(HTTPException):
    def __init__(self, detail: str = "User is not active"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )

class SMSError(HTTPException):
    def __init__(self, detail: str = "SMS sending error"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail
        )

class InvalidToken(HTTPException):
    def __init__(self, detail: str = "Invalid or expired token"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )
</file>

<file path="app/utils/validators.py">
import re

def validate_password_strength(password: str) -> tuple[bool, str]:
    """Проверка надежности пароля"""
    if len(password) < 8:
        return False, "Пароль должен быть минимум 8 символов"
    
    if not re.search(r'[A-Z]', password):
        return False, "Пароль должен содержать заглавные буквы"
    
    if not re.search(r'[a-z]', password):
        return False, "Пароль должен содержать строчные буквы"
    
    if not re.search(r'\d', password):
        return False, "Пароль должен содержать цифры"
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "Пароль должен содержать спецсимволы"
    
    return True, "OK"

def validate_email_format(email: str) -> bool:
    """Проверка формата email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_phone_format(phone: str) -> bool:
    """Проверка формата телефона"""
    pattern = r'^\+7\d{10}$'
    return re.match(pattern, phone) is not None

def is_email_valid(email: str) -> bool:
    """Расширенная проверка email"""
    return validate_email_format(email)
</file>

<file path="app/__init__.py">

</file>

<file path="app/auth_schemas.py">
from pydantic import BaseModel, Field

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int

class TokenRequest(BaseModel):
    email: str
    password: str

class RefreshTokenRequest(BaseModel):
    refresh_token: str

class OAuth2AuthRequest(BaseModel):
    state: str
    code_verifier: str
    provider: str = "bank"

class OAuthCallbackResponse(BaseModel):
    authorization_code: str
    state: str
</file>

<file path="app/database.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from app.config import get_settings

settings = get_settings()

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=True,
    pool_size=20,
    max_overflow=0
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session
</file>

<file path="app/models.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    is_active = Column(Boolean, default=False)
    is_email_verified = Column(Boolean, default=False)
    is_phone_verified = Column(Boolean, default=False)
    
    sms_code = Column(String(6), nullable=True)
    sms_code_expires_at = Column(DateTime, nullable=True)
    sms_attempts = Column(Integer, default=0)
    
    oauth_provider = Column(String(50), nullable=True)
    oauth_id = Column(String(255), nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    token = Column(Text, unique=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_revoked = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class SMSVerification(Base):
    __tablename__ = "sms_verifications"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    code = Column(String(6), nullable=False)
    attempts = Column(Integer, default=0)
    expires_at = Column(DateTime, nullable=False)
    verified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class OAuthSession(Base):
    __tablename__ = "oauth_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    state = Column(String(255), unique=True, nullable=False)
    code_verifier = Column(String(255), nullable=False)
    provider = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)


class AccessTokenBlacklist(Base):
    __tablename__ = "access_token_blacklist"
    
    id = Column(Integer, primary_key=True, index=True)
    token = Column(String(1000), unique=True, nullable=False)
    user_id = Column(Integer, nullable=False, index=True)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
</file>

<file path="app/schemas.py">
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
import re

class UserBase(BaseModel):
    email: EmailStr = Field(..., description="Email адрес")
    phone_number: str = Field(..., description="Номер телефона в формате +7XXXXXXXXXX")
    first_name: str = Field(..., min_length=2, max_length=100)
    last_name: str = Field(..., min_length=2, max_length=100)
    
    @field_validator("phone_number")
    @classmethod
    def validate_phone(cls, v):
        if not re.match(r'^\+7\d{10}$', v):
            raise ValueError("Номер телефона должен быть в формате +7XXXXXXXXXX")
        return v

class UserRegister(UserBase):
    password: str = Field(..., min_length=8, max_length=50)
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну заглавную букву")
        if not re.search(r'[a-z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну строчную букву")
        if not re.search(r'\d', v):
            raise ValueError("Пароль должен содержать хотя бы одну цифру")
        return v

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_email_verified: bool
    is_phone_verified: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserInDB(UserResponse):
    hashed_password: str

class SMSVerificationRequest(BaseModel):
    phone_number: str
    
class SMSVerificationConfirm(BaseModel):
    phone_number: str
    code: str = Field(..., min_length=6, max_length=6)
</file>

<file path="app/users_router.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import User
from app.schemas import UserResponse
from app.database import get_db
from app.security.oauth2 import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Получение информации о текущем пользователе"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse.from_orm(user)

@router.put("/me", response_model=UserResponse)
async def update_user_profile(
    update_data: dict,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Обновление профиля пользователя"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    for key, value in update_data.items():
        if hasattr(user, key):
            setattr(user, key, value)
    
    await db.commit()
    await db.refresh(user)
    
    return UserResponse.from_orm(user)

@router.post("/logout")
async def logout(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Выход из системы"""
    return {"message": "Successfully logged out"}
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#   Usually these files are written by a python script from a template
#   before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
# Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
# uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
# poetry.lock
# poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
# pdm.lock
# pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
# pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# Redis
*.rdb
*.aof
*.pid

# RabbitMQ
mnesia/
rabbitmq/
rabbitmq-data/

# ActiveMQ
activemq-data/

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#   JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#   be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#   and can be added to the global gitignore or merged into this file.  For a more nuclear
#   option (not recommended) you can uncomment the following to ignore the entire idea folder.
# .idea/

# Abstra
#   Abstra is an AI-powered process automation framework.
#   Ignore directories containing user credentials, local state, and settings.
#   Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#   Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#   that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#   and can be added to the global gitignore or merged into this file. However, if you prefer, 
#   you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Streamlit
.streamlit/secrets.toml
</file>

<file path="Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Установка зависимостей
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Копирование requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование приложения
COPY . .

# Запуск приложения
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="env.example">
# ====================================================================
# FastAPI Authentication & Authorization System
# Пример конфигурационного файла
# ====================================================================

# -------- DATABASE --------
# PostgreSQL асинхронное подключение
# Формат: postgresql+asyncpg://user:password@host:port/database
DATABASE_URL=postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db

# Redis для кэширования и сессий
REDIS_URL=redis://localhost:6379/0

# -------- JWT SETTINGS --------
# Секретный ключ для подписи JWT токенов
# Минимум 32 символа, используйте: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-super-secret-key-minimum-32-characters-long-generate-it-securely

# Алгоритм подписи JWT
ALGORITHM=HS256

# Время жизни access токена в минутах
ACCESS_TOKEN_EXPIRE_MINUTES=15

# Время жизни refresh токена в днях
REFRESH_TOKEN_EXPIRE_DAYS=7

# -------- SMS SERVICE --------
# Выбор провайдера SMS
# Опции: sms_ru, twilio, aws_sns, sendpulse
SMS_SERVICE_PROVIDER=sms_ru

# API ключ для SMS сервиса
# Получите на https://sms.ru или у выбранного провайдера
SMS_API_KEY=your_sms_api_key_here

# Имя отправителя для SMS (максимум 11 символов)
SMS_FROM_NAME=YourApp

# Максимальное количество попыток ввода SMS кода
SMS_MAX_ATTEMPTS=3

# Время действия SMS кода в минутах
SMS_CODE_EXPIRY_MINUTES=10

# -------- OAUTH2 / OPENID CONNECT --------
# URL банковского API (согласно ФАПИ Банка России)
BANK_API_URL=https://vbank.open.bankingapi.ru

# Client ID от банка для OAuth2
BANK_CLIENT_ID=your_bank_client_id_here

# Client Secret от банка для OAuth2
BANK_CLIENT_SECRET=your_bank_client_secret_here

# Redirect URI для OAuth2 callback
# Должен совпадать с зарегистрированным в банке
BANK_REDIRECT_URI=http://localhost:8000/auth/oauth/callback

# Scope для доступа к банковским данным
# Опции: openid, profile, accounts, transactions, payments
BANK_SCOPES=openid profile accounts

# -------- EMAIL SETTINGS --------
# SMTP сервер для отправки email
SMTP_SERVER=smtp.gmail.com

# Порт SMTP
SMTP_PORT=587

# Email адрес отправителя
SMTP_USER=your_email@gmail.com

# Пароль приложения Gmail (не основной пароль!)
# Используйте: https://myaccount.google.com/apppasswords
SMTP_PASSWORD=your_app_password_here

# Email для отправки писем с подтверждением
FROM_EMAIL=noreply@yourapp.com

# -------- APPLICATION SETTINGS --------
# Frontend URL для перенаправлений
FRONTEND_URL=http://localhost:3000

# Окружение приложения (development, staging, production)
ENVIRONMENT=development

# Режим отладки (включает более подробные логи)
DEBUG=True

# -------- SECURITY --------
# Требовать HTTPS в production
REQUIRE_HTTPS=False  # Установите True в production

# CORS разрешенные домены (comma-separated)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000

# -------- LOGGING --------
# Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Директория для логов
LOG_DIR=./logs

# -------- RATE LIMITING --------
# Включить rate limiting
RATE_LIMITING_ENABLED=True

# Максимум запросов в минуту для анонимных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Максимум запросов в минуту для авторизованных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE_AUTHENTICATED=100

# -------- MONITORING --------
# Включить Prometheus метрики
PROMETHEUS_ENABLED=False

# -------- OPTIONAL SETTINGS --------
# Максимальный размер запроса в MB
MAX_REQUEST_SIZE=10

# Таймаут для подключения к внешним сервисам (секунды)
EXTERNAL_SERVICE_TIMEOUT=30

# Количество рабочих процессов Uvicorn
WORKERS=4

# ====================================================================
# ИНСТРУКЦИИ ПО ПОЛУЧЕНИЮ ЗНАЧЕНИЙ
# ====================================================================

# 1. SECRET_KEY:
#    python -c "import secrets; print(secrets.token_urlsafe(32))"

# 2. SMS_API_KEY (sms.ru):
#    - Перейти на https://sms.ru
#    - Зарегистрироваться
#    - Получить API ID в личном кабинете
#    - Добавить номер в доверенные

# 3. BANK_CLIENT_ID и BANK_CLIENT_SECRET:
#    - Обратиться к банку (Сбербанк, ВТБ, и т.д.)
#    - Получить учетные данные OAuth2
#    - Согласовать redirect_uri

# 4. SMTP_PASSWORD (Gmail):
#    - Перейти на https://myaccount.google.com/apppasswords
#    - Выбрать приложение "Mail" и устройство "Windows/Mac/Linux"
#    - Скопировать сгенерированный пароль

# 5. BANK_REDIRECT_URI:
#    - В development: http://localhost:8000/auth/oauth/callback
#    - В production: https://yourdomain.com/auth/oauth/callback

# ====================================================================
# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
# ====================================================================

# Для разработки используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/fastapi_dev
# DEBUG=True
# ENVIRONMENT=development

# Для staging используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@staging-db:5432/fastapi_staging
# DEBUG=False
# ENVIRONMENT=staging
# REQUIRE_HTTPS=True

# Для production используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@prod-db:5432/fastapi_prod
# DEBUG=False
# ENVIRONMENT=production
# REQUIRE_HTTPS=True
# RATE_LIMITING_ENABLED=True
# PROMETHEUS_ENABLED=True

# ====================================================================
# БЕЗОПАСНОСТЬ
# ====================================================================

# ⚠️ НИКОГДА не коммитьте этот файл в git, если в нем реальные значения!
# Используйте: git update-index --assume-unchanged .env

# ✅ Рекомендуемые настройки для .gitignore:
# .env
# .env.local
# .env.*.local
# .env.production

# ✅ Для разработки скопируйте этот файл:
# cp .env.example .env

# ✅ Для production используйте переменные окружения системы:
# export SECRET_KEY=your-secret-key
# export DATABASE_URL=postgresql+asyncpg://...

# ====================================================================
</file>

<file path="main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.auth_router import router as auth_router
from app.users_router import router as users_router
from app.database import engine
from app.models import Base
import uvicorn



@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown
    await engine.dispose()

app = FastAPI(
    title="FastAPI Authentication API",
    description="Complete registration and OAuth2 integration",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:5173",
                   "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(auth_router)
app.include_router(users_router)

@app.get("/health")
async def health_check():
    return {"status": "ok"}
</file>

<file path="README.md">
# VTB_API_HACK
</file>

<file path="app/security/oauth2.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.security.jwt_handler import decode_token

security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> int:
    token = credentials.credentials
    user_id = decode_token(token)
    
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )
    
    return user_id
</file>

<file path="app/security/password.py">
from passlib.context import CryptContext
from passlib.exc import InvalidHashError

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except (InvalidHash, ValueError):
        return False
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: fastapi_user
      POSTGRES_PASSWORD: fastapi_password
      POSTGRES_DB: fastapi_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U fastapi_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://fastapi_user:fastapi_password@postgres:5432/fastapi_db
      REDIS_URL: redis://redis:6379/0
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app

volumes:
  postgres_data:
</file>

<file path="requirements.txt">
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9
python-dotenv==1.0.0
pydantic==2.5.0
pydantic-settings==2.1.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
httpx==0.25.2
aioredis==2.0.1
celery==5.3.4
redis==5.0.1
requests==2.31.0
email-validator==2.1.0
bcrypt==4.0.1
passlib==1.7.4
asyncpg==0.30.0
aiohttp==3.13.2
</file>

<file path="app/auth_router.py">
import secrets
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.schemas import UserRegister, UserResponse, SMSVerificationRequest, SMSVerificationConfirm
from app.auth_schemas import TokenResponse, TokenRequest, RefreshTokenRequest
from app.models import User
from app.database import get_db
from app.services.sms_service import sms_service
from app.services.oauth_service import oauth_service
from app.services.bank_oauth_service import oauth_bank_service
from app.security.password import hash_password, verify_password
from app.security.jwt_handler import create_access_token, create_refresh_token, decode_token
from app.config import get_settings
from datetime import datetime, timedelta
import logging

router = APIRouter(prefix="/auth", tags=["auth"])
settings = get_settings()
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register(user_data: UserRegister, db: AsyncSession = Depends(get_db)):
    """Регистрация пользователя"""
    # Проверка существования пользователя
    result = await db.execute(
        select(User).where((User.email == user_data.email) | (User.phone_number == user_data.phone_number))
    )
    if result.scalars().first():
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email или номер телефона уже зарегистрирован"
        )
    
    # Создание пользователя
    user = User(
        email=user_data.email,
        phone_number=user_data.phone_number,
        first_name=user_data.first_name,
        last_name=user_data.last_name,
        hashed_password=hash_password(user_data.password),
        is_active=False
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    
    # Отправка SMS кода
    sms_sent = await sms_service.send_registration_code(user_data.phone_number, db)
    if not sms_sent:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ошибка отправки SMS"
        )
    
    return UserResponse.from_orm(user)

@router.post("/verify-sms")
async def verify_sms(data: SMSVerificationConfirm, db: AsyncSession = Depends(get_db)):
    """Проверка SMS кода"""
    
    # Проверка кода
    verified = await sms_service.verify_sms_code(data.phone_number, data.code, db)
    if not verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Неверный или истекший код"
        )
    
    # Обновление пользователя
    result = await db.execute(select(User).where(User.phone_number == data.phone_number))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_phone_verified = True
    user.is_active = True
    await db.commit()
    
    return {"message": "Номер телефона успешно подтвержден"}

@router.post("/login", response_model=TokenResponse)
async def login(credentials: TokenRequest, db: AsyncSession = Depends(get_db)):
    """Вход в систему"""
    
    result = await db.execute(select(User).where(User.email == credentials.email))
    user = result.scalars().first()
    
    if not user or not verify_password(credentials.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Генерация токенов
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token(user.id)
    
    # Обновление последнего входа
    user.last_login = datetime.utcnow()
    await db.commit()
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh(request: RefreshTokenRequest, db: AsyncSession = Depends(get_db)):
    """Обновление access токена"""
    
    user_id = decode_token(request.refresh_token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )
    
    access_token = create_access_token({"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=request.refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.get("/oauth/authorize")
async def oauth_authorize(db: AsyncSession = Depends(get_db)):
    """
    Инициирование OAuth flow с полным циклом получения банковских данных
    
    НОВЫЙ АЛГОРИТМ (vbank.open.bankingapi.ru):
    1. Получить токен банка
    2. Запросить согласие (авто-одобрение)
    3. Получить данные счетов
    """
    try:
        logger.info("Starting OAuth authorize flow...")
        
        # Генерируем временный ID для отслеживания сессии
        session_id = secrets.token_urlsafe(16)
        logger.info(f"Session ID: {session_id}")
        
        # ============ НОВАЯ ЛОГИКА: Полный цикл работы с банком ============
        
        # Выполняем полный цикл получения банковских счетов
        logger.info("Executing full bank account retrieval cycle...")
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            logger.error(f"Bank cycle failed: {bank_data.get('error')}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Failed to retrieve bank data: {bank_data.get('error')}"
            )
        
        # Извлекаем данные из успешного ответа
        bills = bank_data.get("bills")
        consent_id = bank_data.get("consent_id")
        auto_approved = bank_data.get("auto_approved", True)
        
        logger.info(f"Successfully retrieved {len(bills)} accounts")
        logger.info(f"Consent ID: {consent_id}, Auto-approved: {auto_approved}")
        
        # Сохраняем в сессию для дальнейшего использования
        # Это можно использовать при создании пользователя
        session_data = {
            "bank_accounts": bills,
            "consent_id": consent_id,
            "auto_approved": auto_approved,
            "retrieved_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"Session data prepared: {session_data}")
        
        # Перенаправляем на банк для авторизации пользователя
        # (или если банк уже авторизовал, перенаправляем на callback)
        auth_url = oauth_service.generate_authorization_url(session_id)
        
        logger.info(f"Redirecting to bank authorization URL")
        return RedirectResponse(url=auth_url)
        
    except Exception as e:
        logger.error(f"Error in oauth_authorize: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth authorization failed: {str(e)}"
        )

@router.get("/oauth/callback")
async def oauth_callback(code: str, state: str, db: AsyncSession = Depends(get_db)):
    """
    Callback от банка после авторизации пользователя
    На этом этапе мы уже имеем:
    - Данные счетов пользователя
    - Согласие на доступ
    - Информацию о пользователе
    """
    try:
        logger.info(f"OAuth callback received with state: {state}")
        
        # Валидация состояния
        oauth_session = await oauth_service.validate_oauth_state(state, db)
        if not oauth_session:
            logger.error(f"Invalid OAuth state: {state}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state"
            )
        
        # Обмен кода на токен у банка
        logger.info("Exchanging authorization code for token...")
        token_response = await oauth_service.exchange_code_for_token(
            code, 
            oauth_session["code_verifier"]
        )
        
        if not token_response:
            logger.error("Failed to exchange code for token")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to exchange code for token"
            )
        
        # Получение информации о пользователе от банка
        logger.info("Retrieving user info from bank...")
        user_info = await oauth_service.get_user_info(token_response.get("access_token"))
        
        if not user_info:
            logger.error("Failed to get user info")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to get user info"
            )
        
        # Поиск или создание пользователя
        oauth_id = user_info.get("sub")
        logger.info(f"Looking up user with oauth_id: {oauth_id}")
        
        result = await db.execute(
            select(User).where((User.oauth_id == oauth_id) | (User.email == user_info.get("email")))
        )
        user = result.scalars().first()
        
        if not user:
            logger.info(f"Creating new user from OAuth info")
            user = User(
                email=user_info.get("email"),
                phone_number=user_info.get("phone_number", ""),
                first_name=user_info.get("given_name", ""),
                last_name=user_info.get("family_name", ""),
                oauth_provider="bank",
                oauth_id=oauth_id,
                is_active=True,
                is_phone_verified=True,
                is_email_verified=True,
                hashed_password=hash_password(secrets.token_urlsafe(32))
            )
            db.add(user)
            await db.commit()
            await db.refresh(user)
            logger.info(f"New user created: {user.id}")
        else:
            logger.info(f"Existing user found: {user.id}")
        
        # Генерация токенов
        logger.info("Generating access and refresh tokens...")
        access_token = create_access_token({"sub": str(user.id)})
        refresh_token = create_refresh_token(user.id)
        
        logger.info(f"OAuth callback completed successfully for user {user.id}")
        
        # Перенаправление на фронтенд с токенами
        redirect_url = f"{settings.FRONTEND_URL}/auth/success?access_token={access_token}&refresh_token={refresh_token}"
        return RedirectResponse(url=redirect_url)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in oauth_callback: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth callback failed: {str(e)}"
        )

@router.get("/oauth/bank-bills")
async def get_oauth_bank_accounts(db: AsyncSession = Depends(get_db)):
    """
    Эндпоинт для получения банковских счетов пользователя через OAuth
    Использует полный цикл получения данных от банка
    """
    try:
        logger.info("Getting bank accounts through full OAuth cycle...")
        
        # Можно передать реальный user_id вместо session_id
        session_id = secrets.token_urlsafe(16)
        
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=bank_data.get("error")
            )
        
        return {
            "success": True,
            "accounts": bank_data.get("accounts", []),
            "consent_id": bank_data.get("consent_id"),
            "auto_approved": bank_data.get("auto_approved", True)
        }
        
    except Exception as e:
        logger.error(f"Error getting bank accounts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get bank accounts: {str(e)}"
        )
</file>

<file path="app/config.py">
from pydantic_settings import BaseSettings
from typing import Optional
import uuid
from functools import lru_cache

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db"
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # JWT
    SECRET_KEY: str = "aMeucfHi2Xxl3v0LYb1Tcduk-NuQOOjGVrTxqhDrT0A"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # SMS
    SMS_SERVICE_PROVIDER: str = "sms_ru"
    SMS_API_KEY: uuid.UUID = uuid.UUID("18608A37-567C-3C70-F128-03938B6AF52A")
    SMS_FROM_NAME: str = "YourApp"
    
    # OAuth2
    BANK_API_URL: str = "https://vbank.open.bankingapi.ru"
    BANK_CLIENT_ID: str = "team261-1"
    BANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    BANK_REDIRECT_URI: str = "https://vbank.open.bankingapi.ru/client"
    '''
    # Frontend
    FRONTEND_URL: str
    '''
    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings():
    return Settings()
</file>

</files>
