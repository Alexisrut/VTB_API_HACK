This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  security/
    __init__.py
    jwt_handler.py
    oauth2.py
    password.py
  services/
    bank_oauth_service.py
    oauth_service.py
    sms_service.py
    universal_bank_service.py
  utils/
    __init__.py
    exceptions.py
    validators.py
  __init__.py
  auth_router.py
  auth_schemas.py
  bank_api_router.py
  bank_schemas.py
  config.py
  database.py
  models.py
  schemas.py
  users_router.py
.gitignore
backend.txt
docker-compose.yml
Dockerfile
env.example
main.py
README.md
requirements.txt
vtb_api_hack.session.sql
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/bank_schemas.py">
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any


class BalanceAmount(BaseModel):
    amount: str
    currency: str


class BankBalanceSchema(BaseModel):
    balanceAmount: BalanceAmount
    balanceType: str
    creditDebitIndicator: str


class AccountDetails(BaseModel):
    schemeName: Optional[str] = None
    identification: Optional[str] = None
    name: Optional[str] = None
    secondaryIdentification: Optional[str] = None


class BankAccountSchema(BaseModel):
    account_id: str
    account_type: Optional[str] = None
    currency: Optional[str] = None
    nickname: Optional[str] = None
    account: Optional[AccountDetails] = None
    balances: Optional[List[BankBalanceSchema]] = None


class GetBankAccountsResponse(BaseModel):
    success: bool
    accounts: List[BankAccountSchema]
    consent_id: Optional[str] = None
    auto_approved: Optional[bool] = None


class TransactionAmount(BaseModel):
    amount: str
    currency: str


class RemittanceInformation(BaseModel):
    unstructured: Optional[str] = None


class BankTransactionSchema(BaseModel):
    transactionId: str
    transactionReference: Optional[str] = None
    amount: TransactionAmount
    creditDebitIndicator: str
    status: str
    bookingDateTime: Optional[str] = None
    valueDateTime: Optional[str] = None
    transactionInformation: Optional[str] = None
    creditorName: Optional[str] = None
    debtorName: Optional[str] = None
    remittanceInformation: Optional[RemittanceInformation] = None


class GetBankTransactionsResponse(BaseModel):
    success: bool
    account_id: str
    transactions: List[BankTransactionSchema]
    total_count: int


class GetBankBalanceHistoryResponse(BaseModel):
    success: bool
    account_id: str
    balances: List[BankBalanceSchema]
</file>

<file path="app/security/__init__.py">

</file>

<file path="app/security/jwt_handler.py">
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.config import get_settings

settings = get_settings()

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(user_id: int) -> str:
    data = {
        "sub": str(user_id),
        "type": "refresh"
    }
    expires_delta = timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    return create_access_token(data, expires_delta)

def verify_token(token: str) -> Optional[Dict[str, Any]]:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None

def decode_token(token: str) -> Optional[int]:
    payload = verify_token(token)
    if payload:
        user_id = payload.get("sub")
        if user_id:
            return int(user_id)
    return None
</file>

<file path="app/services/universal_bank_service.py">
import aiohttp
import secrets
import logging
from datetime import datetime, timedelta
from typing import Optional, Dict, List, Any
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.config import get_settings, BankConfig
from app.models import OAuthSession, User

settings = get_settings()
logger = logging.getLogger(__name__)


class UniversalBankAPIService:
    """
    Универсальный сервис для работы с Open Banking API трёх банков:
    - Virtual Bank (vbank.open.bankingapi.ru)
    - Awesome Bank (abank.open.bankingapi.ru)
    - Smart Bank (sbank.open.bankingapi.ru)
    
    Все методы принимают bank_code как параметр для выбора банка
    """
    
    def __init__(self):
        self.settings = get_settings()
    
    def _get_bank_config(self, bank_code: str) -> BankConfig:
        """Получить конфигурацию банка по коду"""
        return self.settings.get_bank_config(bank_code)
    
    # ==================== АУТЕНТИФИКАЦИЯ ====================
    
    async def get_bank_access_token(self, bank_code: str) -> Optional[str]:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://{bank}.open.bankingapi.ru/auth/bank-token
        ?client_id={client_id}&client_secret={client_secret}
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Returns:
            str: access_token или None при ошибке
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/auth/bank-token"
                params = {
                    "client_id": bank.client_id,
                    "client_secret": bank.client_secret
                }
                
                logger.info(f"[{bank_code}] Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info(f"[{bank_code}] Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting bank token: {e}")
            return None
    
    # ==================== СОГЛАСИЯ (CONSENTS) ====================
    
    async def request_account_consent(
        self, 
        bank_code: str,
        access_token: str, 
        user_id: str,
        permissions: Optional[List[str]] = None
    ) -> Optional[Dict]:
        """
        Запросить согласие на доступ к счетам пользователя
        
        POST https://{bank}.open.bankingapi.ru/account-consents/request
        
        Args:
            bank_code: Код банка
            access_token: Токен банка
            user_id: ID пользователя
            permissions: Список разрешений (по умолчанию ReadAccountsDetail, ReadBalances)
        
        Returns:
            dict: {"status": "approved", "consent_id": "...", "auto_approved": true}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            if permissions is None:
                permissions = ["ReadAccountsDetail", "ReadBalances"]
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": permissions,
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": bank.requesting_bank,
                    "requesting_bank_name": bank.requesting_bank_name
                }
                
                logger.info(f"[{bank_code}] Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Consent received: {data.get('consent_id')}")
                        return {
                            "status": data.get("status", "approved"),
                            "consent_id": data.get("consent_id"),
                            "auto_approved": data.get("auto_approved", True)
                        }
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to request consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error requesting consent: {e}")
            return None
    
    async def get_consent_details(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить детали согласия
        
        GET https://{bank}.open.bankingapi.ru/account-consents/{consent_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/{consent_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Getting consent details: {consent_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Consent details retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting consent details: {e}")
            return None
    
    async def delete_consent(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str
    ) -> bool:
        """
        Удалить согласие
        
        DELETE https://{bank}.open.bankingapi.ru/account-consents/{consent_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/account-consents/{consent_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Deleting consent: {consent_id}")
                async with session.delete(url, headers=headers) as resp:
                    if resp.status in [200, 204]:
                        logger.info(f"[{bank_code}] Consent deleted successfully")
                        return True
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to delete consent: {resp.status} - {error_text}")
                        return False
        except Exception as e:
            logger.error(f"[{bank_code}] Error deleting consent: {e}")
            return False
    
    # ==================== СЧЕТА (ACCOUNTS) ====================
    
    async def get_accounts(
        self,
        bank_code: str,
        access_token: str,
        user_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить список счетов пользователя
        
        GET https://{bank}.open.bankingapi.ru/accounts?client_id={client_id}
        
        Args:
            bank_code: Код банка
            access_token: Токен банка
            user_id: ID пользователя
            consent_id: ID согласия
        
        Returns:
            dict: {"accounts": [...]}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"[{bank_code}] Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Successfully fetched {len(data.get('accounts', []))} accounts")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error fetching accounts: {e}")
            return None
    
    async def get_account_details(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить детали конкретного счета
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id
                }
                
                logger.info(f"[{bank_code}] Getting account details: {account_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Account details retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get account details: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting account details: {e}")
            return None
    
    # ==================== БАЛАНСЫ (BALANCES) ====================
    
    async def get_account_balances(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str
    ) -> Optional[Dict]:
        """
        Получить балансы счета
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}/balances
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}/balances"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id
                }
                
                logger.info(f"[{bank_code}] Getting balances for account: {account_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Balances retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get balances: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting balances: {e}")
            return None
    
    # ==================== ТРАНЗАКЦИИ (TRANSACTIONS) ====================
    
    async def get_account_transactions(
        self,
        bank_code: str,
        access_token: str,
        account_id: str,
        consent_id: str,
        from_date: Optional[str] = None,
        to_date: Optional[str] = None
    ) -> Optional[Dict]:
        """
        Получить транзакции по счету
        
        GET https://{bank}.open.bankingapi.ru/accounts/{account_id}/transactions
        
        Args:
            from_date: Дата начала в формате YYYY-MM-DD
            to_date: Дата конца в формате YYYY-MM-DD
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/accounts/{account_id}/transactions"
                
                params = {}
                if from_date:
                    params["fromBookingDateTime"] = from_date
                if to_date:
                    params["toBookingDateTime"] = to_date
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id
                }
                
                logger.info(f"[{bank_code}] Getting transactions for account: {account_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Transactions retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get transactions: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting transactions: {e}")
            return None
    
    # ==================== ПЛАТЕЖИ (PAYMENTS) ====================
    
    async def create_payment_consent(
        self,
        bank_code: str,
        access_token: str,
        user_id: str,
        payment_data: Dict
    ) -> Optional[Dict]:
        """
        Создать согласие на платеж
        
        POST https://{bank}.open.bankingapi.ru/payment-consents
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payment-consents"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{bank.requesting_bank}-{user_id}",
                    **payment_data
                }
                
                logger.info(f"[{bank_code}] Creating payment consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment consent created: {data.get('consentId')}")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to create payment consent: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error creating payment consent: {e}")
            return None
    
    async def initiate_payment(
        self,
        bank_code: str,
        access_token: str,
        consent_id: str,
        payment_data: Dict
    ) -> Optional[Dict]:
        """
        Инициировать платеж
        
        POST https://{bank}.open.bankingapi.ru/payments
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payments"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Content-Type": "application/json"
                }
                
                logger.info(f"[{bank_code}] Initiating payment with consent {consent_id}")
                async with session.post(url, json=payment_data, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment initiated: {data.get('paymentId')}")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to initiate payment: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error initiating payment: {e}")
            return None
    
    async def get_payment_status(
        self,
        bank_code: str,
        access_token: str,
        payment_id: str
    ) -> Optional[Dict]:
        """
        Получить статус платежа
        
        GET https://{bank}.open.bankingapi.ru/payments/{payment_id}
        """
        try:
            bank = self._get_bank_config(bank_code)
            
            async with aiohttp.ClientSession() as session:
                url = f"{bank.api_url}/payments/{payment_id}"
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": bank.requesting_bank
                }
                
                logger.info(f"[{bank_code}] Getting payment status: {payment_id}")
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"[{bank_code}] Payment status retrieved")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{bank_code}] Failed to get payment status: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{bank_code}] Error getting payment status: {e}")
            return None
    
    # ==================== КОМПЛЕКСНЫЕ МЕТОДЫ ====================
    
    async def get_all_accounts_full_cycle(
        self,
        bank_code: str,
        user_id: str
    ) -> Dict:
        """
        Выполнить полный цикл получения счетов для одного банка:
        1. Получить access token банка
        2. Запросить согласие
        3. Получить счета
        
        Returns:
            dict: {"success": True/False, "accounts": [...], "consent_id": "...", "error": "..."}
        """
        try:
            logger.info(f"[{bank_code}] STARTING FULL CYCLE for user {user_id}")
            
            # ШАГ 1: Получить токен банка
            logger.info(f"[{bank_code}] STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token(bank_code)
            
            if not access_token:
                return {
                    "success": False,
                    "error": f"Failed to obtain bank access token from {bank_code}"
                }
            
            # ШАГ 2: Запросить согласие
            logger.info(f"[{bank_code}] STEP 2: Requesting account consent...")
            consent_data = await self.request_account_consent(bank_code, access_token, user_id)
            
            if not consent_data:
                return {
                    "success": False,
                    "error": f"Failed to request account consent from {bank_code}"
                }
            
            consent_id = consent_data.get("consent_id")
            
            # ШАГ 3: Получить счета
            logger.info(f"[{bank_code}] STEP 3: Fetching user accounts...")
            accounts_data = await self.get_accounts(bank_code, access_token, user_id, consent_id)
            
            if not accounts_data:
                return {
                    "success": False,
                    "error": f"Failed to fetch accounts from {bank_code}"
                }
            
            logger.info(f"[{bank_code}] FULL CYCLE COMPLETED SUCCESSFULLY")
            return {
                "success": True,
                "bank_code": bank_code,
                "accounts": accounts_data.get("accounts", []),
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True)
            }
        
        except Exception as e:
            logger.error(f"[{bank_code}] Error in full cycle: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_accounts_from_all_banks(
        self,
        user_id: str,
        bank_codes: Optional[List[str]] = None
    ) -> Dict[str, Dict]:
        """
        Получить счета из всех банков (или выбранных)
        
        Args:
            user_id: ID пользователя
            bank_codes: Список кодов банков (если None - все банки)
        
        Returns:
            dict: {
              "vbank": {"success": True, "accounts": [...]},
              "abank": {"success": True, "accounts": [...]},
              "sbank": {"success": False, "error": "..."}
            }
        """
        if bank_codes is None:
            bank_codes = ["vbank", "abank", "sbank"]
        
        results = {}
        
        for bank_code in bank_codes:
            logger.info(f"Processing bank: {bank_code}")
            result = await self.get_all_accounts_full_cycle(bank_code, user_id)
            results[bank_code] = result
        
        return results


# Глобальный экземпляр сервиса
universal_bank_service = UniversalBankAPIService()
</file>

<file path="app/utils/__init__.py">

</file>

<file path="app/utils/exceptions.py">
from fastapi import HTTPException, status

class UserAlreadyExists(HTTPException):
    def __init__(self, detail: str = "User already exists"):
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
        )

class InvalidCredentials(HTTPException):
    def __init__(self, detail: str = "Invalid email or password"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )

class UserNotActive(HTTPException):
    def __init__(self, detail: str = "User is not active"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )

class SMSError(HTTPException):
    def __init__(self, detail: str = "SMS sending error"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail
        )

class InvalidToken(HTTPException):
    def __init__(self, detail: str = "Invalid or expired token"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )
</file>

<file path="app/utils/validators.py">
import re

def validate_password_strength(password: str) -> tuple[bool, str]:
    """Проверка надежности пароля"""
    if len(password) < 8:
        return False, "Пароль должен быть минимум 8 символов"
    
    if not re.search(r'[A-Z]', password):
        return False, "Пароль должен содержать заглавные буквы"
    
    if not re.search(r'[a-z]', password):
        return False, "Пароль должен содержать строчные буквы"
    
    if not re.search(r'\d', password):
        return False, "Пароль должен содержать цифры"
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "Пароль должен содержать спецсимволы"
    
    return True, "OK"

def validate_email_format(email: str) -> bool:
    """Проверка формата email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_phone_format(phone: str) -> bool:
    """Проверка формата телефона"""
    pattern = r'^\+7\d{10}$'
    return re.match(pattern, phone) is not None

def is_email_valid(email: str) -> bool:
    """Расширенная проверка email"""
    return validate_email_format(email)
</file>

<file path="app/__init__.py">

</file>

<file path="app/auth_schemas.py">
from pydantic import BaseModel, Field

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int

class TokenRequest(BaseModel):
    email: str
    password: str

class RefreshTokenRequest(BaseModel):
    refresh_token: str

class OAuth2AuthRequest(BaseModel):
    state: str
    code_verifier: str
    provider: str = "bank"

class OAuthCallbackResponse(BaseModel):
    authorization_code: str
    state: str
</file>

<file path="app/bank_api_router.py">
from fastapi import APIRouter, HTTPException, status, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, List
from datetime import datetime
import logging

from app.database import get_db
from app.security.oauth2 import get_current_user
from app.services.universal_bank_service import universal_bank_service
from app.bank_schemas import (
    GetBankAccountsResponse,
    BankAccountSchema,
    BankTransactionSchema,
    BankBalanceSchema,
    GetBankTransactionsResponse,
    GetBankBalanceHistoryResponse
)

router = APIRouter(prefix="/api/v1/banks", tags=["Open Banking API"])
logger = logging.getLogger(__name__)

# ==================== ПОЛУЧЕНИЕ СЧЕТОВ ====================

@router.get("/accounts", response_model=GetBankAccountsResponse)
async def get_user_accounts(
    bank_code: str = Query(..., description="Код банка: vbank, abank, sbank"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить список счетов пользователя из конкретного банка
    
    **Параметры:**
    - **bank_code**: Код банка ('vbank', 'abank', 'sbank')
    
    **Возвращает:**
    - Список счетов с балансами
    """
    try:
        logger.info(f"User {user_id} requesting accounts from {bank_code}")
        
        result = await universal_bank_service.get_all_accounts_full_cycle(
            bank_code=bank_code,
            user_id=str(user_id)
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result.get("error", "Failed to fetch accounts")
            )
        
        return GetBankAccountsResponse(
            success=True,
            accounts=[BankAccountSchema(**acc) for acc in result.get("accounts", [])],
            consent_id=result.get("consent_id"),
            auto_approved=result.get("auto_approved")
        )
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error getting accounts: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.get("/accounts/all")
async def get_accounts_from_all_banks(
    user_id: int = Depends(get_current_user),
    banks: Optional[List[str]] = Query(None, description="Список банков (vbank,abank,sbank)"),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить счета из всех банков или выбранных
    
    **Параметры:**
    - **banks**: Список кодов банков (если не указано - все банки)
    
    **Возвращает:**
    - Счета из каждого банка с флагами успешности
    """
    try:
        logger.info(f"User {user_id} requesting accounts from multiple banks")
        
        results = await universal_bank_service.get_accounts_from_all_banks(
            user_id=str(user_id),
            bank_codes=banks
        )
        
        # Форматируем ответ
        response = {
            "success": True,
            "banks": {}
        }
        
        total_accounts = 0
        for bank_code, bank_result in results.items():
            if bank_result.get("success"):
                accounts = bank_result.get("accounts", [])
                total_accounts += len(accounts)
                response["banks"][bank_code] = {
                    "success": True,
                    "accounts": accounts,
                    "consent_id": bank_result.get("consent_id"),
                    "count": len(accounts)
                }
            else:
                response["banks"][bank_code] = {
                    "success": False,
                    "error": bank_result.get("error"),
                    "count": 0
                }
        
        response["total_accounts"] = total_accounts
        return response
    
    except Exception as e:
        logger.error(f"Error getting accounts from all banks: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.get("/accounts/{account_id}")
async def get_account_details(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить детальную информацию о конкретном счете
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия
    """
    try:
        # Получаем токен банка
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        # Получаем детали счета
        account_data = await universal_bank_service.get_account_details(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id
        )
        
        if not account_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Account not found"
            )
        
        return {
            "success": True,
            "account": account_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting account details: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== БАЛАНСЫ ====================

@router.get("/accounts/{account_id}/balances")
async def get_account_balances(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить балансы счета
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        balances_data = await universal_bank_service.get_account_balances(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id
        )
        
        if not balances_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Balances not found"
            )
        
        return {
            "success": True,
            "balances": balances_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting balances: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== ТРАНЗАКЦИИ ====================

@router.get("/accounts/{account_id}/transactions", response_model=GetBankTransactionsResponse)
async def get_account_transactions(
    account_id: str,
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия"),
    from_date: Optional[str] = Query(None, description="Дата начала YYYY-MM-DD"),
    to_date: Optional[str] = Query(None, description="Дата конца YYYY-MM-DD"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить транзакции по счету
    
    **Параметры:**
    - **account_id**: ID счета
    - **bank_code**: Код банка
    - **consent_id**: ID согласия
    - **from_date**: Дата начала (опционально)
    - **to_date**: Дата конца (опционально)
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        transactions_data = await universal_bank_service.get_account_transactions(
            bank_code=bank_code,
            access_token=access_token,
            account_id=account_id,
            consent_id=consent_id,
            from_date=from_date,
            to_date=to_date
        )
        
        if not transactions_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Transactions not found"
            )
        
        transactions = transactions_data.get("transactions", [])
        
        return GetBankTransactionsResponse(
            success=True,
            account_id=account_id,
            transactions=[BankTransactionSchema(**tx) for tx in transactions],
            total_count=len(transactions)
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting transactions: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== СОГЛАСИЯ ====================

@router.get("/consents/{consent_id}")
async def get_consent_details(
    consent_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить детали согласия
    
    **Параметры:**
    - **consent_id**: ID согласия
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        consent_data = await universal_bank_service.get_consent_details(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id
        )
        
        if not consent_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Consent not found"
            )
        
        return {
            "success": True,
            "consent": consent_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.delete("/consents/{consent_id}")
async def delete_consent(
    consent_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Удалить согласие
    
    **Параметры:**
    - **consent_id**: ID согласия
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        success = await universal_bank_service.delete_consent(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id
        )
        
        if not success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to delete consent"
            )
        
        return {
            "success": True,
            "message": "Consent deleted successfully"
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== ПЛАТЕЖИ ====================

@router.post("/payments/consents")
async def create_payment_consent(
    bank_code: str = Query(..., description="Код банка"),
    payment_data: dict = None,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Создать согласие на платеж
    
    **Параметры:**
    - **bank_code**: Код банка
    - **payment_data**: Данные платежа
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        consent_data = await universal_bank_service.create_payment_consent(
            bank_code=bank_code,
            access_token=access_token,
            user_id=str(user_id),
            payment_data=payment_data
        )
        
        if not consent_data:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to create payment consent"
            )
        
        return {
            "success": True,
            "consent": consent_data
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating payment consent: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/payments")
async def initiate_payment(
    bank_code: str = Query(..., description="Код банка"),
    consent_id: str = Query(..., description="ID согласия на платеж"),
    payment_data: dict = None,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Инициировать платеж
    
    **Параметры:**
    - **bank_code**: Код банка
    - **consent_id**: ID согласия на платеж
    - **payment_data**: Данные платежа
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        payment_result = await universal_bank_service.initiate_payment(
            bank_code=bank_code,
            access_token=access_token,
            consent_id=consent_id,
            payment_data=payment_data
        )
        
        if not payment_result:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to initiate payment"
            )
        
        return {
            "success": True,
            "payment": payment_result
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error initiating payment: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/payments/{payment_id}")
async def get_payment_status(
    payment_id: str,
    bank_code: str = Query(..., description="Код банка"),
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Получить статус платежа
    
    **Параметры:**
    - **payment_id**: ID платежа
    - **bank_code**: Код банка
    """
    try:
        access_token = await universal_bank_service.get_bank_access_token(bank_code)
        if not access_token:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to obtain bank token"
            )
        
        payment_status = await universal_bank_service.get_payment_status(
            bank_code=bank_code,
            access_token=access_token,
            payment_id=payment_id
        )
        
        if not payment_status:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Payment not found"
            )
        
        return {
            "success": True,
            "payment": payment_status
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting payment status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


# ==================== УТИЛИТЫ ====================

@router.get("/banks/list")
async def list_available_banks():
    """
    Получить список доступных банков
    """
    return {
        "banks": [
            {
                "code": "vbank",
                "name": "Virtual Bank",
                "url": "https://vbank.open.bankingapi.ru"
            },
            {
                "code": "abank",
                "name": "Awesome Bank",
                "url": "https://abank.open.bankingapi.ru"
            },
            {
                "code": "sbank",
                "name": "Smart Bank",
                "url": "https://sbank.open.bankingapi.ru"
            }
        ]
    }


@router.get("/health")
async def health_check():
    """Проверка работоспособности API"""
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat()
    }
</file>

<file path="app/database.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from app.config import get_settings

settings = get_settings()

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=True,
    pool_size=20,
    max_overflow=0
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session
</file>

<file path="app/models.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    is_active = Column(Boolean, default=False)
    is_email_verified = Column(Boolean, default=False)
    is_phone_verified = Column(Boolean, default=False)
    
    sms_code = Column(String(6), nullable=True)
    sms_code_expires_at = Column(DateTime, nullable=True)
    sms_attempts = Column(Integer, default=0)
    
    oauth_provider = Column(String(50), nullable=True)
    oauth_id = Column(String(255), nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    token = Column(Text, unique=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_revoked = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class SMSVerification(Base):
    __tablename__ = "sms_verifications"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    code = Column(String(6), nullable=False)
    attempts = Column(Integer, default=0)
    expires_at = Column(DateTime, nullable=False)
    verified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class OAuthSession(Base):
    __tablename__ = "oauth_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    state = Column(String(255), unique=True, nullable=False)
    code_verifier = Column(String(255), nullable=False)
    provider = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)


class AccessTokenBlacklist(Base):
    __tablename__ = "access_token_blacklist"
    
    id = Column(Integer, primary_key=True, index=True)
    token = Column(String(1000), unique=True, nullable=False)
    user_id = Column(Integer, nullable=False, index=True)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
</file>

<file path="app/schemas.py">
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
import re

class UserBase(BaseModel):
    email: EmailStr = Field(..., description="Email адрес")
    phone_number: str = Field(..., description="Номер телефона в формате +7XXXXXXXXXX")
    first_name: str = Field(..., min_length=2, max_length=100)
    last_name: str = Field(..., min_length=2, max_length=100)
    
    @field_validator("phone_number")
    @classmethod
    def validate_phone(cls, v):
        if not re.match(r'^\+7\d{10}$', v):
            raise ValueError("Номер телефона должен быть в формате +7XXXXXXXXXX")
        return v

class UserRegister(UserBase):
    password: str = Field(..., min_length=8, max_length=50)
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну заглавную букву")
        if not re.search(r'[a-z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну строчную букву")
        if not re.search(r'\d', v):
            raise ValueError("Пароль должен содержать хотя бы одну цифру")
        return v

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_email_verified: bool
    is_phone_verified: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserInDB(UserResponse):
    hashed_password: str

class SMSVerificationRequest(BaseModel):
    phone_number: str
    
class SMSVerificationConfirm(BaseModel):
    phone_number: str
    code: str = Field(..., min_length=6, max_length=6)
</file>

<file path="app/users_router.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import User
from app.schemas import UserResponse
from app.database import get_db
from app.security.oauth2 import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Получение информации о текущем пользователе"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse.from_orm(user)

@router.put("/me", response_model=UserResponse)
async def update_user_profile(
    update_data: dict,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Обновление профиля пользователя"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    for key, value in update_data.items():
        if hasattr(user, key):
            setattr(user, key, value)
    
    await db.commit()
    await db.refresh(user)
    
    return UserResponse.from_orm(user)

@router.post("/logout")
async def logout(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Выход из системы"""
    return {"message": "Successfully logged out"}
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#   Usually these files are written by a python script from a template
#   before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
# Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
# uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
# poetry.lock
# poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
# pdm.lock
# pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
# pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# Redis
*.rdb
*.aof
*.pid

# RabbitMQ
mnesia/
rabbitmq/
rabbitmq-data/

# ActiveMQ
activemq-data/

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#   JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#   be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#   and can be added to the global gitignore or merged into this file.  For a more nuclear
#   option (not recommended) you can uncomment the following to ignore the entire idea folder.
# .idea/

# Abstra
#   Abstra is an AI-powered process automation framework.
#   Ignore directories containing user credentials, local state, and settings.
#   Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#   Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#   that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#   and can be added to the global gitignore or merged into this file. However, if you prefer, 
#   you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Streamlit
.streamlit/secrets.toml
</file>

<file path="backend.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  security/
    __init__.py
    jwt_handler.py
    oauth2.py
    password.py
  services/
    bank_oauth_service.py
    oauth_service.py
    sms_service.py
  utils/
    __init__.py
    exceptions.py
    validators.py
  __init__.py
  auth_router.py
  auth_schemas.py
  config.py
  database.py
  models.py
  schemas.py
  users_router.py
.gitignore
docker-compose.yml
Dockerfile
env.example
main.py
README.md
requirements.txt
vtb_api_hack.session.sql
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="vtb_api_hack.session.sql">
TRUNCATE TABLE users;
SELECT * FROM users;
</file>

<file path="app/security/__init__.py">

</file>

<file path="app/security/jwt_handler.py">
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from app.config import get_settings

settings = get_settings()

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(user_id: int) -> str:
    data = {
        "sub": str(user_id),
        "type": "refresh"
    }
    expires_delta = timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    return create_access_token(data, expires_delta)

def verify_token(token: str) -> Optional[Dict[str, Any]]:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None

def decode_token(token: str) -> Optional[int]:
    payload = verify_token(token)
    if payload:
        user_id = payload.get("sub")
        if user_id:
            return int(user_id)
    return None
</file>

<file path="app/services/bank_oauth_service.py">
import aiohttp
import secrets
from datetime import datetime, timedelta
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.config import get_settings
from app.models import OAuthSession, User
import logging

settings = get_settings()
logger = logging.getLogger(__name__)

class OAuth2BankService:
    def __init__(self):
        self.bank_api_url = settings.BANK_API_URL
        self.client_id = settings.BANK_CLIENT_ID
        self.client_secret = settings.BANK_CLIENT_SECRET
        self.requesting_bank = "team261"  # Или из конфига
        self.requesting_bank_name = "team261 App"
    
    # ============ ШАГ 1: Получение токена банка ============
    async def get_bank_access_token(self) -> str:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://vbank.open.bankingapi.ru/auth/bank-token
        ?client_id=team200&client_secret=YOUR_SECRET
        
        Returns:
            str: access_token для использования в дальнейших запросах
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/auth/bank-token"
                params = {
                    "client_id": self.requesting_bank,
                    "client_secret": self.client_secret
                }
                
                logger.info(f"Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info("Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error getting bank token: {e}")
            return None
    
    # ============ ШАГ 2: Запрос согласия (авто-одобрение) ============
    async def request_account_consent(self, access_token: str, user_id: str) -> dict:
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": ["ReadAccountsDetail", "ReadBalances"],
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": self.requesting_bank,
                    "requesting_bank_name": self.requesting_bank_name
                }
                
                logger.info(f"Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        logger.info(f"Consent received: {data.get('consent_id')}")
                        return {
                            "status": data.get("status", "approved"),
                            "consent_id": data.get("consent_id"),
                            "auto_approved": data.get("auto_approved", True)
                        }
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to request consent {user_id}: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error requesting consent: {e}")
            return None
    
    # ============ ШАГ 3: Получить данные счетов ============
    async def get_user_accounts(self, access_token: str, user_id: str, consent_id: str) -> dict:
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        logger.info(f"Successfully fetched {len(data.get('accounts', []))} accounts")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Error fetching accounts: {e}")
            return None

    async def get_bank_accounts_full_cycle(self, user_id: str) -> dict:
        try:
            # ШАГ 1: Получить токен банка
            logger.info("STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token()
            
            if not access_token:
                return {
                    "success": False,
                    "error": "Failed to obtain bank access token"
                }
            
            # ШАГ 2: Запросить согласие
            logger.info("STEP 2: Requesting account consent...")
            consent_data = await self.request_account_consent(access_token, self.client_id)
            
            if not consent_data:
                return {
                    "success": False,
                    "error": "Failed to request account consent"
                }
            
            consent_id = consent_data.get("consent_id")

            logger.info("STEP 3: Fetching user accounts...")
            accounts_data = await self.get_user_accounts(access_token, self.client_id, consent_id)
            
            if not accounts_data:
                return {
                    "success": False,
                    "error": "Failed to fetch accounts"
                }
            print(accounts_data)
            return {
                "success": True,
                "bills": accounts_data['data']['account'],
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True)
            }
        
        except Exception as e:
            logger.error(f"Error in full cycle: {e}")
            return {
                "success": False,
                "error": str(e)
            }
oauth_bank_service = OAuth2BankService()
</file>

<file path="app/services/oauth_service.py">
import secrets
import aiohttp
from datetime import datetime, timedelta
from urllib.parse import urlencode
from jose import jwt
from sqlalchemy.ext.asyncio import AsyncSession
from app.config import get_settings
from app.models import OAuthSession
from sqlalchemy import select

settings = get_settings()

class OAuth2Service:
    
    async def generate_oauth_state(self, provider: str, db: AsyncSession) -> dict:
        """Генерация состояния для OAuth flow"""
        state = secrets.token_urlsafe(32)
        code_verifier = secrets.token_urlsafe(32)
        
        oauth_session = OAuthSession(
            state=state,
            code_verifier=code_verifier,
            provider=provider,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(oauth_session)
        await db.commit()
        
        return {
            "state": state,
            "code_verifier": code_verifier
        }
    
    def generate_authorization_url(self, state: str) -> str:
        """Генерация URL для перенаправления на банковский API"""
        
        params = {
            "response_type": "code",
            "client_id": settings.BANK_CLIENT_ID,
            "redirect_uri": settings.BANK_REDIRECT_URI,
            "scope": "openid profile accounts",
            "state": state,
            "nonce": secrets.token_urlsafe(16),
            "code_challenge_method": "S256",
        }
        
        return f"{settings.BANK_API_URL}/oauth/authorize?{urlencode(params)}"
    
    async def exchange_code_for_token(self, code: str, code_verifier: str) -> dict:
        """Обмен кода на токен"""
        async with aiohttp.ClientSession() as session:
            data = {
                "grant_type": "authorization_code",
                "code": code,
                "client_id": settings.BANK_CLIENT_ID,
                "client_secret": settings.BANK_CLIENT_SECRET,
                "redirect_uri": settings.BANK_REDIRECT_URI,
                "code_verifier": code_verifier
            }
            
            async with session.post(
                f"{settings.BANK_API_URL}/oauth/token",
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def get_user_info(self, access_token: str) -> dict:
        """Получение информации о пользователе"""
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {access_token}"}
            async with session.get(
                f"{settings.BANK_API_URL}/oauth/userinfo",
                headers=headers
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def validate_oauth_state(self, state: str, db: AsyncSession) -> dict:
        """Валидация состояния OAuth"""
        result = await db.execute(
            select(OAuthSession).where(
                OAuthSession.state == state,
                OAuthSession.expires_at > datetime.utcnow()
            )
        )
        session = result.scalars().first()
        
        if not session:
            return None
        
        return {
            "state": session.state,
            "code_verifier": session.code_verifier,
            "provider": session.provider
        }

oauth_service = OAuth2Service()
</file>

<file path="app/services/sms_service.py">
import aiohttp
import random
from datetime import datetime, timedelta
from app.config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import SMSVerification
from sqlalchemy import select

settings = get_settings()

class SMSService:
    async def send_sms(self, phone_number: str, message: str) -> bool:
        """Отправка SMS через API"""
        try:
            if settings.SMS_SERVICE_PROVIDER == "sms_ru":
                return await self._send_sms_ru(phone_number, message)
            return True
        except Exception as e:
            print(f"SMS error: {e}")
            return False
    
    async def _send_sms_ru(self, phone_number: str, message: str) -> bool:
        """SMS через sms.ru"""
        async with aiohttp.ClientSession() as session:
            data = {
                "api_id": settings.SMS_API_KEY,
                "to": phone_number.lstrip("+"),
                "msg": message,
                "json": 1
            }
            async with session.post("https://sms.ru/sms/send", data=data) as resp:
                result = await resp.json()
                return result.get("status") == "OK"
    
    async def generate_sms_code(self) -> str:
        """Генерация 6-значного кода"""
        return "".join([str(random.randint(0, 9)) for _ in range(6)])
    
    async def send_registration_code(self, phone_number: str, db: AsyncSession) -> bool:
        """Отправка кода регистрации"""
        code = await self.generate_sms_code()
        
        # Сохранить в БД
        sms_verification = SMSVerification(
            phone_number=phone_number,
            code=code,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(sms_verification)
        await db.commit()
        
        message = f"Ваш код подтверждения: {code}. Действителен 10 минут."
        return await self.send_sms(phone_number, message)
    
    async def verify_sms_code(self, phone_number: str, code: str, db: AsyncSession) -> bool:
        """Проверка SMS кода"""
        result = await db.execute(
            select(SMSVerification).where(
                SMSVerification.phone_number == phone_number
            ).order_by(SMSVerification.created_at.desc())
        )
        verification = result.scalars().first()
        
        if not verification:
            return False
        
        if verification.expires_at < datetime.utcnow():
            return False
        
        if verification.attempts >= 3:
            return False
        
        if verification.code != code:
            verification.attempts += 1
            await db.commit()
            return False
        
        verification.verified = True
        await db.commit()
        return True

sms_service = SMSService()
</file>

<file path="app/utils/__init__.py">

</file>

<file path="app/utils/exceptions.py">
from fastapi import HTTPException, status

class UserAlreadyExists(HTTPException):
    def __init__(self, detail: str = "User already exists"):
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
        )

class InvalidCredentials(HTTPException):
    def __init__(self, detail: str = "Invalid email or password"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )

class UserNotActive(HTTPException):
    def __init__(self, detail: str = "User is not active"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )

class SMSError(HTTPException):
    def __init__(self, detail: str = "SMS sending error"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail
        )

class InvalidToken(HTTPException):
    def __init__(self, detail: str = "Invalid or expired token"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
        )
</file>

<file path="app/utils/validators.py">
import re

def validate_password_strength(password: str) -> tuple[bool, str]:
    """Проверка надежности пароля"""
    if len(password) < 8:
        return False, "Пароль должен быть минимум 8 символов"
    
    if not re.search(r'[A-Z]', password):
        return False, "Пароль должен содержать заглавные буквы"
    
    if not re.search(r'[a-z]', password):
        return False, "Пароль должен содержать строчные буквы"
    
    if not re.search(r'\d', password):
        return False, "Пароль должен содержать цифры"
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "Пароль должен содержать спецсимволы"
    
    return True, "OK"

def validate_email_format(email: str) -> bool:
    """Проверка формата email"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_phone_format(phone: str) -> bool:
    """Проверка формата телефона"""
    pattern = r'^\+7\d{10}$'
    return re.match(pattern, phone) is not None

def is_email_valid(email: str) -> bool:
    """Расширенная проверка email"""
    return validate_email_format(email)
</file>

<file path="app/__init__.py">

</file>

<file path="app/auth_schemas.py">
from pydantic import BaseModel, Field

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int

class TokenRequest(BaseModel):
    email: str
    password: str

class RefreshTokenRequest(BaseModel):
    refresh_token: str

class OAuth2AuthRequest(BaseModel):
    state: str
    code_verifier: str
    provider: str = "bank"

class OAuthCallbackResponse(BaseModel):
    authorization_code: str
    state: str
</file>

<file path="app/database.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from app.config import get_settings

settings = get_settings()

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=True,
    pool_size=20,
    max_overflow=0
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session
</file>

<file path="app/models.py">
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    is_active = Column(Boolean, default=False)
    is_email_verified = Column(Boolean, default=False)
    is_phone_verified = Column(Boolean, default=False)
    
    sms_code = Column(String(6), nullable=True)
    sms_code_expires_at = Column(DateTime, nullable=True)
    sms_attempts = Column(Integer, default=0)
    
    oauth_provider = Column(String(50), nullable=True)
    oauth_id = Column(String(255), nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    token = Column(Text, unique=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_revoked = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class SMSVerification(Base):
    __tablename__ = "sms_verifications"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String(20), unique=True, index=True, nullable=False)
    code = Column(String(6), nullable=False)
    attempts = Column(Integer, default=0)
    expires_at = Column(DateTime, nullable=False)
    verified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class OAuthSession(Base):
    __tablename__ = "oauth_sessions"
    
    id = Column(Integer, primary_key=True, index=True)
    state = Column(String(255), unique=True, nullable=False)
    code_verifier = Column(String(255), nullable=False)
    provider = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)


class AccessTokenBlacklist(Base):
    __tablename__ = "access_token_blacklist"
    
    id = Column(Integer, primary_key=True, index=True)
    token = Column(String(1000), unique=True, nullable=False)
    user_id = Column(Integer, nullable=False, index=True)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
</file>

<file path="app/schemas.py">
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
import re

class UserBase(BaseModel):
    email: EmailStr = Field(..., description="Email адрес")
    phone_number: str = Field(..., description="Номер телефона в формате +7XXXXXXXXXX")
    first_name: str = Field(..., min_length=2, max_length=100)
    last_name: str = Field(..., min_length=2, max_length=100)
    
    @field_validator("phone_number")
    @classmethod
    def validate_phone(cls, v):
        if not re.match(r'^\+7\d{10}$', v):
            raise ValueError("Номер телефона должен быть в формате +7XXXXXXXXXX")
        return v

class UserRegister(UserBase):
    password: str = Field(..., min_length=8, max_length=50)
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну заглавную букву")
        if not re.search(r'[a-z]', v):
            raise ValueError("Пароль должен содержать хотя бы одну строчную букву")
        if not re.search(r'\d', v):
            raise ValueError("Пароль должен содержать хотя бы одну цифру")
        return v

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_email_verified: bool
    is_phone_verified: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserInDB(UserResponse):
    hashed_password: str

class SMSVerificationRequest(BaseModel):
    phone_number: str
    
class SMSVerificationConfirm(BaseModel):
    phone_number: str
    code: str = Field(..., min_length=6, max_length=6)
</file>

<file path="app/users_router.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import User
from app.schemas import UserResponse
from app.database import get_db
from app.security.oauth2 import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Получение информации о текущем пользователе"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse.from_orm(user)

@router.put("/me", response_model=UserResponse)
async def update_user_profile(
    update_data: dict,
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Обновление профиля пользователя"""
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    for key, value in update_data.items():
        if hasattr(user, key):
            setattr(user, key, value)
    
    await db.commit()
    await db.refresh(user)
    
    return UserResponse.from_orm(user)

@router.post("/logout")
async def logout(
    user_id: int = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Выход из системы"""
    return {"message": "Successfully logged out"}
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#   Usually these files are written by a python script from a template
#   before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
# Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
# uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
# poetry.lock
# poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
# pdm.lock
# pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
# pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# Redis
*.rdb
*.aof
*.pid

# RabbitMQ
mnesia/
rabbitmq/
rabbitmq-data/

# ActiveMQ
activemq-data/

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#   JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#   be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#   and can be added to the global gitignore or merged into this file.  For a more nuclear
#   option (not recommended) you can uncomment the following to ignore the entire idea folder.
# .idea/

# Abstra
#   Abstra is an AI-powered process automation framework.
#   Ignore directories containing user credentials, local state, and settings.
#   Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#   Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#   that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#   and can be added to the global gitignore or merged into this file. However, if you prefer, 
#   you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Streamlit
.streamlit/secrets.toml
</file>

<file path="Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Установка зависимостей
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Копирование requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование приложения
COPY . .

# Запуск приложения
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="env.example">
# ====================================================================
# FastAPI Authentication & Authorization System
# Пример конфигурационного файла
# ====================================================================

# -------- DATABASE --------
# PostgreSQL асинхронное подключение
# Формат: postgresql+asyncpg://user:password@host:port/database
DATABASE_URL=postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db

# Redis для кэширования и сессий
REDIS_URL=redis://localhost:6379/0

# -------- JWT SETTINGS --------
# Секретный ключ для подписи JWT токенов
# Минимум 32 символа, используйте: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-super-secret-key-minimum-32-characters-long-generate-it-securely

# Алгоритм подписи JWT
ALGORITHM=HS256

# Время жизни access токена в минутах
ACCESS_TOKEN_EXPIRE_MINUTES=15

# Время жизни refresh токена в днях
REFRESH_TOKEN_EXPIRE_DAYS=7

# -------- SMS SERVICE --------
# Выбор провайдера SMS
# Опции: sms_ru, twilio, aws_sns, sendpulse
SMS_SERVICE_PROVIDER=sms_ru

# API ключ для SMS сервиса
# Получите на https://sms.ru или у выбранного провайдера
SMS_API_KEY=your_sms_api_key_here

# Имя отправителя для SMS (максимум 11 символов)
SMS_FROM_NAME=YourApp

# Максимальное количество попыток ввода SMS кода
SMS_MAX_ATTEMPTS=3

# Время действия SMS кода в минутах
SMS_CODE_EXPIRY_MINUTES=10

# -------- OAUTH2 / OPENID CONNECT --------
# URL банковского API (согласно ФАПИ Банка России)
BANK_API_URL=https://vbank.open.bankingapi.ru

# Client ID от банка для OAuth2
BANK_CLIENT_ID=your_bank_client_id_here

# Client Secret от банка для OAuth2
BANK_CLIENT_SECRET=your_bank_client_secret_here

# Redirect URI для OAuth2 callback
# Должен совпадать с зарегистрированным в банке
BANK_REDIRECT_URI=http://localhost:8000/auth/oauth/callback

# Scope для доступа к банковским данным
# Опции: openid, profile, accounts, transactions, payments
BANK_SCOPES=openid profile accounts

# -------- EMAIL SETTINGS --------
# SMTP сервер для отправки email
SMTP_SERVER=smtp.gmail.com

# Порт SMTP
SMTP_PORT=587

# Email адрес отправителя
SMTP_USER=your_email@gmail.com

# Пароль приложения Gmail (не основной пароль!)
# Используйте: https://myaccount.google.com/apppasswords
SMTP_PASSWORD=your_app_password_here

# Email для отправки писем с подтверждением
FROM_EMAIL=noreply@yourapp.com

# -------- APPLICATION SETTINGS --------
# Frontend URL для перенаправлений
FRONTEND_URL=http://localhost:3000

# Окружение приложения (development, staging, production)
ENVIRONMENT=development

# Режим отладки (включает более подробные логи)
DEBUG=True

# -------- SECURITY --------
# Требовать HTTPS в production
REQUIRE_HTTPS=False  # Установите True в production

# CORS разрешенные домены (comma-separated)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000

# -------- LOGGING --------
# Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Директория для логов
LOG_DIR=./logs

# -------- RATE LIMITING --------
# Включить rate limiting
RATE_LIMITING_ENABLED=True

# Максимум запросов в минуту для анонимных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Максимум запросов в минуту для авторизованных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE_AUTHENTICATED=100

# -------- MONITORING --------
# Включить Prometheus метрики
PROMETHEUS_ENABLED=False

# -------- OPTIONAL SETTINGS --------
# Максимальный размер запроса в MB
MAX_REQUEST_SIZE=10

# Таймаут для подключения к внешним сервисам (секунды)
EXTERNAL_SERVICE_TIMEOUT=30

# Количество рабочих процессов Uvicorn
WORKERS=4

# ====================================================================
# ИНСТРУКЦИИ ПО ПОЛУЧЕНИЮ ЗНАЧЕНИЙ
# ====================================================================

# 1. SECRET_KEY:
#    python -c "import secrets; print(secrets.token_urlsafe(32))"

# 2. SMS_API_KEY (sms.ru):
#    - Перейти на https://sms.ru
#    - Зарегистрироваться
#    - Получить API ID в личном кабинете
#    - Добавить номер в доверенные

# 3. BANK_CLIENT_ID и BANK_CLIENT_SECRET:
#    - Обратиться к банку (Сбербанк, ВТБ, и т.д.)
#    - Получить учетные данные OAuth2
#    - Согласовать redirect_uri

# 4. SMTP_PASSWORD (Gmail):
#    - Перейти на https://myaccount.google.com/apppasswords
#    - Выбрать приложение "Mail" и устройство "Windows/Mac/Linux"
#    - Скопировать сгенерированный пароль

# 5. BANK_REDIRECT_URI:
#    - В development: http://localhost:8000/auth/oauth/callback
#    - В production: https://yourdomain.com/auth/oauth/callback

# ====================================================================
# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
# ====================================================================

# Для разработки используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/fastapi_dev
# DEBUG=True
# ENVIRONMENT=development

# Для staging используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@staging-db:5432/fastapi_staging
# DEBUG=False
# ENVIRONMENT=staging
# REQUIRE_HTTPS=True

# Для production используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@prod-db:5432/fastapi_prod
# DEBUG=False
# ENVIRONMENT=production
# REQUIRE_HTTPS=True
# RATE_LIMITING_ENABLED=True
# PROMETHEUS_ENABLED=True

# ====================================================================
# БЕЗОПАСНОСТЬ
# ====================================================================

# ⚠️ НИКОГДА не коммитьте этот файл в git, если в нем реальные значения!
# Используйте: git update-index --assume-unchanged .env

# ✅ Рекомендуемые настройки для .gitignore:
# .env
# .env.local
# .env.*.local
# .env.production

# ✅ Для разработки скопируйте этот файл:
# cp .env.example .env

# ✅ Для production используйте переменные окружения системы:
# export SECRET_KEY=your-secret-key
# export DATABASE_URL=postgresql+asyncpg://...

# ====================================================================
</file>

<file path="main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.auth_router import router as auth_router
from app.users_router import router as users_router
from app.database import engine
from app.models import Base
import uvicorn



@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown
    await engine.dispose()

app = FastAPI(
    title="FastAPI Authentication API",
    description="Complete registration and OAuth2 integration",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:5173",
                   "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(auth_router)
app.include_router(users_router)

@app.get("/health")
async def health_check():
    return {"status": "ok"}
</file>

<file path="README.md">
# VTB_API_HACK
</file>

<file path="app/security/oauth2.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.security.jwt_handler import decode_token

security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> int:
    token = credentials.credentials
    user_id = decode_token(token)
    
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )
    
    return user_id
</file>

<file path="app/security/password.py">
from passlib.context import CryptContext
from passlib.exc import InvalidHashError

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except (InvalidHash, ValueError):
        return False
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: fastapi_user
      POSTGRES_PASSWORD: fastapi_password
      POSTGRES_DB: fastapi_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U fastapi_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://fastapi_user:fastapi_password@postgres:5432/fastapi_db
      REDIS_URL: redis://redis:6379/0
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app

volumes:
  postgres_data:
</file>

<file path="requirements.txt">
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9
python-dotenv==1.0.0
pydantic==2.5.0
pydantic-settings==2.1.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
httpx==0.25.2
aioredis==2.0.1
celery==5.3.4
redis==5.0.1
requests==2.31.0
email-validator==2.1.0
bcrypt==4.0.1
passlib==1.7.4
asyncpg==0.30.0
aiohttp==3.13.2
</file>

<file path="app/auth_router.py">
import secrets
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.schemas import UserRegister, UserResponse, SMSVerificationRequest, SMSVerificationConfirm
from app.auth_schemas import TokenResponse, TokenRequest, RefreshTokenRequest
from app.models import User
from app.database import get_db
from app.services.sms_service import sms_service
from app.services.oauth_service import oauth_service
from app.services.bank_oauth_service import oauth_bank_service
from app.security.password import hash_password, verify_password
from app.security.jwt_handler import create_access_token, create_refresh_token, decode_token
from app.config import get_settings
from datetime import datetime, timedelta
import logging

router = APIRouter(prefix="/auth", tags=["auth"])
settings = get_settings()
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register(user_data: UserRegister, db: AsyncSession = Depends(get_db)):
    """Регистрация пользователя"""
    # Проверка существования пользователя
    result = await db.execute(
        select(User).where((User.email == user_data.email) | (User.phone_number == user_data.phone_number))
    )
    if result.scalars().first():
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email или номер телефона уже зарегистрирован"
        )
    
    # Создание пользователя
    user = User(
        email=user_data.email,
        phone_number=user_data.phone_number,
        first_name=user_data.first_name,
        last_name=user_data.last_name,
        hashed_password=hash_password(user_data.password),
        is_active=False
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    
    # Отправка SMS кода
    sms_sent = await sms_service.send_registration_code(user_data.phone_number, db)
    if not sms_sent:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ошибка отправки SMS"
        )
    
    return UserResponse.from_orm(user)

@router.post("/verify-sms")
async def verify_sms(data: SMSVerificationConfirm, db: AsyncSession = Depends(get_db)):
    """Проверка SMS кода"""
    
    # Проверка кода
    verified = await sms_service.verify_sms_code(data.phone_number, data.code, db)
    if not verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Неверный или истекший код"
        )
    
    # Обновление пользователя
    result = await db.execute(select(User).where(User.phone_number == data.phone_number))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_phone_verified = True
    user.is_active = True
    await db.commit()
    
    return {"message": "Номер телефона успешно подтвержден"}

@router.post("/login", response_model=TokenResponse)
async def login(credentials: TokenRequest, db: AsyncSession = Depends(get_db)):
    """Вход в систему"""
    
    result = await db.execute(select(User).where(User.email == credentials.email))
    user = result.scalars().first()
    
    if not user or not verify_password(credentials.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Генерация токенов
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token(user.id)
    
    # Обновление последнего входа
    user.last_login = datetime.utcnow()
    await db.commit()
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh(request: RefreshTokenRequest, db: AsyncSession = Depends(get_db)):
    """Обновление access токена"""
    
    user_id = decode_token(request.refresh_token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )
    
    access_token = create_access_token({"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=request.refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.get("/oauth/authorize")
async def oauth_authorize(db: AsyncSession = Depends(get_db)):
    """
    Инициирование OAuth flow с полным циклом получения банковских данных
    
    НОВЫЙ АЛГОРИТМ (vbank.open.bankingapi.ru):
    1. Получить токен банка
    2. Запросить согласие (авто-одобрение)
    3. Получить данные счетов
    """
    try:
        logger.info("Starting OAuth authorize flow...")
        
        # Генерируем временный ID для отслеживания сессии
        session_id = secrets.token_urlsafe(16)
        logger.info(f"Session ID: {session_id}")
        
        # ============ НОВАЯ ЛОГИКА: Полный цикл работы с банком ============
        
        # Выполняем полный цикл получения банковских счетов
        logger.info("Executing full bank account retrieval cycle...")
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            logger.error(f"Bank cycle failed: {bank_data.get('error')}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Failed to retrieve bank data: {bank_data.get('error')}"
            )
        
        # Извлекаем данные из успешного ответа
        bills = bank_data.get("bills")
        consent_id = bank_data.get("consent_id")
        auto_approved = bank_data.get("auto_approved", True)
        
        logger.info(f"Successfully retrieved {len(bills)} accounts")
        logger.info(f"Consent ID: {consent_id}, Auto-approved: {auto_approved}")
        
        # Сохраняем в сессию для дальнейшего использования
        # Это можно использовать при создании пользователя
        session_data = {
            "bank_accounts": bills,
            "consent_id": consent_id,
            "auto_approved": auto_approved,
            "retrieved_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"Session data prepared: {session_data}")
        
        # Перенаправляем на банк для авторизации пользователя
        # (или если банк уже авторизовал, перенаправляем на callback)
        auth_url = oauth_service.generate_authorization_url(session_id)
        
        logger.info(f"Redirecting to bank authorization URL")
        return RedirectResponse(url=auth_url)
        
    except Exception as e:
        logger.error(f"Error in oauth_authorize: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth authorization failed: {str(e)}"
        )

@router.get("/oauth/callback")
async def oauth_callback(code: str, state: str, db: AsyncSession = Depends(get_db)):
    """
    Callback от банка после авторизации пользователя
    На этом этапе мы уже имеем:
    - Данные счетов пользователя
    - Согласие на доступ
    - Информацию о пользователе
    """
    try:
        logger.info(f"OAuth callback received with state: {state}")
        
        # Валидация состояния
        oauth_session = await oauth_service.validate_oauth_state(state, db)
        if not oauth_session:
            logger.error(f"Invalid OAuth state: {state}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state"
            )
        
        # Обмен кода на токен у банка
        logger.info("Exchanging authorization code for token...")
        token_response = await oauth_service.exchange_code_for_token(
            code, 
            oauth_session["code_verifier"]
        )
        
        if not token_response:
            logger.error("Failed to exchange code for token")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to exchange code for token"
            )
        
        # Получение информации о пользователе от банка
        logger.info("Retrieving user info from bank...")
        user_info = await oauth_service.get_user_info(token_response.get("access_token"))
        
        if not user_info:
            logger.error("Failed to get user info")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to get user info"
            )
        
        # Поиск или создание пользователя
        oauth_id = user_info.get("sub")
        logger.info(f"Looking up user with oauth_id: {oauth_id}")
        
        result = await db.execute(
            select(User).where((User.oauth_id == oauth_id) | (User.email == user_info.get("email")))
        )
        user = result.scalars().first()
        
        if not user:
            logger.info(f"Creating new user from OAuth info")
            user = User(
                email=user_info.get("email"),
                phone_number=user_info.get("phone_number", ""),
                first_name=user_info.get("given_name", ""),
                last_name=user_info.get("family_name", ""),
                oauth_provider="bank",
                oauth_id=oauth_id,
                is_active=True,
                is_phone_verified=True,
                is_email_verified=True,
                hashed_password=hash_password(secrets.token_urlsafe(32))
            )
            db.add(user)
            await db.commit()
            await db.refresh(user)
            logger.info(f"New user created: {user.id}")
        else:
            logger.info(f"Existing user found: {user.id}")
        
        # Генерация токенов
        logger.info("Generating access and refresh tokens...")
        access_token = create_access_token({"sub": str(user.id)})
        refresh_token = create_refresh_token(user.id)
        
        logger.info(f"OAuth callback completed successfully for user {user.id}")
        
        # Перенаправление на фронтенд с токенами
        redirect_url = f"{settings.FRONTEND_URL}/auth/success?access_token={access_token}&refresh_token={refresh_token}"
        return RedirectResponse(url=redirect_url)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in oauth_callback: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth callback failed: {str(e)}"
        )

@router.get("/oauth/bank-bills")
async def get_oauth_bank_accounts(db: AsyncSession = Depends(get_db)):
    """
    Эндпоинт для получения банковских счетов пользователя через OAuth
    Использует полный цикл получения данных от банка
    """
    try:
        logger.info("Getting bank accounts through full OAuth cycle...")
        
        # Можно передать реальный user_id вместо session_id
        session_id = secrets.token_urlsafe(16)
        
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=bank_data.get("error")
            )
        
        return {
            "success": True,
            "accounts": bank_data.get("accounts", []),
            "consent_id": bank_data.get("consent_id"),
            "auto_approved": bank_data.get("auto_approved", True)
        }
        
    except Exception as e:
        logger.error(f"Error getting bank accounts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get bank accounts: {str(e)}"
        )
</file>

<file path="app/config.py">
from pydantic_settings import BaseSettings
from typing import Optional
import uuid
from functools import lru_cache

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db"
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # JWT
    SECRET_KEY: str = "aMeucfHi2Xxl3v0LYb1Tcduk-NuQOOjGVrTxqhDrT0A"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # SMS
    SMS_SERVICE_PROVIDER: str = "sms_ru"
    SMS_API_KEY: uuid.UUID = uuid.UUID("18608A37-567C-3C70-F128-03938B6AF52A")
    SMS_FROM_NAME: str = "YourApp"
    
    # OAuth2
    BANK_API_URL: str = "https://vbank.open.bankingapi.ru"
    BANK_CLIENT_ID: str = "team261-1"
    BANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    BANK_REDIRECT_URI: str = "https://vbank.open.bankingapi.ru/client"
    '''
    # Frontend
    FRONTEND_URL: str
    '''
    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings():
    return Settings()
</file>

</files>
</file>

<file path="Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Установка зависимостей
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Копирование requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование приложения
COPY . .

# Запуск приложения
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="env.example">
# ====================================================================
# FastAPI Authentication & Authorization System
# Пример конфигурационного файла
# ====================================================================

# -------- DATABASE --------
# PostgreSQL асинхронное подключение
# Формат: postgresql+asyncpg://user:password@host:port/database
DATABASE_URL=postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db

# Redis для кэширования и сессий
REDIS_URL=redis://localhost:6379/0

# -------- JWT SETTINGS --------
# Секретный ключ для подписи JWT токенов
# Минимум 32 символа, используйте: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-super-secret-key-minimum-32-characters-long-generate-it-securely

# Алгоритм подписи JWT
ALGORITHM=HS256

# Время жизни access токена в минутах
ACCESS_TOKEN_EXPIRE_MINUTES=15

# Время жизни refresh токена в днях
REFRESH_TOKEN_EXPIRE_DAYS=7

# -------- SMS SERVICE --------
# Выбор провайдера SMS
# Опции: sms_ru, twilio, aws_sns, sendpulse
SMS_SERVICE_PROVIDER=sms_ru

# API ключ для SMS сервиса
# Получите на https://sms.ru или у выбранного провайдера
SMS_API_KEY=your_sms_api_key_here

# Имя отправителя для SMS (максимум 11 символов)
SMS_FROM_NAME=YourApp

# Максимальное количество попыток ввода SMS кода
SMS_MAX_ATTEMPTS=3

# Время действия SMS кода в минутах
SMS_CODE_EXPIRY_MINUTES=10

# -------- OAUTH2 / OPENID CONNECT --------
# URL банковского API (согласно ФАПИ Банка России)
BANK_API_URL=https://vbank.open.bankingapi.ru

# Client ID от банка для OAuth2
BANK_CLIENT_ID=your_bank_client_id_here

# Client Secret от банка для OAuth2
BANK_CLIENT_SECRET=your_bank_client_secret_here

# Redirect URI для OAuth2 callback
# Должен совпадать с зарегистрированным в банке
BANK_REDIRECT_URI=http://localhost:8000/auth/oauth/callback

# Scope для доступа к банковским данным
# Опции: openid, profile, accounts, transactions, payments
BANK_SCOPES=openid profile accounts

# -------- EMAIL SETTINGS --------
# SMTP сервер для отправки email
SMTP_SERVER=smtp.gmail.com

# Порт SMTP
SMTP_PORT=587

# Email адрес отправителя
SMTP_USER=your_email@gmail.com

# Пароль приложения Gmail (не основной пароль!)
# Используйте: https://myaccount.google.com/apppasswords
SMTP_PASSWORD=your_app_password_here

# Email для отправки писем с подтверждением
FROM_EMAIL=noreply@yourapp.com

# -------- APPLICATION SETTINGS --------
# Frontend URL для перенаправлений
FRONTEND_URL=http://localhost:3000

# Окружение приложения (development, staging, production)
ENVIRONMENT=development

# Режим отладки (включает более подробные логи)
DEBUG=True

# -------- SECURITY --------
# Требовать HTTPS в production
REQUIRE_HTTPS=False  # Установите True в production

# CORS разрешенные домены (comma-separated)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000

# -------- LOGGING --------
# Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Директория для логов
LOG_DIR=./logs

# -------- RATE LIMITING --------
# Включить rate limiting
RATE_LIMITING_ENABLED=True

# Максимум запросов в минуту для анонимных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Максимум запросов в минуту для авторизованных пользователей
RATE_LIMIT_REQUESTS_PER_MINUTE_AUTHENTICATED=100

# -------- MONITORING --------
# Включить Prometheus метрики
PROMETHEUS_ENABLED=False

# -------- OPTIONAL SETTINGS --------
# Максимальный размер запроса в MB
MAX_REQUEST_SIZE=10

# Таймаут для подключения к внешним сервисам (секунды)
EXTERNAL_SERVICE_TIMEOUT=30

# Количество рабочих процессов Uvicorn
WORKERS=4

# ====================================================================
# ИНСТРУКЦИИ ПО ПОЛУЧЕНИЮ ЗНАЧЕНИЙ
# ====================================================================

# 1. SECRET_KEY:
#    python -c "import secrets; print(secrets.token_urlsafe(32))"

# 2. SMS_API_KEY (sms.ru):
#    - Перейти на https://sms.ru
#    - Зарегистрироваться
#    - Получить API ID в личном кабинете
#    - Добавить номер в доверенные

# 3. BANK_CLIENT_ID и BANK_CLIENT_SECRET:
#    - Обратиться к банку (Сбербанк, ВТБ, и т.д.)
#    - Получить учетные данные OAuth2
#    - Согласовать redirect_uri

# 4. SMTP_PASSWORD (Gmail):
#    - Перейти на https://myaccount.google.com/apppasswords
#    - Выбрать приложение "Mail" и устройство "Windows/Mac/Linux"
#    - Скопировать сгенерированный пароль

# 5. BANK_REDIRECT_URI:
#    - В development: http://localhost:8000/auth/oauth/callback
#    - В production: https://yourdomain.com/auth/oauth/callback

# ====================================================================
# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
# ====================================================================

# Для разработки используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/fastapi_dev
# DEBUG=True
# ENVIRONMENT=development

# Для staging используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@staging-db:5432/fastapi_staging
# DEBUG=False
# ENVIRONMENT=staging
# REQUIRE_HTTPS=True

# Для production используйте:
# DATABASE_URL=postgresql+asyncpg://user:password@prod-db:5432/fastapi_prod
# DEBUG=False
# ENVIRONMENT=production
# REQUIRE_HTTPS=True
# RATE_LIMITING_ENABLED=True
# PROMETHEUS_ENABLED=True

# ====================================================================
# БЕЗОПАСНОСТЬ
# ====================================================================

# ⚠️ НИКОГДА не коммитьте этот файл в git, если в нем реальные значения!
# Используйте: git update-index --assume-unchanged .env

# ✅ Рекомендуемые настройки для .gitignore:
# .env
# .env.local
# .env.*.local
# .env.production

# ✅ Для разработки скопируйте этот файл:
# cp .env.example .env

# ✅ Для production используйте переменные окружения системы:
# export SECRET_KEY=your-secret-key
# export DATABASE_URL=postgresql+asyncpg://...

# ====================================================================
</file>

<file path="README.md">
# VTB_API_HACK
</file>

<file path="app/security/oauth2.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.security.jwt_handler import decode_token

security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> int:
    token = credentials.credentials
    user_id = decode_token(token)
    
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )
    
    return user_id
</file>

<file path="app/services/bank_oauth_service.py">
import aiohttp
import secrets
from datetime import datetime, timedelta
from urllib.parse import urlencode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional, Dict
from app.config import get_settings
from app.models import OAuthSession, User
import logging


settings = get_settings()
logger = logging.getLogger(__name__)


class OAuth2BankService:
    """
    Универсальный сервис для работы с банковским API для трёх банков.
    Поддерживает: vbank, abank, sbank
    
    Usage:
        service = OAuth2BankService(bank_code="vbank")
        result = await service.get_bank_accounts_full_cycle(user_id="123")
    """
    
    def __init__(self, bank_code: str):
        """
        Инициализация сервиса для конкретного банка
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Raises:
            ValueError: Если bank_code неизвестен
        """
        # Получаем конфигурацию для выбранного банка
        self.bank_code = bank_code
        bank_config = settings.get_bank_config(bank_code)
        
        # Устанавливаем параметры из конфигурации
        self.bank_api_url = bank_config.api_url
        self.client_id = bank_config.client_id
        self.client_secret = bank_config.client_secret
        self.requesting_bank = bank_config.requesting_bank
        self.requesting_bank_name = bank_config.requesting_bank_name
        self.redirecting_url = bank_config.redirecting_url
        
        
        logger.info(f"[{self.bank_code}] Initialized OAuth2BankService with URL: {self.bank_api_url}")
    
    # ============ ШАГ 1: Получение токена банка ============
    async def get_bank_access_token(self) -> Optional[str]:
        """
        Получить access token банка для доступа к данным клиентов
        
        POST https://{bank}.open.bankingapi.ru/auth/bank-token
        ?client_id=team261&client_secret=YOUR_SECRET
        
        Returns:
            str: access_token для использования в дальнейших запросах
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/auth/bank-token"
                params = {
                    "client_id": self.requesting_bank,
                    "client_secret": self.client_secret
                }
                
                logger.info(f"[{self.bank_code}] Getting bank token from {url}")
                async with session.post(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        access_token = data.get("access_token")
                        logger.info(f"[{self.bank_code}] Successfully obtained bank access token")
                        return access_token
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to get bank token: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error getting bank token: {e}")
            return None
    
    # ============ ШАГ 2: Запрос согласия (авто-одобрение) ============
    async def request_account_consent(self, access_token: str, user_id: str) -> Optional[Dict]:
        """
        Запросить согласие на доступ к счетам пользователя
        
        POST https://{bank}.open.bankingapi.ru/account-consents/request
        
        Args:
            access_token: Токен банка (из шага 1)
            user_id: ID пользователя
        
        Returns:
            dict: {"status": "approved", "consent_id": "...", "auto_approved": true}
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/account-consents/request"
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "Content-Type": "application/json"
                }
                
                body = {
                    "client_id": f"{user_id}",
                    "permissions": ["ReadAccountsDetail", "ReadBalances"],
                    "reason": "Агрегация счетов для HackAPI",
                    "requesting_bank": self.requesting_bank,
                    "requesting_bank_name": self.requesting_bank_name
                }
                
                logger.info(f"[{self.bank_code}] Requesting account consent for user {user_id}")
                async with session.post(url, json=body, headers=headers) as resp:
                    if resp.status in [200, 201]:
                        data = await resp.json()
                        consent_id = data.get("consent_id")
                        logger.info(f"[{self.bank_code}] Consent received: {consent_id}")
                        return {
                            "status": data.get("status", "approved"),
                            "consent_id": consent_id,
                            "auto_approved": data.get("auto_approved", True)
                        }
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to request consent for user {user_id}: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error requesting consent: {e}")
            return None
    
    # ============ ШАГ 3: Получить данные счетов ============
    async def get_user_accounts(self, access_token: str, user_id: str, consent_id: str) -> Optional[Dict]:
        """
        Получить список счетов пользователя
        
        GET https://{bank}.open.bankingapi.ru/accounts?client_id={user_id}
        
        Args:
            access_token: Токен банка
            user_id: ID пользователя
            consent_id: ID согласия (из шага 2)
        
        Returns:
            dict: {"accounts": [...]} или {"data": {"account": [...]}}
            None: При ошибке
        """
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.bank_api_url}/accounts"
                
                params = {
                    "client_id": f"{user_id}"
                }
                
                headers = {
                    "Authorization": f"Bearer {access_token}",
                    "X-Requesting-Bank": self.requesting_bank,
                    "X-Consent-Id": consent_id,
                    "Accept": "application/json"
                }
                
                logger.info(f"[{self.bank_code}] Fetching accounts for user {user_id}")
                async with session.get(url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        
                        # Поддержка разных форматов ответа
                        if 'data' in data and 'account' in data['data']:
                            accounts = data['data']['account']
                        elif 'accounts' in data:
                            accounts = data['accounts']
                        else:
                            accounts = []
                        
                        logger.info(f"[{self.bank_code}] Successfully fetched {len(accounts)} accounts")
                        return data
                    else:
                        error_text = await resp.text()
                        logger.error(f"[{self.bank_code}] Failed to fetch accounts: {resp.status} - {error_text}")
                        return None
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error fetching accounts: {e}")
            return None
    
    # ============ КОМПЛЕКСНЫЙ МЕТОД: Полный цикл ============
    async def get_bank_accounts_full_cycle(self, user_id: str) -> Dict:
        """
        Выполнить полный цикл получения счетов пользователя:
        1. Получить access token банка
        2. Запросить согласие
        3. Получить данные счетов
        
        Args:
            user_id: ID пользователя
        
        Returns:
            dict: {
                "success": True/False,
                "bank_code": "vbank",
                "bills": [...],  # Список счетов
                "consent_id": "...",
                "auto_approved": True/False,
                "error": "..." (если есть)
            }
        """
        try:
            logger.info(f"[{self.bank_code}] ===== STARTING FULL CYCLE for user {user_id} =====")
            
            # ШАГ 1: Получить токен банка
            logger.info(f"[{self.bank_code}] STEP 1: Getting bank access token...")
            access_token = await self.get_bank_access_token()
            
            if not access_token:
                logger.error(f"[{self.bank_code}] STEP 1 FAILED: No access token")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to obtain bank access token"
                }
            
            logger.info(f"[{self.bank_code}] STEP 1 SUCCESS: Access token obtained")
            
            # ШАГ 2: Запросить согласие
            logger.info(f"[{self.bank_code}] STEP 2: Requesting account consent...")
            consent_data = await self.request_account_consent(access_token, user_id)
            
            if not consent_data:
                logger.error(f"[{self.bank_code}] STEP 2 FAILED: No consent")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to request account consent"
                }
            
            consent_id = consent_data.get("consent_id")
            logger.info(f"[{self.bank_code}] STEP 2 SUCCESS: Consent ID = {consent_id}")
            
            # ШАГ 3: Получить счета
            logger.info(f"[{self.bank_code}] STEP 3: Fetching user accounts...")
            accounts_data = await self.get_user_accounts(access_token, user_id, consent_id)
            
            if not accounts_data:
                logger.error(f"[{self.bank_code}] STEP 3 FAILED: No accounts data")
                return {
                    "success": False,
                    "bank_code": self.bank_code,
                    "error": "Failed to fetch accounts"
                }
            
            # Извлекаем счета в зависимости от формата ответа
            if 'data' in accounts_data and 'account' in accounts_data['data']:
                bills = accounts_data['data']['account']
            elif 'accounts' in accounts_data:
                bills = accounts_data['accounts']
            else:
                bills = []
            
            logger.info(f"[{self.bank_code}] STEP 3 SUCCESS: Fetched {len(bills)} accounts")
            logger.info(f"[{self.bank_code}] ===== FULL CYCLE COMPLETED SUCCESSFULLY =====")
            
            return {
                "success": True,
                "bank_code": self.bank_code,
                "bills": bills,
                "consent_id": consent_id,
                "auto_approved": consent_data.get("auto_approved", True),
                "raw_data": accounts_data  # Полные данные для отладки
            }
        
        except Exception as e:
            logger.error(f"[{self.bank_code}] Error in full cycle: {e}")
            return {
                "success": False,
                "bank_code": self.bank_code,
                "error": str(e)
            }


# ============ УТИЛИТАРНЫЕ ФУНКЦИИ ============

async def get_accounts_from_all_banks(user_id: str) -> Dict[str, Dict]:
    """
    Получить счета из всех трёх банков
    
    Args:
        user_id: ID пользователя
    
    Returns:
        dict: {
            "vbank": {"success": True, "bills": [...], ...},
            "abank": {"success": True, "bills": [...], ...},
            "sbank": {"success": False, "error": "..."}
        }
    """
    results = {}
    
    for bank_code in ["vbank", "abank", "sbank"]:
        logger.info(f"Processing bank: {bank_code}")
        try:
            service = OAuth2BankService(bank_code=bank_code)
            result = await service.get_bank_accounts_full_cycle(user_id)
            results[bank_code] = result
        except ValueError as e:
            # Банк не настроен в конфигурации
            logger.warning(f"Bank {bank_code} not configured: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": f"Bank not configured: {str(e)}"
            }
        except Exception as e:
            logger.error(f"Error processing bank {bank_code}: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": str(e)
            }
    
    return results


async def get_accounts_from_specific_banks(user_id: str, bank_codes: list) -> Dict[str, Dict]:
    """
    Получить счета из указанных банков
    
    Args:
        user_id: ID пользователя
        bank_codes: Список кодов банков, например ["vbank", "abank"]
    
    Returns:
        dict: {
            "vbank": {"success": True, "bills": [...]},
            "abank": {"success": True, "bills": [...]}
        }
    """
    results = {}
    
    for bank_code in bank_codes:
        logger.info(f"Processing bank: {bank_code}")
        try:
            service = OAuth2BankService(bank_code=bank_code)
            result = await service.get_bank_accounts_full_cycle(user_id)
            results[bank_code] = result
        except Exception as e:
            logger.error(f"Error processing bank {bank_code}: {e}")
            results[bank_code] = {
                "success": False,
                "bank_code": bank_code,
                "error": str(e)
            }
    
    return results
</file>

<file path="app/services/oauth_service.py">
import secrets
import aiohttp
from datetime import datetime, timedelta
from urllib.parse import urlencode
from jose import jwt
from sqlalchemy.ext.asyncio import AsyncSession
from app.config import get_settings
from app.models import OAuthSession
from sqlalchemy import select

settings = get_settings()

class OAuth2Service:
    
    async def generate_oauth_state(self, provider: str, db: AsyncSession) -> dict:
        """Генерация состояния для OAuth flow"""
        state = secrets.token_urlsafe(32)
        code_verifier = secrets.token_urlsafe(32)
        
        oauth_session = OAuthSession(
            state=state,
            code_verifier=code_verifier,
            provider=provider,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        db.add(oauth_session)
        await db.commit()
        
        return {
            "state": state,
            "code_verifier": code_verifier
        }
    
    def generate_authorization_url(self, state: str, bank) -> str:
        """Генерация URL для перенаправления на банковский API"""
        
        params = {
            "response_type": "code",
            "client_id": bank.client_id,
            "redirect_uri": bank.redirect_url,
            "scope": "openid profile accounts",
            "state": state,
            "nonce": secrets.token_urlsafe(16),
            "code_challenge_method": "S256",
        }
        
        return f"{settings.BANK_API_URL}/oauth/authorize?{urlencode(params)}"
    
    async def exchange_code_for_token(self, code: str, code_verifier: str) -> dict:
        """Обмен кода на токен"""
        async with aiohttp.ClientSession() as session:
            data = {
                "grant_type": "authorization_code",
                "code": code,
                "client_id": settings.BANK_CLIENT_ID,
                "client_secret": settings.BANK_CLIENT_SECRET,
                "redirect_uri": settings.BANK_REDIRECT_URI,
                "code_verifier": code_verifier
            }
            
            async with session.post(
                f"{settings.BANK_API_URL}/oauth/token",
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def get_user_info(self, access_token: str) -> dict:
        """Получение информации о пользователе"""
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {access_token}"}
            async with session.get(
                f"{settings.BANK_API_URL}/oauth/userinfo",
                headers=headers
            ) as resp:
                if resp.status == 200:
                    return await resp.json()
                return None
    
    async def validate_oauth_state(self, state: str, db: AsyncSession) -> dict:
        """Валидация состояния OAuth"""
        result = await db.execute(
            select(OAuthSession).where(
                OAuthSession.state == state,
                OAuthSession.expires_at > datetime.utcnow()
            )
        )
        session = result.scalars().first()
        
        if not session:
            return None
        
        return {
            "state": session.state,
            "code_verifier": session.code_verifier,
            "provider": session.provider
        }

oauth_service = OAuth2Service()
</file>

<file path="app/services/sms_service.py">
import aiohttp
import random
from datetime import datetime, timedelta
from app.config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import SMSVerification
from sqlalchemy import select

settings = get_settings()

class SMSService:
    async def send_sms(self, phone_number: str, message: str) -> bool:
        """Отправка SMS через API"""
        try:
            if settings.SMS_SERVICE_PROVIDER == "sms_ru":
                return await self._send_sms_ru(phone_number, message)
            return True
        except Exception as e:
            print(f"SMS error: {e}")
            return False
    
    async def _send_sms_ru(self, phone_number: str, message: str) -> bool:
        """SMS через sms.ru"""
        async with aiohttp.ClientSession() as session:
            data = {
                "api_id": settings.SMS_API_KEY,
                "to": phone_number.lstrip("+"),
                "msg": message,
                "json": 1
            }
            async with session.post("https://sms.ru/sms/send", data=data) as resp:
                result = await resp.json()
                return result.get("status") == "OK"
    
    async def generate_sms_code(self) -> str:
        """Генерация 6-значного кода"""
        return "".join([str(random.randint(0, 9)) for _ in range(6)])
    
    async def send_registration_code(self, phone_number: str, db: AsyncSession) -> bool:
        """Отправка кода регистрации"""
        # Проверяем, существует ли уже запись для этого номера
        result = await db.execute(
            select(SMSVerification).where(SMSVerification.phone_number == phone_number)
        )
        existing_verification = result.scalars().first()
        
        code = await self.generate_sms_code()
        current_time = datetime.utcnow()
        
        if existing_verification:
            # Если запись существует, обновляем ее
            existing_verification.code = code
            existing_verification.attempts = 0
            existing_verification.expires_at = current_time + timedelta(minutes=10)
            existing_verification.verified = False
            db.add(existing_verification)
        else:
            # Если записи нет, создаем новую
            sms_verification = SMSVerification(
                phone_number=phone_number,
                code=code,
                expires_at=current_time + timedelta(minutes=10)
            )
            db.add(sms_verification)
        
        await db.commit()
        
        message = f"Ваш код подтверждения: {code}. Действителен 10 минут."
        return await self.send_sms(phone_number, message)
    
    async def verify_sms_code(self, phone_number: str, code: str, db: AsyncSession) -> bool:
        """Проверка SMS кода"""
        result = await db.execute(
            select(SMSVerification).where(
                SMSVerification.phone_number == phone_number
            ).order_by(SMSVerification.created_at.desc())
        )
        verification = result.scalars().first()
        
        if not verification:
            return False
        
        if verification.expires_at < datetime.utcnow():
            return False
        
        if verification.attempts >= 3:
            return False
        
        if verification.code != code:
            verification.attempts += 1
            await db.commit()
            return False
        
        verification.verified = True
        await db.commit()
        return True

sms_service = SMSService()
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: fastapi_user
      POSTGRES_PASSWORD: fastapi_password
      POSTGRES_DB: fastapi_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U fastapi_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://fastapi_user:fastapi_password@postgres:5432/fastapi_db
      REDIS_URL: redis://redis:6379/0
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - .:/app

volumes:
  postgres_data:
</file>

<file path="main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.auth_router import router as auth_router
from app.users_router import router as users_router
from app.bank_api_router import router as bank_router
from app.database import engine
from app.models import Base
import uvicorn



@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown
    await engine.dispose()

app = FastAPI(
    title="FastAPI Authentication API",
    description="Complete registration and OAuth2 integration",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:5173",
                   "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(auth_router)
app.include_router(users_router)
app.include_router(bank_router)

@app.get("/health")
async def health_check():
    return {"status": "ok"}
</file>

<file path="vtb_api_hack.session.sql">
-- TRUNCATE TABLE users;
-- SELECT * FROM users;
-- TRUNCATE TABLE sms_verifications;
</file>

<file path="app/security/password.py">
from passlib.context import CryptContext
from passlib.exc import InvalidHashError

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except (InvalidHashError, ValueError):
        return False
</file>

<file path="requirements.txt">
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9
python-dotenv==1.0.0
pydantic==2.5.0
pydantic-settings==2.1.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
httpx==0.25.2
aioredis==2.0.1
celery==5.3.4
redis==5.0.1
requests==2.31.0
email-validator==2.1.0
bcrypt==4.0.1
passlib==1.7.4
asyncpg==0.30.0
aiohttp==3.13.2
</file>

<file path="app/config.py">
from pydantic_settings import BaseSettings
from functools import lru_cache
from typing import Dict

class BankConfig(BaseSettings):
    api_url: str
    client_id: str
    client_secret: str
    requesting_bank: str
    requesting_bank_name: str
    redirecting_url: str


class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://fastapi_user:fastapi_password@localhost:5432/fastapi_db"
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # JWT
    SECRET_KEY: str = "aMeucfHi2Xxl3v0LYb1Tcduk-NuQOOjGVrTxqhDrT0A"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    
    # SMS
    SMS_SERVICE_PROVIDER: str = "sms_ru"
    SMS_API_KEY: str = "18608A37-567C-3C70-F128-03938B6AF52A"
    SMS_FROM_NAME: str = "YourApp"
    
    # Frontend
    #FRONTEND_URL: str
    
    # ==================== КОНФИГУРАЦИЯ ДЛЯ ТРЁХ БАНКОВ ====================
    
    # Virtual Bank (vbank)
    VBANK_API_URL: str = "https://vbank.open.bankingapi.ru"
    VBANK_CLIENT_ID: str = "team261-1"
    VBANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    VBANK_REQUESTING_BANK: str = "team261"
    VBANK_REQUESTING_BANK_NAME: str = "Team 200 Virtual Bank App"
    VBANK_REDIRECTING_URL: str = "https://vbank.open.bankingapi.ru/client/"
    
    # Awesome Bank (abank)
    ABANK_API_URL: str = "https://abank.open.bankingapi.ru"
    ABANK_CLIENT_ID: str = "team261-1"
    ABANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    ABANK_REQUESTING_BANK: str = "team261"
    ABANK_REQUESTING_BANK_NAME: str = "Team 200 Awesome Bank App"
    ABANK_REDIRECTING_URL: str = "https://abank.open.bankingapi.ru/client/"
    
    # Smart Bank (sbank)
    SBANK_API_URL: str = "https://sbank.open.bankingapi.ru"
    SBANK_CLIENT_ID: str = "team261-1"
    SBANK_CLIENT_SECRET: str = "gBRvg9R6lYhvWHAOQFOH1HGarl1q80Rt"
    SBANK_REQUESTING_BANK: str = "team261"
    SBANK_REQUESTING_BANK_NAME: str = "Team 200 Smart Bank App"
    SBANK_REDIRECTING_URL: str = "https://sbank.open.bankingapi.ru/client/"
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    def get_bank_config(self, bank_code: str) -> BankConfig:
        """
        Получить конфигурацию для конкретного банка
        
        Args:
            bank_code: Код банка ('vbank', 'abank', 'sbank')
        
        Returns:
            BankConfig с параметрами банка
        
        Raises:
            ValueError: Если банк не найден
        """
        bank_configs = {
            "vbank": BankConfig(
                api_url=self.VBANK_API_URL,
                client_id=self.VBANK_CLIENT_ID,
                client_secret=self.VBANK_CLIENT_SECRET,
                requesting_bank=self.VBANK_REQUESTING_BANK,
                requesting_bank_name=self.VBANK_REQUESTING_BANK_NAME,
                redirecting_url=self.VBANK_REDIRECTING_URL
            ),
            "abank": BankConfig(
                api_url=self.ABANK_API_URL,
                client_id=self.ABANK_CLIENT_ID,
                client_secret=self.ABANK_CLIENT_SECRET,
                requesting_bank=self.ABANK_REQUESTING_BANK,
                requesting_bank_name=self.ABANK_REQUESTING_BANK_NAME,
                redirecting_url=self.ABANK_REDIRECTING_URL
            ),
            "sbank": BankConfig(
                api_url=self.SBANK_API_URL,
                client_id=self.SBANK_CLIENT_ID,
                client_secret=self.SBANK_CLIENT_SECRET,
                requesting_bank=self.SBANK_REQUESTING_BANK,
                requesting_bank_name=self.SBANK_REQUESTING_BANK_NAME,
                redirecting_url=self.SBANK_REDIRECTING_URL
            )
        }
        
        if bank_code not in bank_configs:
            raise ValueError(f"Unknown bank code: {bank_code}. Available: {list(bank_configs.keys())}")
        
        return bank_configs[bank_code]
    
    def get_all_banks(self) -> Dict[str, BankConfig]:
        """Получить конфигурации всех банков"""
        return {
            "vbank": self.get_bank_config("vbank"),
            "abank": self.get_bank_config("abank"),
            "sbank": self.get_bank_config("sbank")
        }

@lru_cache()
def get_settings():
    return Settings()
</file>

<file path="app/auth_router.py">
import secrets
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.schemas import UserRegister, UserResponse, SMSVerificationRequest, SMSVerificationConfirm
from app.auth_schemas import TokenResponse, TokenRequest, RefreshTokenRequest
from app.models import User
from app.database import get_db
from app.services.sms_service import sms_service
from app.services.oauth_service import oauth_service
from app.services.bank_oauth_service import OAuth2BankService
from app.security.password import hash_password, verify_password
from app.security.jwt_handler import create_access_token, create_refresh_token, decode_token
from app.config import get_settings
from app.services.universal_bank_service import universal_bank_service
from datetime import datetime, timedelta
import logging

router = APIRouter(prefix="/auth", tags=["auth"])
settings = get_settings()
logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register(user_data: UserRegister, db: AsyncSession = Depends(get_db)):
    """Регистрация пользователя"""
    # Проверка существования пользователя
    result = await db.execute(
        select(User).where((User.email == user_data.email) | (User.phone_number == user_data.phone_number))
    )
    if result.scalars().first():
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email или номер телефона уже зарегистрирован"
        )
    
    # Создание пользователя
    user = User(
        email=user_data.email,
        phone_number=user_data.phone_number,
        first_name=user_data.first_name,
        last_name=user_data.last_name,
        hashed_password=hash_password(user_data.password),
        is_active=False
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    
    # Отправка SMS кода
    sms_sent = await sms_service.send_registration_code(user_data.phone_number, db)
    if not sms_sent:
        pass
        # raise HTTPException(
        #     status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        #     detail="Ошибка отправки SMS"
        # )
    
    return UserResponse.from_orm(user)

@router.post("/verify-sms")
async def verify_sms(data: SMSVerificationConfirm, db: AsyncSession = Depends(get_db)):
    """Проверка SMS кода"""
    
    # Проверка кода
    verified = await sms_service.verify_sms_code(data.phone_number, data.code, db)
    if not verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Неверный или истекший код"
        )
    
    # Обновление пользователя
    result = await db.execute(select(User).where(User.phone_number == data.phone_number))
    user = result.scalars().first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_phone_verified = True
    user.is_active = True
    await db.commit()
    
    return {"message": "Номер телефона успешно подтвержден"}

@router.post("/login", response_model=TokenResponse)
async def login(credentials: TokenRequest, db: AsyncSession = Depends(get_db)):
    """Вход в систему"""
    
    result = await db.execute(select(User).where(User.email == credentials.email))
    user = result.scalars().first()
    
    if not user:
        logger.warning(f"Login attempt with non-existent email: {credentials.email}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    logger.info(f"User found: {user.id}, is_active: {user.is_active}, hashed_password length: {len(user.hashed_password) if user.hashed_password else 0}")
    
    if not verify_password(credentials.password, user.hashed_password):
        logger.warning(f"Invalid password for user: {user.id}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль"
        )
    
    if not user.is_active:
        logger.warning(f"Inactive user attempted login: {user.id}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Генерация токенов
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token(user.id)
    
    # Обновление последнего входа
    user.last_login = datetime.utcnow()
    await db.commit()
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh(request: RefreshTokenRequest, db: AsyncSession = Depends(get_db)):
    """Обновление access токена"""
    
    user_id = decode_token(request.refresh_token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalars().first()
    
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )
    
    access_token = create_access_token({"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=request.refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@router.get("/oauth/authorize/{bank_id}")
async def oauth_authorize(db: AsyncSession = Depends(get_db), bank_code: str = ''):
    """
    Инициирование OAuth flow с полным циклом получения банковских данных
    
    НОВЫЙ АЛГОРИТМ (vbank.open.bankingapi.ru):
    1. Получить токен банка
    2. Запросить согласие (авто-одобрение)
    3. Получить данные счетов
    """
    bank = await universal_bank_service._get_bank_config(bank_code)
    
    try:
        logger.info("Starting OAuth authorize flow...")
        
        # Генерируем временный ID для отслеживания сессии
        session_id = secrets.token_urlsafe(16)
        logger.info(f"Session ID: {session_id}")
        
        # ============ НОВАЯ ЛОГИКА: Полный цикл работы с банком ============
        
        # Выполняем полный цикл получения банковских счетов
        logger.info("Executing full bank account retrieval cycle...")
        oauth_bank_service = OAuth2BankService(bank_code=bank_code)
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            logger.error(f"Bank cycle failed: {bank_data.get('error')}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Failed to retrieve bank data: {bank_data.get('error')}"
            )
        
        # Извлекаем данные из успешного ответа
        bills = bank_data.get("bills")
        consent_id = bank_data.get("consent_id")
        auto_approved = bank_data.get("auto_approved", True)
        
        logger.info(f"Successfully retrieved {len(bills)} accounts")
        logger.info(f"Consent ID: {consent_id}, Auto-approved: {auto_approved}")
        
        # Сохраняем в сессию для дальнейшего использования
        # Это можно использовать при создании пользователя
        session_data = {
            "bank_accounts": bills,
            "consent_id": consent_id,
            "auto_approved": auto_approved,
            "retrieved_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"Session data prepared: {session_data}")
        
        # Перенаправляем на банк для авторизации пользователя
        # (или если банк уже авторизовал, перенаправляем на callback)
        auth_url = oauth_service.generate_authorization_url(session_id, bank_data)
        
        logger.info(f"Redirecting to bank authorization URL")
        return RedirectResponse(url=auth_url)
        
    except Exception as e:
        logger.error(f"Error in oauth_authorize: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth authorization failed: {str(e)}"
        )

@router.get("/oauth/callback")
async def oauth_callback(code: str, state: str, db: AsyncSession = Depends(get_db)):
    """
    Callback от банка после авторизации пользователя
    На этом этапе мы уже имеем:
    - Данные счетов пользователя
    - Согласие на доступ
    - Информацию о пользователе
    """
    try:
        logger.info(f"OAuth callback received with state: {state}")
        
        # Валидация состояния
        oauth_session = await oauth_service.validate_oauth_state(state, db)
        if not oauth_session:
            logger.error(f"Invalid OAuth state: {state}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid state"
            )
        
        # Обмен кода на токен у банка
        logger.info("Exchanging authorization code for token...")
        token_response = await oauth_service.exchange_code_for_token(
            code, 
            oauth_session["code_verifier"]
        )
        
        if not token_response:
            logger.error("Failed to exchange code for token")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to exchange code for token"
            )
        
        # Получение информации о пользователе от банка
        logger.info("Retrieving user info from bank...")
        user_info = await oauth_service.get_user_info(token_response.get("access_token"))
        
        if not user_info:
            logger.error("Failed to get user info")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to get user info"
            )
        
        # Поиск или создание пользователя
        oauth_id = user_info.get("sub")
        logger.info(f"Looking up user with oauth_id: {oauth_id}")
        
        result = await db.execute(
            select(User).where((User.oauth_id == oauth_id) | (User.email == user_info.get("email")))
        )
        user = result.scalars().first()
        
        if not user:
            logger.info(f"Creating new user from OAuth info")
            user = User(
                email=user_info.get("email"),
                phone_number=user_info.get("phone_number", ""),
                first_name=user_info.get("given_name", ""),
                last_name=user_info.get("family_name", ""),
                oauth_provider="bank",
                oauth_id=oauth_id,
                is_active=True,
                is_phone_verified=True,
                is_email_verified=True,
                hashed_password=hash_password(secrets.token_urlsafe(32))
            )
            db.add(user)
            await db.commit()
            await db.refresh(user)
            logger.info(f"New user created: {user.id}")
        else:
            logger.info(f"Existing user found: {user.id}")
        
        # Генерация токенов
        logger.info("Generating access and refresh tokens...")
        access_token = create_access_token({"sub": str(user.id)})
        refresh_token = create_refresh_token(user.id)
        
        logger.info(f"OAuth callback completed successfully for user {user.id}")
        
        # Перенаправление на фронтенд с токенами
        redirect_url = f"{settings.FRONTEND_URL}/auth/success?access_token={access_token}&refresh_token={refresh_token}"
        return RedirectResponse(url=redirect_url)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in oauth_callback: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OAuth callback failed: {str(e)}"
        )

@router.get("/oauth/bank-bills")
async def get_oauth_bank_accounts(db: AsyncSession = Depends(get_db)):
    """
    Эндпоинт для получения банковских счетов пользователя через OAuth
    Использует полный цикл получения данных от банка
    """
    try:
        logger.info("Getting bank accounts through full OAuth cycle...")
        
        # Можно передать реальный user_id вместо session_id
        session_id = secrets.token_urlsafe(16)
        oauth_bank_service = OAuth2BankService(bank_code='vbank')
        bank_data = await oauth_bank_service.get_bank_accounts_full_cycle(session_id)
        
        if not bank_data.get("success"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=bank_data.get("error")
            )
        
        return {
            "success": True,
            "accounts": bank_data.get("accounts", []),
            "consent_id": bank_data.get("consent_id"),
            "auto_approved": bank_data.get("auto_approved", True)
        }
        
    except Exception as e:
        logger.error(f"Error getting bank accounts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get bank accounts: {str(e)}"
        )
</file>

</files>
